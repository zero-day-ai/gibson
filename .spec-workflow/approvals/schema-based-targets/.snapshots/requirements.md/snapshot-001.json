{
  "id": "snapshot_1767742925375_if3vfo98u",
  "approvalId": "approval_1767742925370_gzn8kqmsf",
  "approvalTitle": "Requirements: Schema-Based Target Types",
  "version": 1,
  "timestamp": "2026-01-06T23:42:05.375Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Document: Schema-Based Target Types\n\n## Introduction\n\nThe Gibson framework currently uses a URL-centric model for attack targets. This works well for HTTP-based AI systems (LLM APIs, chat interfaces) but fails for non-HTTP attack surfaces like Kubernetes clusters, smart contracts, internal APIs, or custom protocols.\n\nThis feature introduces schema-based target types where each target type defines its own JSON Schema for connection parameters. Agents declare which target schemas they support, enabling the framework to handle diverse attack surfaces through a single, extensible mechanism.\n\n**Value**: Enables Gibson to expand beyond HTTP-based AI systems to test Kubernetes security, blockchain smart contracts, and other non-traditional attack surfaces without framework modifications.\n\n## Alignment with Product Vision\n\nGibson's mission is autonomous AI security testing. As AI systems expand into:\n- Kubernetes-deployed ML pipelines\n- Blockchain-based AI oracles and smart contracts\n- Edge computing and IoT AI deployments\n- Multi-protocol AI agent systems\n\nThe framework must evolve to test these diverse surfaces. Schema-based targets provide the extensibility foundation for this expansion.\n\n## Requirements\n\n### Requirement 1: Target Schema Definition\n\n**User Story:** As an agent developer, I want to define a JSON Schema for my target type's connection parameters, so that users provide the correct information to connect to targets my agent can test.\n\n#### Acceptance Criteria\n\n1. WHEN an agent registers with Gibson THEN the agent SHALL declare its supported target schemas including type name, version, JSON Schema, and description\n2. IF a target schema defines required fields THEN Gibson SHALL reject targets missing those fields\n3. WHEN a target schema includes field descriptions THEN Gibson CLI SHALL display them in help output and interactive mode\n4. IF multiple agents support the same target type THEN they SHALL use compatible schemas (same required fields)\n\n### Requirement 2: Extensible Target Storage\n\n**User Story:** As a security operator, I want to create targets with type-specific connection parameters, so that I can test diverse systems (HTTP APIs, Kubernetes clusters, smart contracts) through the same Gibson interface.\n\n#### Acceptance Criteria\n\n1. WHEN creating a target THEN the user SHALL specify a target type and connection parameters as JSON\n2. IF the target type has a registered schema THEN Gibson SHALL validate connection parameters against the schema before storing\n3. WHEN listing targets THEN Gibson SHALL display the target type and key connection parameters\n4. IF a target type is unknown (no registered schema) THEN Gibson SHALL store it with a warning but allow creation for forward compatibility\n\n### Requirement 3: Refactored Attack Command\n\n**User Story:** As a security operator, I want to run attacks by specifying a stored target name, so that I don't have to remember and retype connection parameters for each attack.\n\n#### Acceptance Criteria\n\n1. WHEN running an attack THEN the user SHALL specify either `--target <name>` (stored target) or `--type <type> --connection <json>` (inline target)\n2. IF a positional URL argument is provided THEN Gibson SHALL reject it with a clear error message explaining the new syntax\n3. WHEN using `--target` THEN Gibson SHALL resolve the target by name or ID and pass its connection parameters to the agent\n4. IF the specified agent does not support the target's type THEN Gibson SHALL reject the attack with an error listing supported types\n\n### Requirement 4: Agent Target Schema Declaration\n\n**User Story:** As an agent developer, I want my agent to declare which target schemas it supports, so that Gibson can validate targets before invoking my agent.\n\n#### Acceptance Criteria\n\n1. WHEN implementing an agent THEN the developer SHALL implement a `TargetSchemas()` method returning supported schemas\n2. IF an agent's `TargetSchemas()` returns an empty list THEN Gibson SHALL allow any target type (opt-out validation)\n3. WHEN Gibson invokes an agent THEN the harness SHALL provide target connection parameters via `h.Target().Connection`\n4. IF the SDK provides built-in schemas THEN agents SHALL be able to reference them by type name instead of duplicating definitions\n\n### Requirement 5: Built-in Target Schemas (SDK)\n\n**User Story:** As an agent developer, I want pre-defined schemas for common target types, so that I can quickly build agents without defining schemas from scratch.\n\n#### Acceptance Criteria\n\n1. WHEN the SDK is imported THEN it SHALL provide built-in schemas for: `http_api`, `llm_chat`, `llm_api`, `kubernetes`, `smart_contract`\n2. IF an agent references a built-in schema by type name THEN the SDK SHALL resolve it automatically\n3. WHEN a built-in schema is insufficient THEN developers SHALL be able to extend it or define custom schemas\n4. IF a new target type becomes common THEN it SHALL be easy to add to built-in schemas in future SDK releases\n\n### Requirement 6: CLI Target Management\n\n**User Story:** As a security operator, I want an intuitive CLI for creating and managing targets of different types, so that I can quickly set up attack surfaces.\n\n#### Acceptance Criteria\n\n1. WHEN running `gibson target add` THEN the user SHALL provide `--type` and `--connection` flags\n2. IF `--interactive` flag is provided THEN Gibson SHALL prompt for each required field based on the schema\n3. WHEN running `gibson target list` THEN Gibson SHALL show type and summary of connection parameters\n4. IF running `gibson target show <name>` THEN Gibson SHALL display full connection parameters (with sensitive fields masked)\n\n### Requirement 7: Proto/gRPC Updates\n\n**User Story:** As a framework developer, I want target schemas transmitted via gRPC, so that external agents can receive properly structured target information.\n\n#### Acceptance Criteria\n\n1. WHEN an agent registers via gRPC THEN the `AgentDescriptor` message SHALL include target schemas\n2. IF a task is executed via gRPC THEN the `target_json` field SHALL contain the new `TargetInfo` structure with `connection` field\n3. WHEN migrating THEN the proto changes SHALL be backward compatible (old agents continue to work)\n\n## Non-Functional Requirements\n\n### Code Architecture and Modularity\n\n- **Single Responsibility Principle**: Target schema handling in dedicated package (`internal/target/schema`)\n- **Modular Design**: SDK schemas separate from Gibson core, agents reference by import\n- **Dependency Management**: SDK has no dependency on Gibson core (one-way dependency)\n- **Clear Interfaces**: `TargetSchema` interface allows custom implementations\n\n### Performance\n\n- Schema validation SHALL complete in < 10ms for typical targets\n- Schema caching SHALL prevent re-parsing JSON Schemas on every validation\n- Target resolution (name to connection params) SHALL complete in < 50ms\n\n### Security\n\n- Sensitive connection parameters (API keys, tokens) SHALL be stored encrypted in database\n- Connection parameters SHALL NOT be logged at INFO level (only DEBUG with redaction)\n- Schema validation SHALL prevent injection attacks via connection parameter values\n\n### Reliability\n\n- Invalid schemas SHALL fail fast at agent registration, not at attack time\n- Missing required connection fields SHALL produce clear error messages\n- Schema version mismatches SHALL produce warnings but allow execution\n\n### Usability\n\n- `--help` output SHALL show available target types and their required fields\n- Error messages SHALL indicate which connection fields are missing or invalid\n- Interactive mode SHALL provide field descriptions from schema\n- Tab completion SHALL work for target types and stored target names\n\n### Backward Compatibility\n\n- Existing agents using `TargetTypes()` SHALL continue to work during migration period\n- Existing `target.URL` access SHALL work via compatibility shim reading `connection[\"url\"]`\n- URL-based inline attacks SHALL be supported via `--type http_api --connection '{\"url\":\"...\"}'`\n",
  "fileStats": {
    "size": 8013,
    "lines": 138,
    "lastModified": "2026-01-06T23:42:00.367Z"
  },
  "comments": []
}