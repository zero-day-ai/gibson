package generator

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
	"time"

	"github.com/zero-day-ai/gibson/cmd/taxonomy-gen/schema"
)

// GenerateConstants generates Go constants from the taxonomy.
func GenerateConstants(taxonomy *schema.Taxonomy, outputPath, pkgName string) error {
	tmpl, err := template.New("constants").Funcs(constantsFuncMap()).Parse(constantsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		*schema.Taxonomy
		Package     string
		SourcePath  string
		GeneratedAt string
	}{
		Taxonomy:    taxonomy,
		Package:     pkgName,
		SourcePath:  "taxonomy/core.yaml",
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func constantsFuncMap() template.FuncMap {
	return template.FuncMap{
		"toPascalCase": toPascalCase,
		"toUpperSnake": toUpperSnake,
	}
}

const constantsTemplate = `// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: {{.SourcePath}}
// Taxonomy Version: {{.Version}}
// Generated at: {{.GeneratedAt}}

package graphrag

// ==================== NODE TYPE CONSTANTS ====================

// Node type constants for compile-time safety.
const (
{{- range .NodeTypes}}
	// NodeType{{.Name | toPascalCase}} is the "{{.Name}}" node type.
	NodeType{{.Name | toPascalCase}} = "{{.Name}}"
{{- end}}
)

// ==================== RELATIONSHIP TYPE CONSTANTS ====================

// Relationship type constants for compile-time safety.
const (
{{- range .RelationshipTypes}}
	// RelType{{.Name | toPascalCase}} is the "{{.Name}}" relationship type.
	RelType{{.Name | toPascalCase}} = "{{.Name}}"
{{- end}}
)

// ==================== CORE TYPES MAP ====================

// CoreTypes is a set of all core (validated) node types.
var CoreTypes = map[string]bool{
{{- range .NodeTypes}}
	"{{.Name}}": true,
{{- end}}
}

// IsCoreType returns true if the node type is a core (validated) type.
func IsCoreType(nodeType string) bool {
	return CoreTypes[nodeType]
}

// ==================== PARENT REQUIREMENTS ====================

// ParentRequirement defines the parent relationship for a node type.
type ParentRequirement struct {
	ParentType   string
	Relationship string
	Required     bool
}

// ParentRequirements maps node types to their parent requirements.
var ParentRequirements = map[string]ParentRequirement{
{{- range .NodeTypes}}
{{- if .Parent}}
	"{{.Name}}": {
		ParentType:   "{{.Parent.Type}}",
		Relationship: "{{.Parent.Relationship}}",
		Required:     {{.Parent.Required}},
	},
{{- end}}
{{- end}}
}

// GetParentRequirement returns the parent requirement for a node type.
func GetParentRequirement(nodeType string) (ParentRequirement, bool) {
	req, ok := ParentRequirements[nodeType]
	return req, ok
}

// ==================== ALL NODE TYPES ====================

// AllNodeTypes is a list of all core node type names.
var AllNodeTypes = []string{
{{- range .NodeTypes}}
	"{{.Name}}",
{{- end}}
}

// ==================== ALL RELATIONSHIP TYPES ====================

// AllRelationshipTypes is a list of all core relationship type names.
var AllRelationshipTypes = []string{
{{- range .RelationshipTypes}}
	"{{.Name}}",
{{- end}}
}
`
