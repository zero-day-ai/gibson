package generator

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/zero-day-ai/gibson/cmd/taxonomy-gen/schema"
)

// GenerateValidators generates CEL validators from the taxonomy.
func GenerateValidators(taxonomy *schema.Taxonomy, outputPath, pkgName string) error {
	tmpl, err := template.New("validators").Funcs(validatorsFuncMap()).Parse(validatorsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		*schema.Taxonomy
		Package     string
		SourcePath  string
		GeneratedAt string
	}{
		Taxonomy:    taxonomy,
		Package:     "validation",
		SourcePath:  "taxonomy/core.yaml",
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func validatorsFuncMap() template.FuncMap {
	return template.FuncMap{
		"toPascalCase":   toPascalCase,
		"toLowerSnake":   toLowerSnake,
		"hasValidations": func(nt schema.NodeType) bool { return len(nt.Validations) > 0 },
		"escapeCEL":      escapeCEL,
	}
}

// escapeCEL escapes a CEL expression for Go string literal.
func escapeCEL(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	s = strings.ReplaceAll(s, "\n", `\n`)
	return s
}

const validatorsTemplate = `// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: {{.SourcePath}}
// Taxonomy Version: {{.Version}}
// Generated at: {{.GeneratedAt}}

package {{.Package}}

import (
	"fmt"
	"sync"

	"github.com/google/cel-go/cel"
	"github.com/zero-day-ai/sdk/api/gen/taxonomypb"
)

var (
	initOnce sync.Once
	initErr  error

	// Pre-compiled CEL programs for each type
{{- range .NodeTypes}}
{{- if hasValidations .}}
	{{.Name}}Validators []*compiledRule
{{- end}}
{{- end}}

	// Core types set
	coreTypes = map[string]bool{
{{- range .NodeTypes}}
		"{{.Name}}": true,
{{- end}}
	}

	// Parent requirements
	parentRequirements = map[string]ParentRequirement{
{{- range .NodeTypes}}
{{- if .Parent}}
		"{{.Name}}": {ParentType: "{{.Parent.Type}}", Relationship: "{{.Parent.Relationship}}", Required: {{.Parent.Required}}},
{{- end}}
{{- end}}
	}
)

type compiledRule struct {
	program cel.Program
	message string
}

// ParentRequirement defines the parent relationship for a node type.
type ParentRequirement struct {
	ParentType   string
	Relationship string
	Required     bool
}

func init() {
	initOnce.Do(func() {
		initErr = initValidators()
	})
}

func initValidators() error {
{{- range .NodeTypes}}
{{- if hasValidations .}}
	// Initialize {{.Name}} validators
	{
		env, err := cel.NewEnv(
			cel.Types(&taxonomypb.{{.Name | toPascalCase}}{}),
			cel.Variable("self", cel.ObjectType("taxonomy.{{.Name | toPascalCase}}")),
		)
		if err != nil {
			return fmt.Errorf("failed to create CEL environment for {{.Name}}: %w", err)
		}
		{{.Name}}Validators = compileRules(env, []ruleSpec{
{{- range .Validations}}
			{expr: "{{.Rule | escapeCEL}}", message: "{{.Message}}"},
{{- end}}
		})
	}
{{- end}}
{{- end}}
	return nil
}

type ruleSpec struct {
	expr    string
	message string
}

func compileRules(env *cel.Env, specs []ruleSpec) []*compiledRule {
	rules := make([]*compiledRule, 0, len(specs))
	for _, spec := range specs {
		ast, issues := env.Compile(spec.expr)
		if issues != nil && issues.Err() != nil {
			panic(fmt.Sprintf("failed to compile CEL rule '%s': %v", spec.expr, issues.Err()))
		}
		prg, err := env.Program(ast)
		if err != nil {
			panic(fmt.Sprintf("failed to create CEL program for '%s': %v", spec.expr, err))
		}
		rules = append(rules, &compiledRule{program: prg, message: spec.message})
	}
	return rules
}

// ==================== PUBLIC API ====================

// IsCoreType returns true if the node type is a core (validated) type.
func IsCoreType(nodeType string) bool {
	return coreTypes[nodeType]
}

// GetParentRequirement returns the parent requirement for a node type.
func GetParentRequirement(nodeType string) (ParentRequirement, bool) {
	req, ok := parentRequirements[nodeType]
	return req, ok
}

// ValidateNode validates any node. Custom types pass through without validation.
func ValidateNode(nodeType string, properties map[string]any, hasParent bool) error {
	// Custom type - no validation
	if !IsCoreType(nodeType) {
		return nil
	}

	// Check parent requirement
	if req, ok := parentRequirements[nodeType]; ok && req.Required && !hasParent {
		return fmt.Errorf("%s requires a parent of type %s", nodeType, req.ParentType)
	}

	return nil
}

// ==================== TYPE-SPECIFIC VALIDATORS ====================
{{range .NodeTypes}}
// Validate{{.Name | toPascalCase}} validates a {{.Name | toPascalCase}} proto.
func Validate{{.Name | toPascalCase}}(p *taxonomypb.{{.Name | toPascalCase}}) error {
	if initErr != nil {
		return fmt.Errorf("validator initialization failed: %w", initErr)
	}
{{- if hasValidations .}}
	for _, rule := range {{.Name}}Validators {
		result, _, err := rule.program.Eval(map[string]any{"self": p})
		if err != nil {
			return fmt.Errorf("validation error: %w", err)
		}
		if result.Value() != true {
			return fmt.Errorf("{{.Name}} validation failed: %s", rule.message)
		}
	}
{{- end}}
	return nil
}
{{end}}`
