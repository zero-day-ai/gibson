package generator

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
	"time"

	"github.com/zero-day-ai/gibson/cmd/taxonomy-gen/schema"
)

// GenerateRelationships generates relationship mapping configuration.
func GenerateRelationships(taxonomy *schema.Taxonomy, outputPath, pkgName string) error {
	tmpl, err := template.New("relationships").Funcs(relationshipsFuncMap()).Parse(relationshipsTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		*schema.Taxonomy
		Package     string
		SourcePath  string
		GeneratedAt string
	}{
		Taxonomy:    taxonomy,
		Package:     pkgName,
		SourcePath:  "taxonomy/core.yaml",
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func relationshipsFuncMap() template.FuncMap {
	return template.FuncMap{
		"toPascalCase": toPascalCase,
		"isRoot":       func(nt schema.NodeType) bool { return nt.Parent == nil },
		"hasParent":    func(nt schema.NodeType) bool { return nt.Parent != nil },
	}
}

const relationshipsTemplate = `// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: {{.SourcePath}}
// Taxonomy Version: {{.Version}}
// Generated at: {{.GeneratedAt}}

package {{.Package}}

// ParentRelationship defines how a child node relates to its parent.
type ParentRelationship struct {
	// ChildType is the node type name (e.g., "port")
	ChildType string
	// ParentType is the parent node type name (e.g., "host")
	ParentType string
	// RefField is the field on the child that holds the parent UUID (e.g., "host_id")
	RefField string
	// ParentField is the field on the parent to match against (always "id")
	ParentField string
	// Relationship is the Neo4j relationship type (e.g., "HAS_PORT")
	Relationship string
	// Required indicates if the parent is mandatory
	Required bool
}

// ParentRelationships maps child node types to their parent relationship config.
var ParentRelationships = map[string]ParentRelationship{
{{- range .NodeTypes}}
{{- if hasParent .}}
	"{{.Name}}": {
		ChildType:    "{{.Name}}",
		ParentType:   "{{.Parent.Type}}",
		RefField:     "{{.Parent.RefField}}",
		ParentField:  "id",
		Relationship: "{{.Parent.Relationship}}",
		Required:     {{.Parent.Required}},
	},
{{- end}}
{{- end}}
}

// RootNodeTypes lists node types that have no parent (can attach to MissionRun).
var RootNodeTypes = []string{
{{- range .NodeTypes}}
{{- if isRoot .}}
	"{{.Name}}",
{{- end}}
{{- end}}
}

// IsRootNodeType returns true if the given node type is a root type (no parent).
func IsRootNodeType(nodeType string) bool {
	for _, rt := range RootNodeTypes {
		if rt == nodeType {
			return true
		}
	}
	return false
}

// GetParentRelationship returns the parent relationship config for a child type.
// Returns nil if the type has no parent (is a root type).
func GetParentRelationship(childType string) *ParentRelationship {
	if rel, ok := ParentRelationships[childType]; ok {
		return &rel
	}
	return nil
}
`
