package generator

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/zero-day-ai/gibson/cmd/taxonomy-gen/schema"
)

// GenerateDomain generates Go domain types from the taxonomy.
func GenerateDomain(taxonomy *schema.Taxonomy, outputPath, pkgName string) error {
	tmpl, err := template.New("domain").Funcs(domainFuncMap()).Parse(domainTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		*schema.Taxonomy
		Package     string
		SourcePath  string
		GeneratedAt string
	}{
		Taxonomy:    taxonomy,
		Package:     pkgName,
		SourcePath:  "taxonomy/core.yaml",
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func domainFuncMap() template.FuncMap {
	return template.FuncMap{
		"add":            func(a, b int) int { return a + b },
		"toPascalCase":   toPascalCase,
		"toLowerSnake":   toLowerSnake,
		"toUpperSnake":   toUpperSnake,
		"toCamelCase":    toCamelCase,
		"escapeKeyword":  escapeKeyword,
		"hasParent":      func(nt schema.NodeType) bool { return nt.Parent != nil },
		"hasValidations": func(nt schema.NodeType) bool { return len(nt.Validations) > 0 },
		"join":           strings.Join,
	}
}

// goKeywords is a set of Go reserved keywords that need escaping when used as identifiers.
var goKeywords = map[string]bool{
	"break": true, "case": true, "chan": true, "const": true, "continue": true,
	"default": true, "defer": true, "else": true, "fallthrough": true, "for": true,
	"func": true, "go": true, "goto": true, "if": true, "import": true,
	"interface": true, "map": true, "package": true, "range": true, "return": true,
	"select": true, "struct": true, "switch": true, "type": true, "var": true,
}

// escapeKeyword escapes Go keywords by appending an underscore.
func escapeKeyword(s string) string {
	if goKeywords[s] {
		return s + "_"
	}
	return s
}

// toCamelCase converts a string to camelCase.
// e.g., "host_id" -> "hostId", "mission_run" -> "missionRun"
func toCamelCase(s string) string {
	pascal := toPascalCase(s)
	if len(pascal) > 0 {
		return strings.ToLower(pascal[:1]) + pascal[1:]
	}
	return pascal
}

const domainTemplate = `// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: {{.SourcePath}}
// Taxonomy Version: {{.Version}}
// Generated at: {{.GeneratedAt}}

package {{.Package}}

import (
	"fmt"

	"github.com/zero-day-ai/sdk/api/gen/taxonomypb"
	"github.com/zero-day-ai/sdk/graphrag/validation"
)

// ==================== INTERFACES ====================

// GraphNode is implemented by all domain types.
type GraphNode interface {
	// NodeType returns the taxonomy node type string.
	NodeType() string

	// Properties returns all properties as a map.
	Properties() map[string]any

	// IdentifyingProperties returns the natural key properties.
	IdentifyingProperties() map[string]any

	// ParentRef returns the parent reference, or nil for root nodes.
	ParentRef() *NodeRef

	// Validate runs CEL validation rules. Returns nil for custom types.
	Validate() error

	// ToProto converts to the generic GraphNode proto.
	ToProto() *taxonomypb.GraphNode

	// ID returns the node ID (may be empty until stored).
	ID() string

	// SetID sets the node ID (called by harness after storage).
	SetID(id string)
}

// NodeRef references a parent node.
type NodeRef struct {
	NodeType     string
	Properties   map[string]any
	Relationship string
}

// ==================== HELPER FUNCTIONS ====================

func propsToValueMap(props map[string]any) map[string]*taxonomypb.Value {
	result := make(map[string]*taxonomypb.Value, len(props))
	for k, v := range props {
		result[k] = anyToValue(v)
	}
	return result
}

func anyToValue(v any) *taxonomypb.Value {
	if v == nil {
		return nil
	}
	switch val := v.(type) {
	case string:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_StringValue{StringValue: val}}
	case int:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_IntValue{IntValue: int64(val)}}
	case int32:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_IntValue{IntValue: int64(val)}}
	case int64:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_IntValue{IntValue: val}}
	case float64:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_DoubleValue{DoubleValue: val}}
	case float32:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_DoubleValue{DoubleValue: float64(val)}}
	case bool:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_BoolValue{BoolValue: val}}
	case []byte:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_BytesValue{BytesValue: val}}
	default:
		return &taxonomypb.Value{Kind: &taxonomypb.Value_StringValue{StringValue: fmt.Sprintf("%v", val)}}
	}
}

// ==================== GENERATED DOMAIN TYPES ====================
{{range .NodeTypes}}
// ==================== {{.Name | toUpperSnake}} ====================

// {{.Name | toPascalCase}} represents: {{.Description}}
type {{.Name | toPascalCase}} struct {
	proto  *taxonomypb.{{.Name | toPascalCase}}
	parent *NodeRef
}

// New{{.Name | toPascalCase}} creates a new {{.Name | toPascalCase}}.
{{- $type := .}}
{{- $requiredProps := .RequiredProperties}}
{{- if gt (len $requiredProps) 0}}
func New{{.Name | toPascalCase}}({{range $i, $p := $requiredProps}}{{if $i}}, {{end}}{{$p.Name | escapeKeyword}} {{$p.GoType}}{{end}}) *{{.Name | toPascalCase}} {
	return &{{.Name | toPascalCase}}{
		proto: &taxonomypb.{{.Name | toPascalCase}}{
{{- range $requiredProps}}
			{{.Name | toPascalCase}}: {{.Name | escapeKeyword}},
{{- end}}
		},
	}
}
{{- else}}
func New{{.Name | toPascalCase}}() *{{.Name | toPascalCase}} {
	return &{{.Name | toPascalCase}}{
		proto: &taxonomypb.{{.Name | toPascalCase}}{},
	}
}
{{- end}}

// NodeType implements GraphNode.
func (n *{{.Name | toPascalCase}}) NodeType() string { return "{{.Name}}" }

// Properties implements GraphNode.
func (n *{{.Name | toPascalCase}}) Properties() map[string]any {
	props := make(map[string]any)
{{- range .Properties}}
{{- if .Required}}
	props["{{.Name}}"] = n.proto.{{.Name | toPascalCase}}
{{- else}}
	if n.proto.{{.Name | toPascalCase}} != nil {
		props["{{.Name}}"] = *n.proto.{{.Name | toPascalCase}}
	}
{{- end}}
{{- end}}
{{- if .Parent}}
	if n.proto.Parent{{.Parent.Type | toPascalCase}}Id != "" {
		props["parent_{{.Parent.Type}}_id"] = n.proto.Parent{{.Parent.Type | toPascalCase}}Id
	}
{{- end}}
	return props
}

// IdentifyingProperties implements GraphNode.
func (n *{{.Name | toPascalCase}}) IdentifyingProperties() map[string]any {
	props := make(map[string]any)
{{- range .IdentifyingProperties}}
{{- $prop := $type.PropertyByName .}}
{{- if $prop}}
{{- if $prop.Required}}
	props["{{.}}"] = n.proto.{{. | toPascalCase}}
{{- else}}
	if n.proto.{{. | toPascalCase}} != nil {
		props["{{.}}"] = *n.proto.{{. | toPascalCase}}
	}
{{- end}}
{{- end}}
{{- end}}
	return props
}

// ParentRef implements GraphNode.
func (n *{{.Name | toPascalCase}}) ParentRef() *NodeRef {
{{- if .Parent}}
	if n.parent != nil {
		return n.parent
	}
	if n.proto.Parent{{.Parent.Type | toPascalCase}}Id != "" {
		return &NodeRef{
			NodeType:     "{{.Parent.Type}}",
			Properties:   map[string]any{"id": n.proto.Parent{{.Parent.Type | toPascalCase}}Id},
			Relationship: "{{.Parent.Relationship}}",
		}
	}
{{- end}}
	return nil
}

// Validate implements GraphNode.
func (n *{{.Name | toPascalCase}}) Validate() error {
{{- if .Parent}}
{{- if .Parent.Required}}
	if n.parent == nil && n.proto.Parent{{.Parent.Type | toPascalCase}}Id == "" {
		return fmt.Errorf("{{.Name}} requires a parent of type {{.Parent.Type}} (use BelongsTo)")
	}
{{- end}}
{{- end}}
	return validation.Validate{{.Name | toPascalCase}}(n.proto)
}

// ToProto implements GraphNode.
func (n *{{.Name | toPascalCase}}) ToProto() *taxonomypb.GraphNode {
	node := &taxonomypb.GraphNode{
		Id:         n.proto.Id,
		Type:       "{{.Name}}",
		Properties: propsToValueMap(n.Properties()),
	}
	if n.parent != nil {
		node.ParentType = &n.parent.NodeType
		node.ParentRelationship = &n.parent.Relationship
	}
	return node
}

// ID returns the node ID.
func (n *{{.Name | toPascalCase}}) ID() string { return n.proto.Id }

// SetID sets the node ID.
func (n *{{.Name | toPascalCase}}) SetID(id string) { n.proto.Id = id }
{{if .Parent}}
// BelongsTo sets the parent {{.Parent.Type}}.
func (n *{{.Name | toPascalCase}}) BelongsTo(parent *{{.Parent.Type | toPascalCase}}) *{{.Name | toPascalCase}} {
	n.parent = &NodeRef{
		NodeType:     "{{.Parent.Type}}",
		Properties:   parent.IdentifyingProperties(),
		Relationship: "{{.Parent.Relationship}}",
	}
	n.proto.Parent{{.Parent.Type | toPascalCase}}Id = parent.ID()
	return n
}
{{end}}
// --- Typed Accessors ---
{{range .Properties}}
// {{.Name | toPascalCase}} returns the {{.Name}} value.
func (n *{{$type.Name | toPascalCase}}) {{.Name | toPascalCase}}() {{.GoType}} {
{{- if .Required}}
	return n.proto.{{.Name | toPascalCase}}
{{- else}}
	if n.proto.{{.Name | toPascalCase}} != nil {
		return *n.proto.{{.Name | toPascalCase}}
	}
	var zero {{.GoType}}
	return zero
{{- end}}
}

// Set{{.Name | toPascalCase}} sets the {{.Name}} value.
func (n *{{$type.Name | toPascalCase}}) Set{{.Name | toPascalCase}}(v {{.GoType}}) *{{$type.Name | toPascalCase}} {
{{- if .Required}}
	n.proto.{{.Name | toPascalCase}} = v
{{- else}}
	n.proto.{{.Name | toPascalCase}} = &v
{{- end}}
	return n
}
{{end}}
{{end}}`
