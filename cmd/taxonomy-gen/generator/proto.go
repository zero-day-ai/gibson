// Package generator provides code generation from taxonomy YAML.
package generator

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"
	"time"
	"unicode"

	"github.com/zero-day-ai/gibson/cmd/taxonomy-gen/schema"
)

// GenerateProto generates a protobuf definition file from the taxonomy.
func GenerateProto(taxonomy *schema.Taxonomy, outputPath string) error {
	tmpl, err := template.New("proto").Funcs(protoFuncMap()).Parse(protoTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	data := struct {
		*schema.Taxonomy
		SourcePath  string
		GeneratedAt string
	}{
		Taxonomy:    taxonomy,
		SourcePath:  "taxonomy/core.yaml",
		GeneratedAt: time.Now().UTC().Format(time.RFC3339),
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	return nil
}

func protoFuncMap() template.FuncMap {
	return template.FuncMap{
		"add": func(a, b int) int {
			return a + b
		},
		"toUpperSnake": toUpperSnake,
		"toPascalCase": toPascalCase,
		"toLowerSnake": toLowerSnake,
	}
}

// toUpperSnake converts a string to UPPER_SNAKE_CASE.
// e.g., "mission_run" -> "MISSION_RUN", "HAS_PORT" -> "HAS_PORT"
func toUpperSnake(s string) string {
	// If already has underscores, just uppercase
	if strings.Contains(s, "_") {
		return strings.ToUpper(s)
	}
	// Otherwise convert camelCase to UPPER_SNAKE_CASE
	return strings.ToUpper(toLowerSnake(s))
}

// toPascalCase converts a string to PascalCase.
// e.g., "mission_run" -> "MissionRun"
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

// toLowerSnake converts a string to lower_snake_case.
// e.g., "MissionRun" -> "mission_run"
func toLowerSnake(s string) string {
	var result strings.Builder
	for i, r := range s {
		if unicode.IsUpper(r) {
			if i > 0 {
				result.WriteRune('_')
			}
			result.WriteRune(unicode.ToLower(r))
		} else {
			result.WriteRune(r)
		}
	}
	return result.String()
}

const protoTemplate = `// Code generated by taxonomy-gen from taxonomy YAML. DO NOT EDIT.
// Source: {{.SourcePath}}
// Taxonomy Version: {{.Version}}
// Generated at: {{.GeneratedAt}}

syntax = "proto3";

package taxonomy;

option go_package = "github.com/zero-day-ai/sdk/api/gen/taxonomypb";

// ==================== ENUMS ====================

// CoreNodeType enumerates all core (validated) node types.
// Custom types use string directly, not this enum.
enum CoreNodeType {
  CORE_NODE_TYPE_UNSPECIFIED = 0;
{{- range $i, $nt := .NodeTypes}}
  CORE_NODE_TYPE_{{$nt.Name | toUpperSnake}} = {{add $i 1}};
{{- end}}
}

// CoreRelationType enumerates all core relationship types.
enum CoreRelationType {
  CORE_RELATION_TYPE_UNSPECIFIED = 0;
{{- range $i, $rt := .RelationshipTypes}}
  CORE_RELATION_TYPE_{{$rt.Name | toUpperSnake}} = {{add $i 1}};
{{- end}}
}

// ==================== VALUE TYPES ====================

// Value represents a dynamic property value.
message Value {
  oneof kind {
    string string_value = 1;
    int64 int_value = 2;
    double double_value = 3;
    bool bool_value = 4;
    bytes bytes_value = 5;
    int64 timestamp_value = 6;
    ListValue list_value = 7;
    MapValue map_value = 8;
  }
}

message ListValue {
  repeated Value values = 1;
}

message MapValue {
  map<string, Value> fields = 1;
}

// ==================== CORE MESSAGES ====================

// GraphNode is the generic node type that can represent any taxonomy node.
// Use typed messages (Host, Port, etc.) for compile-time safety,
// or GraphNode for dynamic/custom types.
message GraphNode {
  // Identity
  string id = 1;
  string type = 2;  // String to allow custom types

  // Properties (flexible key-value)
  map<string, Value> properties = 3;

  // Parent reference (set by BelongsTo)
  optional string parent_id = 4;
  optional string parent_type = 5;
  optional string parent_relationship = 6;

  // Scoping (injected by harness - agents never set these)
  string mission_id = 10;
  string mission_run_id = 11;
  string agent_run_id = 12;
  string discovered_by = 13;
  int64 discovered_at = 14;

  // Timestamps
  int64 created_at = 20;
  int64 updated_at = 21;
}

// Relationship represents a connection between two nodes.
message Relationship {
  string id = 1;
  string from_id = 2;
  string to_id = 3;
  string type = 4;  // String to allow custom types

  map<string, Value> properties = 5;
  double weight = 6;

  // Scoping
  string mission_id = 10;
  string mission_run_id = 11;

  // Timestamps
  int64 created_at = 20;
}

// ==================== TYPED NODE MESSAGES ====================
{{range .NodeTypes}}
// {{.Name | toPascalCase}} represents: {{.Description}}
message {{.Name | toPascalCase}} {
  string id = 1;

  // Properties
{{- $fieldNum := 2}}
{{- range .Properties}}
{{- if .Required}}
  {{.ProtoType}} {{.Name}} = {{$fieldNum}};
{{- else}}
  optional {{.ProtoType}} {{.Name}} = {{$fieldNum}};
{{- end}}
{{- $fieldNum = add $fieldNum 1}}
{{- end}}
{{- if .Parent}}

  // Parent reference
  string parent_{{.Parent.Type}}_id = {{$fieldNum}};
{{- end}}
}
{{end}}`
