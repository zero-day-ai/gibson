package registry

import (
	"context"
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"

	proto "github.com/zero-day-ai/sdk/api/gen/proto"
	sdkregistry "github.com/zero-day-ai/sdk/registry"
)

// TestToolDiscoveryIntegration demonstrates the complete tool discovery flow
// from registry query to gRPC client execution.
func TestToolDiscoveryIntegration(t *testing.T) {
	// Setup: Mock registry that returns tool instances
	mockReg := &mockToolRegistry{
		discoverFunc: func(ctx context.Context, componentType, name string) ([]sdkregistry.ServiceInfo, error) {
			if componentType == "tool" && name == "nmap" {
				return []sdkregistry.ServiceInfo{
					{
						Name:     "nmap",
						Version:  "1.0.0",
						Endpoint: "localhost:50051",
						Metadata: map[string]string{
							"description": "Network scanner",
							"tags":        "network,scanner,recon",
						},
					},
				}, nil
			}
			return []sdkregistry.ServiceInfo{}, nil
		},
	}

	// Create adapter with mock registry
	adapter := NewRegistryAdapter(mockReg)

	// Mock the load balancer to return our instance
	adapter.loadBalancer = &LoadBalancer{
		registry: mockReg,
		strategy: StrategyRoundRobin,
	}

	// Mock the gRPC pool to avoid actual network connections
	mockConn := &mockGRPCConn{}
	mockPool := &mockGRPCPool{
		getFunc: func(ctx context.Context, endpoint string) (*grpc.ClientConn, error) {
			return mockConn, nil
		},
	}
	adapter.pool = mockPool

	ctx := context.Background()

	// Act: Discover the tool
	tool, err := adapter.DiscoverTool(ctx, "nmap")

	// Assert: Verify we got a valid tool client
	require.NoError(t, err)
	require.NotNil(t, tool)

	// Verify tool metadata
	assert.Equal(t, "nmap", tool.Name())
	assert.Equal(t, "1.0.0", tool.Version())
	assert.Equal(t, "Network scanner", tool.Description())
	assert.Equal(t, []string{"network", "scanner", "recon"}, tool.Tags())

	t.Log("Successfully discovered tool via registry and created gRPC client")
}

// TestToolDiscoveryWithExecution demonstrates discovering a tool and executing it
func TestToolDiscoveryWithExecution(t *testing.T) {
	// Setup: Create a mock tool service client
	mockToolClient := &mockToolServiceClient{
		getDescriptorFunc: func(ctx context.Context, req *proto.ToolGetDescriptorRequest, opts ...grpc.CallOption) (*proto.ToolDescriptor, error) {
			return &proto.ToolDescriptor{
				Name:        "nmap",
				Description: "Network scanner",
				Version:     "1.0.0",
				Tags:        []string{"network", "scanner"},
				InputSchema: &proto.JSONSchema{
					Json: `{"type":"object","properties":{"target":{"type":"string"}},"required":["target"]}`,
				},
				OutputSchema: &proto.JSONSchema{
					Json: `{"type":"object","properties":{"result":{"type":"string"}}}`,
				},
			}, nil
		},
		executeFunc: func(ctx context.Context, req *proto.ToolExecuteRequest, opts ...grpc.CallOption) (*proto.ToolExecuteResponse, error) {
			// Parse input
			var input map[string]any
			_ = json.Unmarshal([]byte(req.InputJson), &input)

			// Simulate scan result
			output := map[string]any{
				"result": "Scan complete for " + input["target"].(string),
				"ports":  []int{22, 80, 443},
			}
			outputJSON, _ := json.Marshal(output)

			return &proto.ToolExecuteResponse{
				OutputJson: string(outputJSON),
			}, nil
		},
		healthFunc: func(ctx context.Context, req *proto.ToolHealthRequest, opts ...grpc.CallOption) (*proto.HealthStatus, error) {
			return &proto.HealthStatus{
				State:   "healthy",
				Message: "Scanner ready",
			}, nil
		},
	}

	// Create tool client directly
	info := sdkregistry.ServiceInfo{
		Name:     "nmap",
		Version:  "1.0.0",
		Endpoint: "localhost:50051",
		Metadata: map[string]string{
			"description": "Network scanner",
			"tags":        "network,scanner",
		},
	}

	toolClient := &GRPCToolClient{
		client: mockToolClient,
		info:   info,
	}

	ctx := context.Background()

	// Execute the tool
	input := map[string]any{
		"target": "192.168.1.1",
		"ports":  "1-1000",
	}

	output, err := toolClient.Execute(ctx, input)

	// Verify execution
	require.NoError(t, err)
	require.NotNil(t, output)
	assert.Contains(t, output["result"], "192.168.1.1")
	assert.Contains(t, output, "ports")

	// Check health
	health := toolClient.Health(ctx)
	assert.True(t, health.IsHealthy())
	assert.Equal(t, "Scanner ready", health.Message)

	t.Log("Successfully executed tool and verified health status")
}

// mockGRPCConn is a mock grpc.ClientConn for testing
type mockGRPCConn struct {
	grpc.ClientConn
}

// mockGRPCPool is a mock GRPCPool for testing
type mockGRPCPool struct {
	getFunc    func(ctx context.Context, endpoint string) (*grpc.ClientConn, error)
	removeFunc func(endpoint string) error
	closeFunc  func() error
}

func (m *mockGRPCPool) Get(ctx context.Context, endpoint string) (*grpc.ClientConn, error) {
	if m.getFunc != nil {
		return m.getFunc(ctx, endpoint)
	}
	return &mockGRPCConn{}, nil
}

func (m *mockGRPCPool) Remove(endpoint string) error {
	if m.removeFunc != nil {
		return m.removeFunc(endpoint)
	}
	return nil
}

func (m *mockGRPCPool) Close() error {
	if m.closeFunc != nil {
		return m.closeFunc()
	}
	return nil
}
