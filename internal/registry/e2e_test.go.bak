package registry

import (
	"context"
	"encoding/json"
	"fmt"
	"net"
	"reflect"
	"testing"
	"time"
	"unsafe"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/test/bufconn"

	"github.com/zero-day-ai/gibson/internal/agent"
	"github.com/zero-day-ai/gibson/internal/component"
	"github.com/zero-day-ai/gibson/internal/plugin"
	"github.com/zero-day-ai/gibson/internal/schema"
	"github.com/zero-day-ai/gibson/internal/tool"
	"github.com/zero-day-ai/gibson/internal/types"
	proto "github.com/zero-day-ai/sdk/api/gen/proto"
	sdkregistry "github.com/zero-day-ai/sdk/registry"
)

// setAdapterPool is a test helper that uses reflection to set the private pool field.
// This is only used for testing to inject custom pool implementations.
func setAdapterPool(adapter *RegistryAdapter, pool poolInterface) {
	adapterValue := reflect.ValueOf(adapter).Elem()
	poolField := adapterValue.FieldByName("pool")
	poolField = reflect.NewAt(poolField.Type(), unsafe.Pointer(poolField.UnsafeAddr())).Elem()
	poolField.Set(reflect.ValueOf(pool))
}

// E2E Test File for gRPC Component Communication
//
// This file contains comprehensive end-to-end tests that verify the entire
// component communication flow works correctly. The tests demonstrate:
//
// 1. Component Lifecycle:
//    - Components start and register with the etcd registry
//    - Orchestrator discovers components via registry adapter
//    - gRPC connections are established from the connection pool
//    - RPC calls execute operations (Execute, Query, Health, etc.)
//    - Components deregister on shutdown
//
// 2. Discovery Flow:
//    - Registry stores component metadata (name, version, endpoint, capabilities)
//    - DiscoverAgent/Tool/Plugin queries registry for instances
//    - Load balancer selects an instance (round-robin by default)
//    - Connection pool manages gRPC connections with health checking
//    - Wrapped client implements Gibson's component interfaces
//
// 3. Test Architecture:
//    - Uses embedded etcd for registry (no external dependencies)
//    - Uses bufconn for in-process gRPC (fast, no network overhead)
//    - Mock gRPC servers implement proto service interfaces
//    - All tests are self-contained and clean up after themselves

const bufSize = 1024 * 1024

// poolInterface defines the interface for GRPCPool used by RegistryAdapter.
// This allows test code to inject custom pool implementations.
type poolInterface interface {
	Get(ctx context.Context, endpoint string) (*grpc.ClientConn, error)
	Remove(endpoint string) error
	Close() error
}

// testGRPCPool embeds GRPCPool and intercepts "bufconn" endpoints for in-process connections.
// This allows tests to use in-memory gRPC connections without network overhead.
type testGRPCPool struct {
	*GRPCPool
	testSrv *testServer
}

// newTestGRPCPool creates a test pool that intercepts bufconn endpoints.
func newTestGRPCPool(testSrv *testServer) *testGRPCPool {
	return &testGRPCPool{
		GRPCPool: NewGRPCPool(),
		testSrv:  testSrv,
	}
}

// Get intercepts bufconn endpoints and delegates to testServer, otherwise uses the embedded pool.
func (tp *testGRPCPool) Get(ctx context.Context, endpoint string) (*grpc.ClientConn, error) {
	if endpoint == "bufconn" || endpoint == "bufconn-agent" {
		return tp.testSrv.dialContext(ctx)
	}
	return tp.GRPCPool.Get(ctx, endpoint)
}

// testServer manages a mock gRPC server for testing component communication.
// It uses bufconn for in-process connections (no TCP overhead) and provides
// methods to start agent, tool, and plugin services.
type testServer struct {
	listener *bufconn.Listener
	server   *grpc.Server
	endpoint string
}

// newTestServer creates a new test gRPC server with bufconn listener.
func newTestServer() *testServer {
	listener := bufconn.Listen(bufSize)
	server := grpc.NewServer()

	return &testServer{
		listener: listener,
		server:   server,
		endpoint: "bufconn", // Special endpoint for bufconn
	}
}

// start begins serving gRPC requests in the background.
func (ts *testServer) start() {
	go func() {
		if err := ts.server.Serve(ts.listener); err != nil {
			// Server stopped, ignore error
		}
	}()
}

// stop gracefully stops the gRPC server.
func (ts *testServer) stop() {
	ts.server.GracefulStop()
	ts.listener.Close()
}

// dialContext creates a gRPC client connection to this test server.
func (ts *testServer) dialContext(ctx context.Context) (*grpc.ClientConn, error) {
	return grpc.DialContext(ctx, "bufconn",
		grpc.WithContextDialer(func(context.Context, string) (net.Conn, error) {
			return ts.listener.Dial()
		}),
		grpc.WithTransportCredentials(insecure.NewCredentials()),
	)
}

// mockAgentServer implements proto.AgentServiceServer for testing.
// It responds to Execute, Health, GetDescriptor, and GetSlotSchema RPCs.
type mockAgentServer struct {
	proto.UnimplementedAgentServiceServer
	name           string
	version        string
	description    string
	capabilities   []string
	targetTypes    []string
	techniqueTypes []string
	executeFunc    func(ctx context.Context, req *proto.AgentExecuteRequest) (*proto.AgentExecuteResponse, error)
}

// Execute handles agent execution requests.
func (m *mockAgentServer) Execute(ctx context.Context, req *proto.AgentExecuteRequest) (*proto.AgentExecuteResponse, error) {
	if m.executeFunc != nil {
		return m.executeFunc(ctx, req)
	}

	// Default: parse task and return success result
	var task agent.Task
	if err := json.Unmarshal([]byte(req.TaskJson), &task); err != nil {
		return &proto.AgentExecuteResponse{
			Error: &proto.Error{
				Code:    "INVALID_TASK",
				Message: fmt.Sprintf("failed to parse task: %v", err),
			},
		}, nil
	}

	// Create success result
	result := agent.NewResult(task.ID)
	result.Complete(map[string]any{"test": "data"})

	resultJSON, _ := json.Marshal(result)
	return &proto.AgentExecuteResponse{
		ResultJson: string(resultJSON),
	}, nil
}

// Health returns the agent's health status.
func (m *mockAgentServer) Health(ctx context.Context, req *proto.AgentHealthRequest) (*proto.HealthStatus, error) {
	return &proto.HealthStatus{
		State:     "healthy",
		Message:   "Agent is running",
		CheckedAt: time.Now().UnixMilli(),
	}, nil
}

// GetDescriptor returns the agent's metadata.
func (m *mockAgentServer) GetDescriptor(ctx context.Context, req *proto.AgentGetDescriptorRequest) (*proto.AgentDescriptor, error) {
	return &proto.AgentDescriptor{
		Name:           m.name,
		Version:        m.version,
		Description:    m.description,
		Capabilities:   m.capabilities,
		TargetTypes:    m.targetTypes,
		TechniqueTypes: m.techniqueTypes,
	}, nil
}

// GetSlotSchema returns the agent's LLM slot requirements.
func (m *mockAgentServer) GetSlotSchema(ctx context.Context, req *proto.AgentGetSlotSchemaRequest) (*proto.AgentGetSlotSchemaResponse, error) {
	return &proto.AgentGetSlotSchemaResponse{
		Slots: []*proto.AgentSlotDefinition{
			{
				Name:        "primary",
				Description: "Primary LLM for agent reasoning",
				Required:    true,
				DefaultConfig: &proto.AgentSlotConfig{
					Provider:    "anthropic",
					Model:       "claude-3-5-sonnet",
					Temperature: 0.7,
					MaxTokens:   4096,
				},
				Constraints: &proto.AgentSlotConstraints{
					MinContextWindow: 100000,
					RequiredFeatures: []string{"tool_use"},
				},
			},
		},
	}, nil
}

// mockToolServer implements proto.ToolServiceServer for testing.
type mockToolServer struct {
	proto.UnimplementedToolServiceServer
	name        string
	version     string
	description string
	executeFunc func(ctx context.Context, req *proto.ToolExecuteRequest) (*proto.ToolExecuteResponse, error)
}

// Execute handles tool execution requests.
func (m *mockToolServer) Execute(ctx context.Context, req *proto.ToolExecuteRequest) (*proto.ToolExecuteResponse, error) {
	if m.executeFunc != nil {
		return m.executeFunc(ctx, req)
	}

	// Default: echo back the input with a "result" field
	var input map[string]any
	if err := json.Unmarshal([]byte(req.InputJson), &input); err != nil {
		return &proto.ToolExecuteResponse{
			Error: &proto.Error{
				Code:    "INVALID_INPUT",
				Message: fmt.Sprintf("failed to parse input: %v", err),
			},
		}, nil
	}

	output := map[string]any{
		"result": "success",
		"input":  input,
	}

	outputJSON, _ := json.Marshal(output)
	return &proto.ToolExecuteResponse{
		OutputJson: string(outputJSON),
	}, nil
}

// Health returns the tool's health status.
func (m *mockToolServer) Health(ctx context.Context, req *proto.ToolHealthRequest) (*proto.HealthStatus, error) {
	return &proto.HealthStatus{
		State:     "healthy",
		Message:   "Tool is operational",
		CheckedAt: time.Now().UnixMilli(),
	}, nil
}

// GetDescriptor returns the tool's metadata.
func (m *mockToolServer) GetDescriptor(ctx context.Context, req *proto.ToolGetDescriptorRequest) (*proto.ToolDescriptor, error) {
	return &proto.ToolDescriptor{
		Name:        m.name,
		Version:     m.version,
		Description: m.description,
		Tags:        []string{"test", "mock"},
		InputSchema: &proto.JSONSchema{
			Json: `{
				"type": "object",
				"properties": {
					"target": {"type": "string"}
				},
				"required": ["target"]
			}`,
		},
		OutputSchema: &proto.JSONSchema{
			Json: `{
				"type": "object",
				"properties": {
					"result": {"type": "string"}
				}
			}`,
		},
	}, nil
}

// mockPluginServer implements proto.PluginServiceServer for testing.
type mockPluginServer struct {
	proto.UnimplementedPluginServiceServer
	name        string
	version     string
	description string
	queryFunc   func(ctx context.Context, req *proto.PluginQueryRequest) (*proto.PluginQueryResponse, error)
}

// Query handles plugin query requests.
func (m *mockPluginServer) Query(ctx context.Context, req *proto.PluginQueryRequest) (*proto.PluginQueryResponse, error) {
	if m.queryFunc != nil {
		return m.queryFunc(ctx, req)
	}

	// Default: return success with method name
	result := map[string]any{
		"method": req.Method,
		"params": req.ParamsJson,
		"result": "success",
	}

	resultJSON, _ := json.Marshal(result)
	return &proto.PluginQueryResponse{
		ResultJson: string(resultJSON),
	}, nil
}

// Health returns the plugin's health status.
func (m *mockPluginServer) Health(ctx context.Context, req *proto.PluginHealthRequest) (*proto.HealthStatus, error) {
	return &proto.HealthStatus{
		State:     "healthy",
		Message:   "Plugin is ready",
		CheckedAt: time.Now().UnixMilli(),
	}, nil
}

// ListMethods returns the plugin's available methods.
func (m *mockPluginServer) ListMethods(ctx context.Context, req *proto.PluginListMethodsRequest) (*proto.PluginListMethodsResponse, error) {
	return &proto.PluginListMethodsResponse{
		Methods: []*proto.PluginMethodDescriptor{
			{
				Name:        "search",
				Description: "Search for data",
				InputSchema: &proto.JSONSchema{
					Json: `{
						"type": "object",
						"properties": {
							"query": {"type": "string"}
						}
					}`,
				},
			},
			{
				Name:        "retrieve",
				Description: "Retrieve data by ID",
				InputSchema: &proto.JSONSchema{
					Json: `{
						"type": "object",
						"properties": {
							"id": {"type": "string"}
						}
					}`,
				},
			},
		},
	}, nil
}

// TestE2E_AgentDiscoveryAndExecution tests the complete agent lifecycle:
// 1. Start mock agent gRPC server
// 2. Register with embedded etcd
// 3. Discover agent via registry adapter
// 4. Execute task via gRPC
// 5. Verify result
//
// This demonstrates the full component communication flow for agents.
func TestE2E_AgentDiscoveryAndExecution(t *testing.T) {
	ctx := context.Background()

	// Step 1: Create embedded etcd registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-agent",
		ListenAddress: "localhost:0", // Random port
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err, "failed to create embedded registry")
	defer reg.Close()

	// Step 2: Create and start mock agent gRPC server
	testSrv := newTestServer()
	defer testSrv.stop()

	mockAgent := &mockAgentServer{
		name:           "test-agent",
		version:        "1.0.0",
		description:    "Test agent for E2E testing",
		capabilities:   []string{"prompt_injection", "jailbreak"},
		targetTypes:    []string{"llm_chat", "llm_api"},
		techniqueTypes: []string{"prompt_injection"},
	}

	proto.RegisterAgentServiceServer(testSrv.server, mockAgent)
	testSrv.start()

	// Step 3: Register agent with etcd
	agentInfo := sdkregistry.ServiceInfo{
		Kind:       "agent",
		Name:       "test-agent",
		Version:    "1.0.0",
		InstanceID: uuid.New().String(),
		Endpoint:   testSrv.endpoint,
		Metadata: map[string]string{
			"description":     mockAgent.description,
			"capabilities":    "prompt_injection,jailbreak",
			"target_types":    "llm_chat,llm_api",
			"technique_types": "prompt_injection",
		},
		StartedAt: time.Now(),
	}

	err = reg.Register(ctx, agentInfo)
	require.NoError(t, err, "failed to register agent")

	// Step 4: Create registry adapter
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	// Override connection pool to use bufconn dialer for testing
	// Since GRPCPool doesn't expose internal fields, we create a custom pool
	// that intercepts the "bufconn" endpoint and uses our test server's dialer
	customPool := newTestGRPCPool(testSrv)
	adapter = NewRegistryAdapterWithPool(reg, customPool.GRPCPool)

	// Step 5: Discover agent via adapter
	agentClient, err := adapter.DiscoverAgent(ctx, "test-agent")
	require.NoError(t, err, "failed to discover agent")
	require.NotNil(t, agentClient, "agent client is nil")

	// Verify agent metadata
	assert.Equal(t, "test-agent", agentClient.Name())
	assert.Equal(t, "1.0.0", agentClient.Version())
	assert.Equal(t, "Test agent for E2E testing", agentClient.Description())
	assert.Contains(t, agentClient.Capabilities(), "prompt_injection")
	assert.Contains(t, agentClient.Capabilities(), "jailbreak")

	// Step 6: Execute task on agent
	task := agent.Task{
		ID:          types.NewID(),
		Name:        "test-task",
		Description: "Test task for E2E testing",
		Timeout:     30 * time.Second,
		Input:       map[string]any{"test": "param"},
	}

	result, err := agentClient.Execute(ctx, task, nil)
	require.NoError(t, err, "agent execution failed")

	// Verify result
	assert.Equal(t, agent.ResultStatusCompleted, result.Status)
	assert.NotNil(t, result.Output)

	// Step 7: Check health
	health := agentClient.Health(ctx)
	assert.Equal(t, "healthy", health.State)
}

// TestE2E_AgentNotFound verifies proper error handling when discovering
// a non-existent agent. The adapter should return AgentNotFoundError
// with a list of available agents.
func TestE2E_AgentNotFound(t *testing.T) {
	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-notfound",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Register a different agent
	agentInfo := sdkregistry.ServiceInfo{
		Kind:       "agent",
		Name:       "other-agent",
		Version:    "1.0.0",
		InstanceID: uuid.New().String(),
		Endpoint:   "localhost:50051",
		Metadata:   map[string]string{},
		StartedAt:  time.Now(),
	}

	err = reg.Register(ctx, agentInfo)
	require.NoError(t, err)

	// Try to discover non-existent agent
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	_, err = adapter.DiscoverAgent(ctx, "nonexistent-agent")
	require.Error(t, err, "expected error for non-existent agent")

	// Verify it's AgentNotFoundError
	var notFoundErr *AgentNotFoundError
	require.True(t, isAgentNotFoundError(err, &notFoundErr), "expected AgentNotFoundError")
	assert.Equal(t, "nonexistent-agent", notFoundErr.Name)
	assert.Contains(t, notFoundErr.Available, "other-agent")
}

// TestE2E_MultipleAgentInstances verifies load balancing across multiple
// instances of the same agent. The adapter should round-robin between instances.
func TestE2E_MultipleAgentInstances(t *testing.T) {
	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-multi",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Register three instances
	for i := 1; i <= 3; i++ {
		agentInfo := sdkregistry.ServiceInfo{
			Kind:       "agent",
			Name:       "multi-agent",
			Version:    "1.0.0",
			InstanceID: fmt.Sprintf("instance-%d", i),
			Endpoint:   fmt.Sprintf("localhost:5005%d", i),
			Metadata:   map[string]string{},
			StartedAt:  time.Now(),
		}

		err = reg.Register(ctx, agentInfo)
		require.NoError(t, err)
	}

	// Create adapter
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	// Discover multiple times - should round-robin
	endpoints := make(map[string]int)
	for i := 0; i < 6; i++ {
		// Discover creates a new client each time, which triggers load balancer
		selected, err := adapter.loadBalancer.Select(ctx, "agent", "multi-agent")
		require.NoError(t, err)
		endpoints[selected.Endpoint]++
	}

	// Verify all instances were selected (round-robin)
	assert.Equal(t, 3, len(endpoints), "expected all 3 instances to be selected")
	for endpoint, count := range endpoints {
		assert.Equal(t, 2, count, "expected each instance to be selected twice, got %d for %s", count, endpoint)
	}
}

// TestE2E_ToolDiscoveryAndExecution tests the complete tool lifecycle.
// Note: Tool gRPC client is not yet implemented, so this test is currently
// skipped. When implementation is complete, remove the skip.
func TestE2E_ToolDiscoveryAndExecution(t *testing.T) {
	t.Skip("Tool gRPC client not yet implemented - see Task 4")

	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-tool",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Create and start mock tool server
	testSrv := newTestServer()
	defer testSrv.stop()

	mockTool := &mockToolServer{
		name:        "test-tool",
		version:     "1.0.0",
		description: "Test tool for E2E testing",
	}

	proto.RegisterToolServiceServer(testSrv.server, mockTool)
	testSrv.start()

	// Register tool
	toolInfo := sdkregistry.ServiceInfo{
		Kind:       "tool",
		Name:       "test-tool",
		Version:    "1.0.0",
		InstanceID: uuid.New().String(),
		Endpoint:   testSrv.endpoint,
		Metadata: map[string]string{
			"description": mockTool.description,
		},
		StartedAt: time.Now(),
	}

	err = reg.Register(ctx, toolInfo)
	require.NoError(t, err)

	// Create adapter with bufconn dialer
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	customPool := newTestGRPCPool(testSrv)
	adapter = NewRegistryAdapterWithPool(reg, customPool.GRPCPool)

	// Discover tool
	toolClient, err := adapter.DiscoverTool(ctx, "test-tool")
	require.NoError(t, err)
	require.NotNil(t, toolClient)

	// Execute tool
	input := map[string]any{"target": "test-target"}
	output, err := toolClient.Execute(ctx, input)
	require.NoError(t, err)
	assert.Equal(t, "success", output["result"])

	// Check health
	health := toolClient.Health(ctx)
	assert.Equal(t, "healthy", health.State)
}

// TestE2E_PluginDiscoveryAndQuery tests the complete plugin lifecycle.
// Note: Plugin gRPC client is not yet implemented, so this test is currently
// skipped. When implementation is complete, remove the skip.
func TestE2E_PluginDiscoveryAndQuery(t *testing.T) {
	t.Skip("Plugin gRPC client not yet implemented - see Task 5")

	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-plugin",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Create and start mock plugin server
	testSrv := newTestServer()
	defer testSrv.stop()

	mockPlugin := &mockPluginServer{
		name:        "test-plugin",
		version:     "1.0.0",
		description: "Test plugin for E2E testing",
	}

	proto.RegisterPluginServiceServer(testSrv.server, mockPlugin)
	testSrv.start()

	// Register plugin
	pluginInfo := sdkregistry.ServiceInfo{
		Kind:       "plugin",
		Name:       "test-plugin",
		Version:    "1.0.0",
		InstanceID: uuid.New().String(),
		Endpoint:   testSrv.endpoint,
		Metadata: map[string]string{
			"description": mockPlugin.description,
		},
		StartedAt: time.Now(),
	}

	err = reg.Register(ctx, pluginInfo)
	require.NoError(t, err)

	// Create adapter with bufconn dialer
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	customPool := newTestGRPCPool(testSrv)
	adapter = NewRegistryAdapterWithPool(reg, customPool.GRPCPool)

	// Discover plugin
	pluginClient, err := adapter.DiscoverPlugin(ctx, "test-plugin")
	require.NoError(t, err)
	require.NotNil(t, pluginClient)

	// Query plugin
	params := map[string]any{"query": "test query"}
	result, err := pluginClient.Query(ctx, "search", params)
	require.NoError(t, err)
	assert.NotNil(t, result)

	// List methods
	methods := pluginClient.Methods()
	assert.GreaterOrEqual(t, len(methods), 2)

	// Check health
	health := pluginClient.Health(ctx)
	assert.Equal(t, "healthy", health.State)
}

// TestE2E_MultiComponentWorkflow tests a complex workflow involving
// multiple component types (agent, tool, plugin) working together.
//
// This simulates a realistic attack scenario where:
// 1. Agent is discovered and executed
// 2. Agent needs tool execution (simulated via harness)
// 3. Agent needs plugin query (simulated via harness)
// 4. All components are healthy and accessible
func TestE2E_MultiComponentWorkflow(t *testing.T) {
	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-multi-component",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Step 1: Create and register agent
	agentSrv := newTestServer()
	defer agentSrv.stop()

	mockAgent := &mockAgentServer{
		name:           "workflow-agent",
		version:        "1.0.0",
		description:    "Agent for workflow testing",
		capabilities:   []string{"prompt_injection"},
		targetTypes:    []string{"llm_chat"},
		techniqueTypes: []string{"prompt_injection"},
	}

	proto.RegisterAgentServiceServer(agentSrv.server, mockAgent)
	agentSrv.start()

	agentInfo := sdkregistry.ServiceInfo{
		Kind:       "agent",
		Name:       "workflow-agent",
		Version:    "1.0.0",
		InstanceID: uuid.New().String(),
		Endpoint:   "bufconn-agent",
		Metadata: map[string]string{
			"description":     mockAgent.description,
			"capabilities":    "prompt_injection",
			"target_types":    "llm_chat",
			"technique_types": "prompt_injection",
		},
		StartedAt: time.Now(),
	}

	err = reg.Register(ctx, agentInfo)
	require.NoError(t, err)

	// Step 2: Create adapter and verify agent discovery
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	customPool := newTestGRPCPool(agentSrv)
	adapter = NewRegistryAdapterWithPool(reg, customPool.GRPCPool)
			return grpc.DialContext(ctx, endpoint,
				grpc.WithTransportCredentials(insecure.NewCredentials()),
			)
		},
	}

	// Step 3: List all agents
	agents, err := adapter.ListAgents(ctx)
	require.NoError(t, err)
	require.Len(t, agents, 1)
	assert.Equal(t, "workflow-agent", agents[0].Name)
	assert.Equal(t, 1, agents[0].Instances)

	// Step 4: Discover and execute agent
	agentClient, err := adapter.DiscoverAgent(ctx, "workflow-agent")
	require.NoError(t, err)

	task := agent.Task{
		ID:          types.NewID(),
		Name:        "workflow-task",
		Description: "Task for workflow testing",
		Timeout:     30 * time.Second,
		Input:       map[string]any{"workflow": "test"},
	}

	result, err := agentClient.Execute(ctx, task, nil)
	require.NoError(t, err)
	assert.Equal(t, agent.ResultStatusCompleted, result.Status)

	// Step 5: Verify health of all components
	health := agentClient.Health(ctx)
	assert.Equal(t, "healthy", health.State)
}

// TestE2E_ComponentTimeout verifies timeout handling during execution.
// When a task exceeds its timeout, the context should be canceled and
// the execution should fail gracefully.
func TestE2E_ComponentTimeout(t *testing.T) {
	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-timeout",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Create agent that sleeps during execution
	testSrv := newTestServer()
	defer testSrv.stop()

	mockAgent := &mockAgentServer{
		name:           "slow-agent",
		version:        "1.0.0",
		description:    "Agent that times out",
		capabilities:   []string{"test"},
		targetTypes:    []string{"test"},
		techniqueTypes: []string{"test"},
		executeFunc: func(ctx context.Context, req *proto.AgentExecuteRequest) (*proto.AgentExecuteResponse, error) {
			// Sleep longer than timeout
			select {
			case <-time.After(5 * time.Second):
				// Should not reach here
			case <-ctx.Done():
				// Context canceled due to timeout
				return nil, ctx.Err()
			}
			return nil, nil
		},
	}

	proto.RegisterAgentServiceServer(testSrv.server, mockAgent)
	testSrv.start()

	// Register agent
	agentInfo := sdkregistry.ServiceInfo{
		Kind:       "agent",
		Name:       "slow-agent",
		Version:    "1.0.0",
		InstanceID: uuid.New().String(),
		Endpoint:   "bufconn",
		Metadata:   map[string]string{},
		StartedAt:  time.Now(),
	}

	err = reg.Register(ctx, agentInfo)
	require.NoError(t, err)

	// Create adapter
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	customPool := newTestGRPCPool(testSrv)
	adapter = NewRegistryAdapterWithPool(reg, customPool.GRPCPool)

	// Discover agent
	agentClient, err := adapter.DiscoverAgent(ctx, "slow-agent")
	require.NoError(t, err)

	// Execute with short timeout
	timeoutCtx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
	defer cancel()

	task := agent.Task{
		ID:          types.NewID(),
		Name:        "timeout-task",
		Description: "Task that should timeout",
		Timeout:     100 * time.Millisecond,
		Input:       map[string]any{},
	}

	result, err := agentClient.Execute(timeoutCtx, task, nil)

	// Execution should fail due to timeout
	// Either err is not nil, or result indicates failure
	if err == nil {
		assert.Equal(t, agent.ResultStatusFailed, result.Status, "expected failure status for timed out task")
	}
}

// TestE2E_ListAllComponents verifies that ListAgents, ListTools, and ListPlugins
// correctly aggregate instances and provide metadata.
func TestE2E_ListAllComponents(t *testing.T) {
	ctx := context.Background()

	// Create embedded registry
	cfg := sdkregistry.Config{
		Type:          "embedded",
		DataDir:       t.TempDir() + "/etcd-list",
		ListenAddress: "localhost:0",
		Namespace:     "gibson-test",
		TTL:           30,
	}

	reg, err := NewEmbeddedRegistry(cfg)
	require.NoError(t, err)
	defer reg.Close()

	// Register multiple agents with multiple instances
	for i := 1; i <= 2; i++ {
		agentInfo := sdkregistry.ServiceInfo{
			Kind:       "agent",
			Name:       fmt.Sprintf("agent-%d", i),
			Version:    "1.0.0",
			InstanceID: fmt.Sprintf("agent-%d-instance-1", i),
			Endpoint:   fmt.Sprintf("localhost:5005%d", i),
			Metadata: map[string]string{
				"description":     fmt.Sprintf("Agent %d", i),
				"capabilities":    "prompt_injection,jailbreak",
				"target_types":    "llm_chat",
				"technique_types": "prompt_injection",
			},
			StartedAt: time.Now(),
		}
		err = reg.Register(ctx, agentInfo)
		require.NoError(t, err)
	}

	// Register second instance of agent-1
	agentInfo := sdkregistry.ServiceInfo{
		Kind:       "agent",
		Name:       "agent-1",
		Version:    "1.0.0",
		InstanceID: "agent-1-instance-2",
		Endpoint:   "localhost:50053",
		Metadata: map[string]string{
			"description":     "Agent 1",
			"capabilities":    "prompt_injection,jailbreak",
			"target_types":    "llm_chat",
			"technique_types": "prompt_injection",
		},
		StartedAt: time.Now(),
	}
	err = reg.Register(ctx, agentInfo)
	require.NoError(t, err)

	// Create adapter
	adapter := NewRegistryAdapter(reg)
	defer adapter.Close()

	// List agents
	agents, err := adapter.ListAgents(ctx)
	require.NoError(t, err)
	require.Len(t, agents, 2, "expected 2 unique agents")

	// Find agent-1 and verify it has 2 instances
	var agent1 *AgentInfo
	for i := range agents {
		if agents[i].Name == "agent-1" {
			agent1 = &agents[i]
			break
		}
	}
	require.NotNil(t, agent1, "agent-1 not found")
	assert.Equal(t, 2, agent1.Instances, "expected 2 instances of agent-1")
	assert.Len(t, agent1.Endpoints, 2, "expected 2 endpoints")
	assert.Contains(t, agent1.Capabilities, "prompt_injection")
	assert.Contains(t, agent1.Capabilities, "jailbreak")
}

// Component Communication Pattern Documentation
//
// The following describes the typical lifecycle of component communication in Gibson:
//
// ## 1. Component Registration
// When a component (agent/tool/plugin) starts, it:
//   a. Creates a gRPC server and starts listening
//   b. Registers with etcd registry using ServiceInfo
//   c. Includes metadata: name, version, endpoint, capabilities, etc.
//   d. Etcd grants a lease with TTL (e.g., 30 seconds)
//   e. Component starts background keepalive to renew lease
//
// Example ServiceInfo:
//   {
//     Kind:       "agent",
//     Name:       "davinci",
//     Version:    "1.0.0",
//     InstanceID: "uuid-1234",
//     Endpoint:   "localhost:50051",
//     Metadata:   {"capabilities": "jailbreak,prompt_injection"},
//     StartedAt:  time.Now(),
//   }
//
// ## 2. Component Discovery
// When the orchestrator needs a component, it:
//   a. Calls adapter.DiscoverAgent/Tool/Plugin(ctx, name)
//   b. Adapter queries registry for all instances
//   c. Load balancer selects an instance (round-robin, random, etc.)
//   d. Connection pool gets or creates gRPC connection
//   e. Wrapped client is returned (implements Gibson interface)
//
// Discovery flow:
//   registry.Discover(ctx, "agent", "davinci")
//     -> []ServiceInfo with endpoints
//     -> loadBalancer.Select()
//     -> pool.Get(endpoint)
//     -> NewGRPCAgentClient(conn, info)
//
// ## 3. RPC Execution
// When a component operation is invoked, it:
//   a. Marshals parameters to JSON/protobuf
//   b. Sends gRPC request to remote component
//   c. Component executes operation
//   d. Response is unmarshaled and returned
//
// For agents: Execute(ctx, task, harness) -> Result
// For tools:  Execute(ctx, input) -> (output, error)
// For plugins: Query(ctx, method, params) -> (result, error)
//
// ## 4. Health Monitoring
// Health checks occur:
//   a. Periodically via adapter.Health(ctx)
//   b. Before critical operations
//   c. In connection pool (stale connection detection)
//
// Health states: healthy, degraded, unhealthy
//
// ## 5. Component Deregistration
// On graceful shutdown:
//   a. Component revokes its etcd lease
//   b. Etcd immediately removes the registration
//   c. gRPC server stops accepting requests
//   d. Active requests complete (graceful stop)
//
// On crash:
//   a. Keepalive stops sending renewals
//   b. Lease expires after TTL (e.g., 30 seconds)
//   c. Etcd automatically removes registration
//
// ## 6. Load Balancing
// Multiple instances of the same component:
//   - Round-robin: cycles through instances in order
//   - Random: random selection (good for distributed load)
//   - Future: Health-aware, latency-based selection
//
// ## 7. Connection Pooling
// The GRPCPool maintains connections:
//   - Reuses connections to same endpoint
//   - Handles connection failures (reconnect)
//   - Cleans up stale connections
//   - Thread-safe for concurrent access
//
// ## 8. Error Handling
// Error scenarios and handling:
//   - AgentNotFoundError: No instances registered
//   - RegistryUnavailableError: Etcd connection failed
//   - NoHealthyInstancesError: All instances unhealthy
//   - Connection errors: Pool retries/removes endpoint
//   - Execution errors: Wrapped in Result or returned as error
