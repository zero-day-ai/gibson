package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/zero-day-ai/gibson/internal/graphrag/taxonomy"
)

const generatedFileTemplate = `// Code generated by taxonomy-gen. DO NOT EDIT.
// Source: github.com/zero-day-ai/gibson/internal/graphrag/taxonomy
// Taxonomy Version: {{.Version}}

package graphrag

// TaxonomyVersion is the version of the taxonomy that these constants were generated from.
// This version is tied to the Gibson binary version.
const TaxonomyVersion = "{{.Version}}"

// Node type constants
// These constants define the canonical node types in the GraphRAG taxonomy.
const (
{{- range .NodeTypes}}
	// {{.Name}} - {{.Description}}
	{{.ConstName}} = "{{.Type}}"
{{- end}}
)

// Relationship type constants
// These constants define the canonical relationship types in the GraphRAG taxonomy.
const (
{{- range .RelationshipTypes}}
	// {{.Name}} - {{.Description}}
	{{.ConstName}} = "{{.Type}}"
{{- end}}
)

// MITRE ATT&CK Technique ID constants
const (
{{- range .MITRETechniques}}
	// {{.Name}} - {{.Description}}
	{{.ConstName}} = "{{.TechniqueID}}"
{{- end}}
)

// Common property name constants
const (
	PropName        = "name"
	PropTitle       = "title"
	PropDescription = "description"
	PropSeverity    = "severity"
	PropConfidence  = "confidence"
	PropCategory    = "category"
	PropURL         = "url"
	PropIP          = "ip"
	PropPort        = "port"
	PropProtocol    = "protocol"
	PropMethod      = "method"
	PropStatusCode  = "status_code"
	PropTimestamp   = "timestamp"
)
`

type templateData struct {
	Version           string
	NodeTypes         []nodeTypeConst
	RelationshipTypes []relationshipTypeConst
	MITRETechniques   []techniqueConst
}

type nodeTypeConst struct {
	Name        string
	Type        string
	ConstName   string
	Description string
}

type relationshipTypeConst struct {
	Name        string
	Type        string
	ConstName   string
	Description string
}

type techniqueConst struct {
	Name        string
	TechniqueID string
	ConstName   string
	Description string
}

func main() {
	var (
		outputFile string
		inputDir   string
	)

	flag.StringVar(&outputFile, "output", "", "Output file path (required)")
	flag.StringVar(&inputDir, "input", "", "Input taxonomy directory (optional, uses embedded if not specified)")
	flag.Parse()

	if outputFile == "" {
		fmt.Fprintf(os.Stderr, "Error: -output flag is required\n")
		flag.Usage()
		os.Exit(1)
	}

	// Load taxonomy
	var tax *taxonomy.Taxonomy
	var err error

	if inputDir != "" {
		// Load from custom path (not commonly used)
		customPath := filepath.Join(inputDir, "taxonomy.yaml")
		tax, err = taxonomy.LoadTaxonomyWithCustom(customPath)
	} else {
		// Load embedded taxonomy
		tax, err = taxonomy.LoadTaxonomy()
	}

	if err != nil {
		fmt.Fprintf(os.Stderr, "Error loading taxonomy: %v\n", err)
		os.Exit(1)
	}

	// Validate taxonomy
	if err := taxonomy.ValidateTaxonomy(tax); err != nil {
		fmt.Fprintf(os.Stderr, "Error validating taxonomy: %v\n", err)
		os.Exit(1)
	}

	// Build template data
	data := buildTemplateData(tax)

	// Generate code
	tmpl, err := template.New("generated").Parse(generatedFileTemplate)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error formatting generated code: %v\n", err)
		fmt.Fprintf(os.Stderr, "Generated code:\n%s\n", buf.String())
		os.Exit(1)
	}

	// Write to output file
	if err := os.WriteFile(outputFile, formatted, 0644); err != nil {
		fmt.Fprintf(os.Stderr, "Error writing output file: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", outputFile)
	fmt.Printf("Taxonomy version: %s\n", tax.Version)
	fmt.Printf("Node types: %d\n", len(tax.NodeTypes))
	fmt.Printf("Relationships: %d\n", len(tax.Relationships))
	fmt.Printf("Techniques: %d\n", len(tax.Techniques))
}

func buildTemplateData(tax *taxonomy.Taxonomy) templateData {
	data := templateData{
		Version:           tax.Version,
		NodeTypes:         make([]nodeTypeConst, 0),
		RelationshipTypes: make([]relationshipTypeConst, 0),
		MITRETechniques:   make([]techniqueConst, 0),
	}

	// Build node type constants
	for _, nodeDef := range tax.NodeTypes {
		data.NodeTypes = append(data.NodeTypes, nodeTypeConst{
			Name:        nodeDef.Name,
			Type:        nodeDef.Type,
			ConstName:   toConstName("NodeType", nodeDef.Type),
			Description: truncateDescription(nodeDef.Description),
		})
	}

	// Sort node types by const name for deterministic output
	sort.Slice(data.NodeTypes, func(i, j int) bool {
		return data.NodeTypes[i].ConstName < data.NodeTypes[j].ConstName
	})

	// Build relationship type constants
	for _, relDef := range tax.Relationships {
		data.RelationshipTypes = append(data.RelationshipTypes, relationshipTypeConst{
			Name:        relDef.Name,
			Type:        relDef.Type,
			ConstName:   toConstName("RelType", relDef.Type),
			Description: truncateDescription(relDef.Description),
		})
	}

	// Sort relationship types by const name
	sort.Slice(data.RelationshipTypes, func(i, j int) bool {
		return data.RelationshipTypes[i].ConstName < data.RelationshipTypes[j].ConstName
	})

	// Build technique constants
	for _, techDef := range tax.Techniques {
		constItem := techniqueConst{
			Name:        techDef.Name,
			TechniqueID: techDef.TechniqueID,
			ConstName:   toTechniqueConstName(techDef.TechniqueID),
			Description: truncateDescription(techDef.Description),
		}

		if techDef.Taxonomy == "mitre" {
			data.MITRETechniques = append(data.MITRETechniques, constItem)
		}
	}

	// Sort techniques by const name
	sort.Slice(data.MITRETechniques, func(i, j int) bool {
		return data.MITRETechniques[i].ConstName < data.MITRETechniques[j].ConstName
	})

	return data
}

// toConstName converts a type string to a Go constant name.
// Examples:
//
//	domain -> NodeTypeDomain
//	subdomain -> NodeTypeSubdomain
//	HAS_SUBDOMAIN -> RelTypeHasSubdomain
func toConstName(prefix, typeName string) string {
	// Split on underscores and capitalize each part
	parts := strings.Split(typeName, "_")
	for i, part := range parts {
		parts[i] = strings.Title(strings.ToLower(part))
	}

	return prefix + strings.Join(parts, "")
}

// toTechniqueConstName converts a technique ID to a Go constant name.
// Examples:
//
//	T1190 -> TechniqueT1190
//	ARC-T001 -> TechniqueARCT001
func toTechniqueConstName(techniqueID string) string {
	// Remove hyphens and format
	cleaned := strings.ReplaceAll(techniqueID, "-", "")
	return "Technique" + cleaned
}

// truncateDescription truncates a description to fit in a single-line comment.
func truncateDescription(desc string) string {
	const maxLen = 100
	if len(desc) <= maxLen {
		return desc
	}

	// Truncate and add ellipsis
	return desc[:maxLen-3] + "..."
}
