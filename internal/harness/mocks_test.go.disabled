package harness

import (
	"context"

	"github.com/zero-day-ai/gibson/internal/agent"
	"github.com/zero-day-ai/gibson/internal/llm"
	"github.com/zero-day-ai/gibson/internal/memory"
	"github.com/zero-day-ai/gibson/internal/plugin"
	"github.com/zero-day-ai/gibson/internal/schema"
	"github.com/zero-day-ai/gibson/internal/tool"
	"github.com/zero-day-ai/gibson/internal/types"
)

// ────────────────────────────────────────────────────────────────────────────
// Mock LLM Provider
// ────────────────────────────────────────────────────────────────────────────

type MockLLMProvider struct {
	CompleteFn         func(ctx context.Context, req llm.CompletionRequest) (*llm.CompletionResponse, error)
	CompleteWithToolsFn func(ctx context.Context, req llm.CompletionRequest, tools []llm.ToolDef) (*llm.CompletionResponse, error)
	StreamFn           func(ctx context.Context, req llm.CompletionRequest) (<-chan llm.StreamChunk, error)
	NameFn             func() string
	SupportedModelsFn  func() []string
}

func (m *MockLLMProvider) Complete(ctx context.Context, req llm.CompletionRequest) (*llm.CompletionResponse, error) {
	if m.CompleteFn != nil {
		return m.CompleteFn(ctx, req)
	}
	return &llm.CompletionResponse{
		Message: llm.NewAssistantMessage("mock response"),
		Usage: llm.TokenUsage{
			PromptTokens:     10,
			CompletionTokens: 20,
			TotalTokens:      30,
		},
	}, nil
}

func (m *MockLLMProvider) CompleteWithTools(ctx context.Context, req llm.CompletionRequest, tools []llm.ToolDef) (*llm.CompletionResponse, error) {
	if m.CompleteWithToolsFn != nil {
		return m.CompleteWithToolsFn(ctx, req, tools)
	}
	return m.Complete(ctx, req)
}

func (m *MockLLMProvider) Stream(ctx context.Context, req llm.CompletionRequest) (<-chan llm.StreamChunk, error) {
	if m.StreamFn != nil {
		return m.StreamFn(ctx, req)
	}
	ch := make(chan llm.StreamChunk, 1)
	ch <- llm.StreamChunk{
		Delta: llm.NewAssistantMessage("streamed response"),
		Usage: &llm.TokenUsage{
			PromptTokens:     10,
			CompletionTokens: 20,
			TotalTokens:      30,
		},
	}
	close(ch)
	return ch, nil
}

func (m *MockLLMProvider) Name() string {
	if m.NameFn != nil {
		return m.NameFn()
	}
	return "mock-provider"
}

func (m *MockLLMProvider) SupportedModels() []string {
	if m.SupportedModelsFn != nil {
		return m.SupportedModelsFn()
	}
	return []string{"mock-model"}
}

var _ llm.LLMProvider = (*MockLLMProvider)(nil)

// ────────────────────────────────────────────────────────────────────────────
// Mock Tool
// ────────────────────────────────────────────────────────────────────────────

type MockTool struct {
	NameFn        func() string
	DescriptionFn func() string
	VersionFn     func() string
	TagsFn        func() []string
	InputSchemaFn func() schema.JSONSchema
	OutputSchemaFn func() schema.JSONSchema
	ExecuteFn     func(ctx context.Context, input map[string]any) (map[string]any, error)
}

func (m *MockTool) Name() string {
	if m.NameFn != nil {
		return m.NameFn()
	}
	return "mock-tool"
}

func (m *MockTool) Description() string {
	if m.DescriptionFn != nil {
		return m.DescriptionFn()
	}
	return "A mock tool for testing"
}

func (m *MockTool) Version() string {
	if m.VersionFn != nil {
		return m.VersionFn()
	}
	return "1.0.0"
}

func (m *MockTool) Tags() []string {
	if m.TagsFn != nil {
		return m.TagsFn()
	}
	return []string{"test", "mock"}
}

func (m *MockTool) InputSchema() schema.JSONSchema {
	if m.InputSchemaFn != nil {
		return m.InputSchemaFn()
	}
	return schema.JSONSchema{
		Type: "object",
		Properties: map[string]schema.JSONSchema{
			"input": {Type: "string"},
		},
	}
}

func (m *MockTool) OutputSchema() schema.JSONSchema {
	if m.OutputSchemaFn != nil {
		return m.OutputSchemaFn()
	}
	return schema.JSONSchema{
		Type: "object",
		Properties: map[string]schema.JSONSchema{
			"output": {Type: "string"},
		},
	}
}

func (m *MockTool) Execute(ctx context.Context, input map[string]any) (map[string]any, error) {
	if m.ExecuteFn != nil {
		return m.ExecuteFn(ctx, input)
	}
	return map[string]any{"output": "mock result"}, nil
}

var _ tool.Tool = (*MockTool)(nil)

// ────────────────────────────────────────────────────────────────────────────
// Mock Plugin
// ────────────────────────────────────────────────────────────────────────────

type MockPlugin struct {
	NameFn    func() string
	VersionFn func() string
	MethodsFn func() []plugin.MethodDescriptor
	InitFn    func(ctx context.Context, config map[string]any) error
	CallFn    func(ctx context.Context, method string, params map[string]any) (any, error)
	CloseFn   func(ctx context.Context) error
}

func (m *MockPlugin) Name() string {
	if m.NameFn != nil {
		return m.NameFn()
	}
	return "mock-plugin"
}

func (m *MockPlugin) Version() string {
	if m.VersionFn != nil {
		return m.VersionFn()
	}
	return "1.0.0"
}

func (m *MockPlugin) Methods() []plugin.MethodDescriptor {
	if m.MethodsFn != nil {
		return m.MethodsFn()
	}
	return []plugin.MethodDescriptor{
		{
			Name:        "testMethod",
			Description: "A test method",
		},
	}
}

func (m *MockPlugin) Init(ctx context.Context, config map[string]any) error {
	if m.InitFn != nil {
		return m.InitFn(ctx, config)
	}
	return nil
}

func (m *MockPlugin) Call(ctx context.Context, method string, params map[string]any) (any, error) {
	if m.CallFn != nil {
		return m.CallFn(ctx, method, params)
	}
	return "mock result", nil
}

func (m *MockPlugin) Close(ctx context.Context) error {
	if m.CloseFn != nil {
		return m.CloseFn(ctx)
	}
	return nil
}

var _ plugin.Plugin = (*MockPlugin)(nil)

// ────────────────────────────────────────────────────────────────────────────
// Mock Agent
// ────────────────────────────────────────────────────────────────────────────

type MockAgent struct {
	NameFn         func() string
	VersionFn      func() string
	DescriptionFn  func() string
	CapabilitiesFn func() []string
	LLMSlotsFn     func() []agent.SlotDefinition
	ExecuteFn      func(ctx context.Context, task agent.Task, harness AgentHarness) (agent.Result, error)
}

func (m *MockAgent) Name() string {
	if m.NameFn != nil {
		return m.NameFn()
	}
	return "mock-agent"
}

func (m *MockAgent) Version() string {
	if m.VersionFn != nil {
		return m.VersionFn()
	}
	return "1.0.0"
}

func (m *MockAgent) Description() string {
	if m.DescriptionFn != nil {
		return m.DescriptionFn()
	}
	return "A mock agent for testing"
}

func (m *MockAgent) Capabilities() []string {
	if m.CapabilitiesFn != nil {
		return m.CapabilitiesFn()
	}
	return []string{"test", "mock"}
}

func (m *MockAgent) LLMSlots() []agent.SlotDefinition {
	if m.LLMSlotsFn != nil {
		return m.LLMSlotsFn()
	}
	return []agent.SlotDefinition{
		{
			Name:     "primary",
			Required: true,
		},
	}
}

func (m *MockAgent) Execute(ctx context.Context, task agent.Task, harness AgentHarness) (agent.Result, error) {
	if m.ExecuteFn != nil {
		return m.ExecuteFn(ctx, task, harness)
	}
	return agent.Result{
		Output: map[string]any{"success": true},
	}, nil
}

var _ agent.Agent = (*MockAgent)(nil)

// ────────────────────────────────────────────────────────────────────────────
// Mock Memory Store
// ────────────────────────────────────────────────────────────────────────────

type MockMemoryStore struct {
	WorkingFn  func() memory.KeyValueStore
	MissionFn  func() memory.KeyValueStore
	LongTermFn func() memory.VectorStore
}

func (m *MockMemoryStore) Working() memory.KeyValueStore {
	if m.WorkingFn != nil {
		return m.WorkingFn()
	}
	return &MockKeyValueStore{}
}

func (m *MockMemoryStore) Mission() memory.KeyValueStore {
	if m.MissionFn != nil {
		return m.MissionFn()
	}
	return &MockKeyValueStore{}
}

func (m *MockMemoryStore) LongTerm() memory.VectorStore {
	if m.LongTermFn != nil {
		return m.LongTermFn()
	}
	return &MockVectorStore{}
}

var _ memory.MemoryStore = (*MockMemoryStore)(nil)

type MockKeyValueStore struct {
	SetFn    func(ctx context.Context, key string, value any) error
	GetFn    func(ctx context.Context, key string) (any, error)
	DeleteFn func(ctx context.Context, key string) error
	ListFn   func(ctx context.Context) ([]string, error)
}

func (m *MockKeyValueStore) Set(ctx context.Context, key string, value any) error {
	if m.SetFn != nil {
		return m.SetFn(ctx, key, value)
	}
	return nil
}

func (m *MockKeyValueStore) Get(ctx context.Context, key string) (any, error) {
	if m.GetFn != nil {
		return m.GetFn(ctx, key)
	}
	return nil, nil
}

func (m *MockKeyValueStore) Delete(ctx context.Context, key string) error {
	if m.DeleteFn != nil {
		return m.DeleteFn(ctx, key)
	}
	return nil
}

func (m *MockKeyValueStore) List(ctx context.Context) ([]string, error) {
	if m.ListFn != nil {
		return m.ListFn(ctx)
	}
	return []string{}, nil
}

var _ memory.KeyValueStore = (*MockKeyValueStore)(nil)

type MockVectorStore struct {
	StoreFn  func(ctx context.Context, doc memory.Document) error
	SearchFn func(ctx context.Context, query string, limit int) ([]memory.Document, error)
}

func (m *MockVectorStore) Store(ctx context.Context, doc memory.Document) error {
	if m.StoreFn != nil {
		return m.StoreFn(ctx, doc)
	}
	return nil
}

func (m *MockVectorStore) Search(ctx context.Context, query string, limit int) ([]memory.Document, error) {
	if m.SearchFn != nil {
		return m.SearchFn(ctx, query, limit)
	}
	return []memory.Document{}, nil
}

var _ memory.VectorStore = (*MockVectorStore)(nil)

// ────────────────────────────────────────────────────────────────────────────
// Mock Metrics Recorder
// ────────────────────────────────────────────────────────────────────────────

type MockMetricsRecorder struct {
	RecordCounterFn   func(name string, value int64, labels map[string]string)
	RecordGaugeFn     func(name string, value float64, labels map[string]string)
	RecordHistogramFn func(name string, value float64, labels map[string]string)
}

func (m *MockMetricsRecorder) RecordCounter(name string, value int64, labels map[string]string) {
	if m.RecordCounterFn != nil {
		m.RecordCounterFn(name, value, labels)
	}
}

func (m *MockMetricsRecorder) RecordGauge(name string, value float64, labels map[string]string) {
	if m.RecordGaugeFn != nil {
		m.RecordGaugeFn(name, value, labels)
	}
}

func (m *MockMetricsRecorder) RecordHistogram(name string, value float64, labels map[string]string) {
	if m.RecordHistogramFn != nil {
		m.RecordHistogramFn(name, value, labels)
	}
}

var _ MetricsRecorder = (*MockMetricsRecorder)(nil)

// ────────────────────────────────────────────────────────────────────────────
// Mock Finding Store
// ────────────────────────────────────────────────────────────────────────────

type MockFindingStore struct {
	StoreFn func(ctx context.Context, missionID types.ID, finding agent.Finding) error
	GetFn   func(ctx context.Context, missionID types.ID, filter FindingFilter) ([]agent.Finding, error)
}

func (m *MockFindingStore) Store(ctx context.Context, missionID types.ID, finding agent.Finding) error {
	if m.StoreFn != nil {
		return m.StoreFn(ctx, missionID, finding)
	}
	return nil
}

func (m *MockFindingStore) Get(ctx context.Context, missionID types.ID, filter FindingFilter) ([]agent.Finding, error) {
	if m.GetFn != nil {
		return m.GetFn(ctx, missionID, filter)
	}
	return []agent.Finding{}, nil
}

var _ FindingStore = (*MockFindingStore)(nil)
