package harness

import (
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/zero-day-ai/gibson/internal/agent"
	"github.com/zero-day-ai/gibson/internal/plugin"
	"github.com/zero-day-ai/gibson/internal/schema"
)

// ────────────────────────────────────────────────────────────────────────────
// ToolDescriptor Tests
// ────────────────────────────────────────────────────────────────────────────

func TestFromTool(t *testing.T) {
	inputSchema := schema.JSONSchema{
		Type: "object",
		Properties: map[string]schema.JSONSchema{
			"target": {Type: "string"},
			"port":   {Type: "integer"},
		},
	}

	outputSchema := schema.JSONSchema{
		Type: "object",
		Properties: map[string]schema.JSONSchema{
			"result": {Type: "string"},
		},
	}

	mockTool := &MockTool{
		NameFn:        func() string { return "test-tool" },
		DescriptionFn: func() string { return "A test tool" },
		VersionFn:     func() string { return "1.0.0" },
		TagsFn:        func() []string { return []string{"network", "scanning"} },
		InputSchemaFn: func() schema.JSONSchema { return inputSchema },
		OutputSchemaFn: func() schema.JSONSchema { return outputSchema },
	}

	descriptor := FromTool(mockTool)

	assert.Equal(t, "test-tool", descriptor.Name)
	assert.Equal(t, "A test tool", descriptor.Description)
	assert.Equal(t, "1.0.0", descriptor.Version)
	assert.Equal(t, []string{"network", "scanning"}, descriptor.Tags)
	assert.Equal(t, inputSchema, descriptor.InputSchema)
	assert.Equal(t, outputSchema, descriptor.OutputSchema)
}

func TestToolDescriptor_HasTag(t *testing.T) {
	tests := []struct {
		name     string
		tags     []string
		searchTag string
		expected bool
	}{
		{
			name:      "tag exists",
			tags:      []string{"network", "scanning", "security"},
			searchTag: "scanning",
			expected:  true,
		},
		{
			name:      "tag does not exist",
			tags:      []string{"network", "scanning"},
			searchTag: "web",
			expected:  false,
		},
		{
			name:      "empty tags",
			tags:      []string{},
			searchTag: "network",
			expected:  false,
		},
		{
			name:      "case sensitive",
			tags:      []string{"Network"},
			searchTag: "network",
			expected:  false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			descriptor := ToolDescriptor{
				Name: "test",
				Tags: tt.tags,
			}

			result := descriptor.HasTag(tt.searchTag)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestToolDescriptor_HasTag_EmptyString(t *testing.T) {
	descriptor := ToolDescriptor{
		Name: "test",
		Tags: []string{"network", ""},
	}

	assert.True(t, descriptor.HasTag(""))
	assert.True(t, descriptor.HasTag("network"))
}

// ────────────────────────────────────────────────────────────────────────────
// PluginDescriptor Tests
// ────────────────────────────────────────────────────────────────────────────

func TestFromPlugin(t *testing.T) {
	methods := []plugin.MethodDescriptor{
		{Name: "query", Description: "Execute a query"},
		{Name: "update", Description: "Update data"},
	}

	mockPlugin := &MockPlugin{
		NameFn:    func() string { return "test-plugin" },
		VersionFn: func() string { return "2.0.0" },
		MethodsFn: func() []plugin.MethodDescriptor { return methods },
	}

	descriptor := FromPlugin(mockPlugin)

	assert.Equal(t, "test-plugin", descriptor.Name)
	assert.Equal(t, "2.0.0", descriptor.Version)
	assert.Equal(t, methods, descriptor.Methods)
	assert.False(t, descriptor.IsExternal)
	assert.Equal(t, plugin.PluginStatusUninitialized, descriptor.Status)
}

func TestPluginDescriptor_HasMethod(t *testing.T) {
	tests := []struct {
		name       string
		methods    []plugin.MethodDescriptor
		searchMethod string
		expected   bool
	}{
		{
			name: "method exists",
			methods: []plugin.MethodDescriptor{
				{Name: "query"},
				{Name: "update"},
				{Name: "delete"},
			},
			searchMethod: "update",
			expected:     true,
		},
		{
			name: "method does not exist",
			methods: []plugin.MethodDescriptor{
				{Name: "query"},
				{Name: "update"},
			},
			searchMethod: "delete",
			expected:     false,
		},
		{
			name:         "empty methods",
			methods:      []plugin.MethodDescriptor{},
			searchMethod: "query",
			expected:     false,
		},
		{
			name: "case sensitive",
			methods: []plugin.MethodDescriptor{
				{Name: "Query"},
			},
			searchMethod: "query",
			expected:     false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			descriptor := PluginDescriptor{
				Name:    "test",
				Methods: tt.methods,
			}

			result := descriptor.HasMethod(tt.searchMethod)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestPluginDescriptor_GetMethod(t *testing.T) {
	methods := []plugin.MethodDescriptor{
		{Name: "query", Description: "Execute a query"},
		{Name: "update", Description: "Update data"},
		{Name: "delete", Description: "Delete data"},
	}

	descriptor := PluginDescriptor{
		Name:    "test",
		Methods: methods,
	}

	t.Run("method exists", func(t *testing.T) {
		method := descriptor.GetMethod("update")
		assert.NotNil(t, method)
		assert.Equal(t, "update", method.Name)
		assert.Equal(t, "Update data", method.Description)
	})

	t.Run("method does not exist", func(t *testing.T) {
		method := descriptor.GetMethod("nonexistent")
		assert.Nil(t, method)
	})

	t.Run("empty method name", func(t *testing.T) {
		method := descriptor.GetMethod("")
		assert.Nil(t, method)
	})
}

func TestPluginDescriptor_GetMethod_FirstMatch(t *testing.T) {
	// Test that GetMethod returns the first match if there are duplicates
	methods := []plugin.MethodDescriptor{
		{Name: "query", Description: "First"},
		{Name: "query", Description: "Second"},
	}

	descriptor := PluginDescriptor{
		Name:    "test",
		Methods: methods,
	}

	method := descriptor.GetMethod("query")
	assert.NotNil(t, method)
	assert.Equal(t, "First", method.Description)
}

// ────────────────────────────────────────────────────────────────────────────
// AgentDescriptor Tests
// ────────────────────────────────────────────────────────────────────────────

func TestFromAgent(t *testing.T) {
	capabilities := []string{"network-scanning", "vulnerability-detection"}
	slots := []agent.SlotDefinition{
		{Name: "primary", Required: true},
		{Name: "reasoning", Required: false},
	}

	mockAgent := &MockAgent{
		NameFn:         func() string { return "test-agent" },
		VersionFn:      func() string { return "3.0.0" },
		DescriptionFn:  func() string { return "A test agent" },
		CapabilitiesFn: func() []string { return capabilities },
		LLMSlotsFn:     func() []agent.SlotDefinition { return slots },
	}

	descriptor := FromAgent(mockAgent)

	assert.Equal(t, "test-agent", descriptor.Name)
	assert.Equal(t, "3.0.0", descriptor.Version)
	assert.Equal(t, "A test agent", descriptor.Description)
	assert.Equal(t, capabilities, descriptor.Capabilities)
	assert.Equal(t, slots, descriptor.Slots)
	assert.False(t, descriptor.IsExternal)
}

func TestAgentDescriptor_HasCapability(t *testing.T) {
	tests := []struct {
		name         string
		capabilities []string
		searchCap    string
		expected     bool
	}{
		{
			name:         "capability exists",
			capabilities: []string{"network-scanning", "vulnerability-detection", "exploitation"},
			searchCap:    "vulnerability-detection",
			expected:     true,
		},
		{
			name:         "capability does not exist",
			capabilities: []string{"network-scanning", "vulnerability-detection"},
			searchCap:    "exploitation",
			expected:     false,
		},
		{
			name:         "empty capabilities",
			capabilities: []string{},
			searchCap:    "network-scanning",
			expected:     false,
		},
		{
			name:         "case sensitive",
			capabilities: []string{"Network-Scanning"},
			searchCap:    "network-scanning",
			expected:     false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			descriptor := AgentDescriptor{
				Name:         "test",
				Capabilities: tt.capabilities,
			}

			result := descriptor.HasCapability(tt.searchCap)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestAgentDescriptor_RequiresSlot(t *testing.T) {
	tests := []struct {
		name     string
		slots    []agent.SlotDefinition
		slotName string
		expected bool
	}{
		{
			name: "required slot exists",
			slots: []agent.SlotDefinition{
				{Name: "primary", Required: true},
				{Name: "reasoning", Required: false},
			},
			slotName: "primary",
			expected: true,
		},
		{
			name: "optional slot exists",
			slots: []agent.SlotDefinition{
				{Name: "primary", Required: true},
				{Name: "reasoning", Required: false},
			},
			slotName: "reasoning",
			expected: false,
		},
		{
			name: "slot does not exist",
			slots: []agent.SlotDefinition{
				{Name: "primary", Required: true},
			},
			slotName: "reasoning",
			expected: false,
		},
		{
			name:     "empty slots",
			slots:    []agent.SlotDefinition{},
			slotName: "primary",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			descriptor := AgentDescriptor{
				Name:  "test",
				Slots: tt.slots,
			}

			result := descriptor.RequiresSlot(tt.slotName)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestAgentDescriptor_GetSlot(t *testing.T) {
	slots := []agent.SlotDefinition{
		{Name: "primary", Required: true},
		{Name: "reasoning", Required: false},
		{Name: "fast", Required: false},
	}

	descriptor := AgentDescriptor{
		Name:  "test",
		Slots: slots,
	}

	t.Run("slot exists", func(t *testing.T) {
		slot := descriptor.GetSlot("reasoning")
		assert.NotNil(t, slot)
		assert.Equal(t, "reasoning", slot.Name)
		assert.False(t, slot.Required)
	})

	t.Run("required slot exists", func(t *testing.T) {
		slot := descriptor.GetSlot("primary")
		assert.NotNil(t, slot)
		assert.Equal(t, "primary", slot.Name)
		assert.True(t, slot.Required)
	})

	t.Run("slot does not exist", func(t *testing.T) {
		slot := descriptor.GetSlot("nonexistent")
		assert.Nil(t, slot)
	})

	t.Run("empty slot name", func(t *testing.T) {
		slot := descriptor.GetSlot("")
		assert.Nil(t, slot)
	})
}

func TestAgentDescriptor_GetSlot_FirstMatch(t *testing.T) {
	// Test that GetSlot returns the first match if there are duplicates
	slots := []agent.SlotDefinition{
		{Name: "primary", Required: true},
		{Name: "primary", Required: false},
	}

	descriptor := AgentDescriptor{
		Name:  "test",
		Slots: slots,
	}

	slot := descriptor.GetSlot("primary")
	assert.NotNil(t, slot)
	assert.True(t, slot.Required)
}

// ────────────────────────────────────────────────────────────────────────────
// Integration and Edge Cases
// ────────────────────────────────────────────────────────────────────────────

func TestDescriptors_EmptyCollections(t *testing.T) {
	t.Run("tool with no tags", func(t *testing.T) {
		mockTool := &MockTool{
			TagsFn: func() []string { return []string{} },
		}
		descriptor := FromTool(mockTool)
		assert.Empty(t, descriptor.Tags)
		assert.False(t, descriptor.HasTag("anything"))
	})

	t.Run("plugin with no methods", func(t *testing.T) {
		mockPlugin := &MockPlugin{
			MethodsFn: func() []plugin.MethodDescriptor { return []plugin.MethodDescriptor{} },
		}
		descriptor := FromPlugin(mockPlugin)
		assert.Empty(t, descriptor.Methods)
		assert.False(t, descriptor.HasMethod("anything"))
		assert.Nil(t, descriptor.GetMethod("anything"))
	})

	t.Run("agent with no capabilities", func(t *testing.T) {
		mockAgent := &MockAgent{
			CapabilitiesFn: func() []string { return []string{} },
		}
		descriptor := FromAgent(mockAgent)
		assert.Empty(t, descriptor.Capabilities)
		assert.False(t, descriptor.HasCapability("anything"))
	})

	t.Run("agent with no slots", func(t *testing.T) {
		mockAgent := &MockAgent{
			LLMSlotsFn: func() []agent.SlotDefinition { return []agent.SlotDefinition{} },
		}
		descriptor := FromAgent(mockAgent)
		assert.Empty(t, descriptor.Slots)
		assert.False(t, descriptor.RequiresSlot("anything"))
		assert.Nil(t, descriptor.GetSlot("anything"))
	})
}

func TestDescriptors_NilSchemas(t *testing.T) {
	mockTool := &MockTool{
		InputSchemaFn:  func() schema.JSONSchema { return schema.JSONSchema{} },
		OutputSchemaFn: func() schema.JSONSchema { return schema.JSONSchema{} },
	}

	descriptor := FromTool(mockTool)
	assert.Equal(t, schema.JSONSchema{}, descriptor.InputSchema)
	assert.Equal(t, schema.JSONSchema{}, descriptor.OutputSchema)
}

func TestToolDescriptor_MultipleTagsSearch(t *testing.T) {
	descriptor := ToolDescriptor{
		Name: "multi-tool",
		Tags: []string{"network", "scanning", "security", "passive", "active"},
	}

	assert.True(t, descriptor.HasTag("network"))
	assert.True(t, descriptor.HasTag("security"))
	assert.True(t, descriptor.HasTag("passive"))
	assert.True(t, descriptor.HasTag("active"))
	assert.False(t, descriptor.HasTag("web"))
}

func TestPluginDescriptor_MethodWithComplexDescriptor(t *testing.T) {
	methods := []plugin.MethodDescriptor{
		{
			Name:        "complexMethod",
			Description: "A complex method with long description",
		},
	}

	descriptor := PluginDescriptor{
		Name:    "test",
		Methods: methods,
	}

	method := descriptor.GetMethod("complexMethod")
	assert.NotNil(t, method)
	assert.Equal(t, "complexMethod", method.Name)
	assert.Equal(t, "A complex method with long description", method.Description)
}

func TestAgentDescriptor_ComplexSlotDefinitions(t *testing.T) {
	slots := []agent.SlotDefinition{
		{Name: "primary", Required: true},
		{Name: "reasoning", Required: false},
		{Name: "fast", Required: false},
		{Name: "vision", Required: false},
	}

	descriptor := AgentDescriptor{
		Name:  "complex-agent",
		Slots: slots,
	}

	assert.True(t, descriptor.RequiresSlot("primary"))
	assert.False(t, descriptor.RequiresSlot("reasoning"))
	assert.False(t, descriptor.RequiresSlot("fast"))
	assert.False(t, descriptor.RequiresSlot("vision"))
	assert.False(t, descriptor.RequiresSlot("nonexistent"))

	// Verify GetSlot works for all
	for _, slot := range slots {
		retrieved := descriptor.GetSlot(slot.Name)
		assert.NotNil(t, retrieved)
		assert.Equal(t, slot.Name, retrieved.Name)
		assert.Equal(t, slot.Required, retrieved.Required)
	}
}

func TestDescriptors_SpecialCharacters(t *testing.T) {
	t.Run("tool with special character tags", func(t *testing.T) {
		descriptor := ToolDescriptor{
			Tags: []string{"network-scan", "web_scan", "scan:active"},
		}
		assert.True(t, descriptor.HasTag("network-scan"))
		assert.True(t, descriptor.HasTag("web_scan"))
		assert.True(t, descriptor.HasTag("scan:active"))
	})

	t.Run("plugin with special character method names", func(t *testing.T) {
		descriptor := PluginDescriptor{
			Methods: []plugin.MethodDescriptor{
				{Name: "query_data"},
				{Name: "update-record"},
			},
		}
		assert.True(t, descriptor.HasMethod("query_data"))
		assert.True(t, descriptor.HasMethod("update-record"))
	})

	t.Run("agent with special character capabilities", func(t *testing.T) {
		descriptor := AgentDescriptor{
			Capabilities: []string{"network-scanning", "vuln_detection", "exploit:active"},
		}
		assert.True(t, descriptor.HasCapability("network-scanning"))
		assert.True(t, descriptor.HasCapability("vuln_detection"))
		assert.True(t, descriptor.HasCapability("exploit:active"))
	})
}
