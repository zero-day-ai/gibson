package daemon

import (
	"context"
	"fmt"
	"log/slog"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/zero-day-ai/gibson/internal/daemon/api"
	"github.com/zero-day-ai/gibson/internal/mission"
	"github.com/zero-day-ai/gibson/internal/types"
)

// mockMissionStore is a mock implementation of mission.MissionStore interface

func (m *mockMissionStore) Create(ctx context.Context, mission *mission.Mission) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	if m.missions == nil {
		m.missions = make(map[string]*mission.Mission)
	}
	m.missions[mission.ID.String()] = mission
	return nil
}





// mockEventBus is a mock implementation of EventBus for testing
type mockEventBus struct {
	publishedEvents []api.EventData
	mu              sync.Mutex
}

func (m *mockEventBus) Publish(ctx context.Context, event api.EventData) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	m.publishedEvents = append(m.publishedEvents, event)
	return nil
}

func (m *mockEventBus) Subscribe(ctx context.Context, eventTypes []string, missionID string) (<-chan api.EventData, error) {
	ch := make(chan api.EventData)
	close(ch)
	return ch, nil
}

func (m *mockEventBus) getPublishedEvents() []api.EventData {
	m.mu.Lock()
	defer m.mu.Unlock()
	return append([]api.EventData{}, m.publishedEvents...)
}

// TestStopMission_Success tests successfully stopping a running mission.
func TestStopMission_Success(t *testing.T) {
	missionID := "test-mission-123"

	// Create a mock mission
	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "Test Mission",
		Status: mission.MissionStatusRunning,
		Metrics: &mission.MissionMetrics{
			StartedAt: time.Now().Add(-5 * time.Minute),
		},
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
	}

	eventBus := &mockEventBus{}

	// Create daemon with active mission
	ctx, cancel := context.WithCancel(context.Background())
	daemon := &daemonImpl{
		logger:       slog.Default(),
		missionStore: store,
		activeMissions: map[string]context.CancelFunc{
			missionID: cancel,
		},
		eventBus: eventBus,
	}

	// Stop the mission
	err := daemon.StopMission(context.Background(), missionID, false)
	require.NoError(t, err)

	// Verify mission was removed from active missions
	daemon.missionsMu.RLock()
	_, exists := daemon.activeMissions[missionID]
	daemon.missionsMu.RUnlock()
	assert.False(t, exists, "mission should be removed from activeMissions")

	// Verify mission status was updated
	updatedMission, err := store.Get(context.Background(), missionID)
	require.NoError(t, err)
	assert.Equal(t, mission.MissionStatusCancelled, updatedMission.Status)
	assert.NotNil(t, updatedMission.CompletedAt)

	// Verify event was published
	events := eventBus.getPublishedEvents()
	assert.Len(t, events, 1)
	assert.Equal(t, "mission_stopped", events[0].EventType)
	assert.NotNil(t, events[0].MissionEvent)
	assert.Equal(t, missionID, events[0].MissionEvent.MissionID)
}

// TestStopMission_NotRunning tests stopping a mission that is not running.
func TestStopMission_NotRunning(t *testing.T) {
	missionID := "test-mission-456"

	// Create a mock mission in completed state
	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "Completed Mission",
		Status: mission.MissionStatusCompleted,
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
	}

	daemon := &daemonImpl{
		logger:         slog.Default(),
		missionStore:   store,
		activeMissions: map[string]context.CancelFunc{},
	}

	// Attempt to stop the mission
	err := daemon.StopMission(context.Background(), missionID, false)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "not currently running")
}

// TestStopMission_NotFound tests stopping a mission that doesn't exist.
func TestStopMission_NotFound(t *testing.T) {
	missionID := "nonexistent-mission"

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{},
	}

	daemon := &daemonImpl{
		logger:         slog.Default(),
		missionStore:   store,
		activeMissions: map[string]context.CancelFunc{},
	}

	// Attempt to stop non-existent mission
	err := daemon.StopMission(context.Background(), missionID, false)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "mission not found")
}

// TestStopMission_EmptyMissionID tests validation of mission ID.
func TestStopMission_EmptyMissionID(t *testing.T) {
	daemon := &daemonImpl{
		logger:         slog.Default(),
		activeMissions: map[string]context.CancelFunc{},
	}

	err := daemon.StopMission(context.Background(), "", false)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "mission ID cannot be empty")
}

// TestStopMission_WithForce tests force flag is properly logged and emitted.
func TestStopMission_WithForce(t *testing.T) {
	missionID := "test-mission-force"

	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "Force Stop Mission",
		Status: mission.MissionStatusRunning,
		Metrics: &mission.MissionMetrics{
			StartedAt: time.Now(),
		},
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
	}

	eventBus := &mockEventBus{}

	ctx, cancel := context.WithCancel(context.Background())
	daemon := &daemonImpl{
		logger:       slog.Default(),
		missionStore: store,
		activeMissions: map[string]context.CancelFunc{
			missionID: cancel,
		},
		eventBus: eventBus,
	}

	// Stop with force=true
	err := daemon.StopMission(context.Background(), missionID, true)
	require.NoError(t, err)

	// Verify event includes force flag in message
	events := eventBus.getPublishedEvents()
	assert.Len(t, events, 1)
	assert.Contains(t, events[0].MissionEvent.Message, "force=true")
}

// TestStopMission_StoreUpdateError tests handling of store update errors.
func TestStopMission_StoreUpdateError(t *testing.T) {
	missionID := "test-mission-error"

	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "Error Mission",
		Status: mission.MissionStatusRunning,
		Metrics: &mission.MissionMetrics{
			StartedAt: time.Now(),
		},
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
		updateFunc: func(ctx context.Context, m *mission.Mission) error {
			return fmt.Errorf("database error")
		},
	}

	ctx, cancel := context.WithCancel(context.Background())
	daemon := &daemonImpl{
		logger:       slog.Default(),
		missionStore: store,
		activeMissions: map[string]context.CancelFunc{
			missionID: cancel,
		},
	}

	// Stop should succeed even if store update fails (cancellation was successful)
	err := daemon.StopMission(context.Background(), missionID, false)
	assert.NoError(t, err, "StopMission should not fail due to store update error")

	// Verify mission was still removed from active missions
	daemon.missionsMu.RLock()
	_, exists := daemon.activeMissions[missionID]
	daemon.missionsMu.RUnlock()
	assert.False(t, exists)
}

// TestStopMission_ConcurrentStops tests preventing duplicate stop requests.
func TestStopMission_ConcurrentStops(t *testing.T) {
	missionID := "test-mission-concurrent"

	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "Concurrent Stop Mission",
		Status: mission.MissionStatusRunning,
		Metrics: &mission.MissionMetrics{
			StartedAt: time.Now(),
		},
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
	}

	ctx, cancel := context.WithCancel(context.Background())
	daemon := &daemonImpl{
		logger:       slog.Default(),
		missionStore: store,
		activeMissions: map[string]context.CancelFunc{
			missionID: cancel,
		},
		eventBus: &mockEventBus{},
	}

	// First stop should succeed
	err1 := daemon.StopMission(context.Background(), missionID, false)
	assert.NoError(t, err1)

	// Second stop should fail (mission no longer running)
	err2 := daemon.StopMission(context.Background(), missionID, false)
	assert.Error(t, err2)
	assert.Contains(t, err2.Error(), "not currently running")
}

// TestStopMission_MetricsDuration tests that mission duration is calculated.
func TestStopMission_MetricsDuration(t *testing.T) {
	missionID := "test-mission-duration"
	startTime := time.Now().Add(-10 * time.Minute)

	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "Duration Mission",
		Status: mission.MissionStatusRunning,
		Metrics: &mission.MissionMetrics{
			StartedAt: startTime,
		},
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
	}

	ctx, cancel := context.WithCancel(context.Background())
	daemon := &daemonImpl{
		logger:       slog.Default(),
		missionStore: store,
		activeMissions: map[string]context.CancelFunc{
			missionID: cancel,
		},
		eventBus: &mockEventBus{},
	}

	err := daemon.StopMission(context.Background(), missionID, false)
	require.NoError(t, err)

	// Verify duration was calculated
	updatedMission, err := store.Get(context.Background(), missionID)
	require.NoError(t, err)
	assert.Greater(t, updatedMission.Metrics.Duration, 9*time.Minute)
	assert.Less(t, updatedMission.Metrics.Duration, 11*time.Minute)
}

// TestStopMission_WithoutEventBus tests that StopMission works without event bus.
func TestStopMission_WithoutEventBus(t *testing.T) {
	missionID := "test-mission-no-eventbus"

	mockMission := &mission.Mission{
		ID:     types.MustParseID(missionID),
		Name:   "No EventBus Mission",
		Status: mission.MissionStatusRunning,
		Metrics: &mission.MissionMetrics{
			StartedAt: time.Now(),
		},
	}

	store := &mockMissionStore{
		missions: map[string]*mission.Mission{
			missionID: mockMission,
		},
	}

	ctx, cancel := context.WithCancel(context.Background())
	daemon := &daemonImpl{
		logger:       slog.Default(),
		missionStore: store,
		activeMissions: map[string]context.CancelFunc{
			missionID: cancel,
		},
		eventBus: nil, // No event bus
	}

	// Should succeed even without event bus
	err := daemon.StopMission(context.Background(), missionID, false)
	assert.NoError(t, err)

	// Verify mission was cancelled
	updatedMission, err := store.Get(context.Background(), missionID)
	require.NoError(t, err)
	assert.Equal(t, mission.MissionStatusCancelled, updatedMission.Status)
}
