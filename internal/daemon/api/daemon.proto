syntax = "proto3";

package gibson.daemon.v1;

option go_package = "github.com/zero-day-ai/gibson/internal/daemon/api;api";

// Import SDK common types for TypedValue, TypedMap, ErrorCode, etc.
import "common.proto";

// MissionStatus represents the execution status of a mission.
enum MissionStatus {
  MISSION_STATUS_UNSPECIFIED = 0;
  MISSION_STATUS_PENDING = 1;
  MISSION_STATUS_RUNNING = 2;
  MISSION_STATUS_PAUSED = 3;
  MISSION_STATUS_COMPLETED = 4;
  MISSION_STATUS_FAILED = 5;
  MISSION_STATUS_CANCELLED = 6;
}

// DaemonService provides the gRPC API for Gibson daemon client communication.
//
// This service exposes all daemon functionality including mission execution,
// agent management, attack operations, and real-time event streaming for the TUI.
service DaemonService {
  // Connect establishes a client connection to the daemon.
  // Returns connection metadata and daemon version info.
  rpc Connect(ConnectRequest) returns (ConnectResponse);

  // Ping checks if the daemon is responsive.
  // Used for health checks and connection validation.
  rpc Ping(PingRequest) returns (PingResponse);

  // Status returns the current daemon status including uptime,
  // service endpoints, and component counts.
  rpc Status(StatusRequest) returns (StatusResponse);

  // RunMission starts a mission and streams execution events.
  // The stream remains open until the mission completes or is stopped.
  rpc RunMission(RunMissionRequest) returns (stream MissionEvent);

  // StopMission gracefully stops a running mission.
  rpc StopMission(StopMissionRequest) returns (StopMissionResponse);

  // ListMissions returns all missions (past and active).
  rpc ListMissions(ListMissionsRequest) returns (ListMissionsResponse);

  // ListAgents returns all registered agents from the etcd registry.
  rpc ListAgents(ListAgentsRequest) returns (ListAgentsResponse);

  // GetAgentStatus returns the current status of a specific agent.
  rpc GetAgentStatus(GetAgentStatusRequest) returns (AgentStatusResponse);

  // ListTools returns all registered tools from the etcd registry.
  rpc ListTools(ListToolsRequest) returns (ListToolsResponse);

  // ListPlugins returns all registered plugins from the etcd registry.
  rpc ListPlugins(ListPluginsRequest) returns (ListPluginsResponse);

  // QueryPlugin executes a method on a plugin and returns the result.
  // The plugin must be registered in the etcd registry.
  rpc QueryPlugin(QueryPluginRequest) returns (QueryPluginResponse);

  // RunAttack executes an attack and streams progress events.
  // The stream remains open until the attack completes or is stopped.
  rpc RunAttack(RunAttackRequest) returns (stream AttackEvent);

  // Subscribe establishes an event stream for TUI real-time updates.
  // Streams mission events, agent events, finding events, etc.
  rpc Subscribe(SubscribeRequest) returns (stream Event);

  // StartComponent starts a component (agent, tool, or plugin) by kind and name.
  // The component must be installed in the local database.
  rpc StartComponent(StartComponentRequest) returns (StartComponentResponse);

  // StopComponent stops a running component (agent, tool, or plugin) by kind and name.
  // If force is true, sends SIGKILL immediately instead of graceful SIGTERM.
  rpc StopComponent(StopComponentRequest) returns (StopComponentResponse);

  // PauseMission pauses a running mission at the next clean checkpoint boundary.
  // If force is true, pauses immediately without waiting for a clean boundary.
  rpc PauseMission(PauseMissionRequest) returns (PauseMissionResponse);

  // ResumeMission resumes a paused mission from its last checkpoint.
  // Returns a stream of mission events as execution continues.
  rpc ResumeMission(ResumeMissionRequest) returns (stream MissionEvent);

  // GetMissionHistory returns all runs for a mission name, showing the
  // complete history of mission executions with the same workflow name.
  rpc GetMissionHistory(GetMissionHistoryRequest) returns (GetMissionHistoryResponse);

  // GetMissionCheckpoints returns all checkpoints for a specific mission,
  // providing visibility into saved execution states for resume capability.
  rpc GetMissionCheckpoints(GetMissionCheckpointsRequest) returns (GetMissionCheckpointsResponse);

  // ExecuteTool executes a tool via the Tool Executor Service.
  // Routes tool execution through the centralized tool executor which handles
  // schema validation, timeout management, and execution tracking.
  rpc ExecuteTool(ExecuteToolRequest) returns (ExecuteToolResponse);

  // GetAvailableTools returns all available tools from the Tool Executor Service.
  // Provides detailed information about each tool including schemas, capabilities,
  // and execution metrics.
  rpc GetAvailableTools(GetAvailableToolsRequest) returns (GetAvailableToolsResponse);

  // InstallComponent installs a component (agent, tool, or plugin) from a Git repository.
  // Clones the repository, builds the component, and registers it in the registry.
  rpc InstallComponent(InstallComponentRequest) returns (InstallComponentResponse);

  // InstallAllComponent installs all components from a mono-repo.
  // Clones the repository once, discovers all component.yaml files, and installs each component.
  rpc InstallAllComponent(InstallAllComponentRequest) returns (InstallAllComponentResponse);

  // UninstallComponent removes a component (agent, tool, or plugin) from the system.
  // Stops the component if running and removes it from the registry.
  rpc UninstallComponent(UninstallComponentRequest) returns (UninstallComponentResponse);

  // UpdateComponent updates a component (agent, tool, or plugin) to the latest version.
  // Pulls latest changes, rebuilds, and optionally restarts if it was running.
  rpc UpdateComponent(UpdateComponentRequest) returns (UpdateComponentResponse);

  // BuildComponent rebuilds a component (agent, tool, or plugin) from source.
  // Useful for rebuilding after manual code changes.
  rpc BuildComponent(BuildComponentRequest) returns (BuildComponentResponse);

  // ShowComponent returns detailed information about a component.
  // Includes manifest, status, paths, and lifecycle information.
  rpc ShowComponent(ShowComponentRequest) returns (ShowComponentResponse);

  // GetComponentLogs streams log entries for a component.
  // Supports follow mode for continuous streaming and line limits.
  rpc GetComponentLogs(GetComponentLogsRequest) returns (stream LogEntry);

  // InstallMission installs a mission from a Git repository.
  // Clones the repository, validates mission.yaml, and registers it in the registry.
  rpc InstallMission(InstallMissionRequest) returns (InstallMissionResponse);

  // UninstallMission removes an installed mission from the system.
  rpc UninstallMission(UninstallMissionRequest) returns (UninstallMissionResponse);

  // ListMissionDefinitions returns all installed mission definitions.
  rpc ListMissionDefinitions(ListMissionDefinitionsRequest) returns (ListMissionDefinitionsResponse);

  // UpdateMission updates an installed mission to the latest version.
  // Pulls latest changes and rebuilds the mission definition.
  rpc UpdateMission(UpdateMissionRequest) returns (UpdateMissionResponse);

  // ResolveMissionDependencies resolves the complete dependency tree for a mission.
  // Walks all transitive dependencies from agents, tools, and plugins.
  rpc ResolveMissionDependencies(ResolveMissionDependenciesRequest) returns (ResolveMissionDependenciesResponse);

  // ValidateMissionDependencies validates that all mission dependencies are installed and running.
  // Returns detailed validation results with component status and any issues found.
  rpc ValidateMissionDependencies(ValidateMissionDependenciesRequest) returns (ValidateMissionDependenciesResponse);

  // EnsureDependenciesRunning starts any stopped dependencies in the correct topological order.
  // Ensures all components required by a mission are running before execution.
  rpc EnsureDependenciesRunning(EnsureDependenciesRunningRequest) returns (EnsureDependenciesRunningResponse);
}

// ConnectRequest initiates a client connection to the daemon.
message ConnectRequest {
  // client_version is the version of the Gibson CLI client
  string client_version = 1;

  // client_id is an optional unique identifier for this client
  string client_id = 2;
}

// ConnectResponse returns connection metadata.
message ConnectResponse {
  // daemon_version is the version of the running daemon
  string daemon_version = 1;

  // session_id is a unique identifier for this client session
  string session_id = 2;

  // grpc_address is the address the daemon is listening on
  string grpc_address = 3;
}

// PingRequest is an empty health check request.
message PingRequest {}

// PingResponse confirms the daemon is responsive.
message PingResponse {
  // timestamp is the server time when the ping was received
  int64 timestamp = 1;
}

// StatusRequest queries daemon status.
message StatusRequest {}

// StatusResponse returns complete daemon status information.
message StatusResponse {
  // running indicates if the daemon is running (always true if responding)
  bool running = 1;

  // pid is the process ID of the daemon
  int32 pid = 2;

  // start_time is when the daemon started (Unix timestamp)
  int64 start_time = 3;

  // uptime is the human-readable uptime string
  string uptime = 4;

  // grpc_address is the gRPC server address
  string grpc_address = 5;

  // registry_type is the type of registry (embedded, external)
  string registry_type = 6;

  // registry_addr is the registry endpoint address
  string registry_addr = 7;

  // callback_addr is the callback server address
  string callback_addr = 8;

  // agent_count is the number of registered agents
  int32 agent_count = 9;

  // mission_count is the total number of missions
  int32 mission_count = 10;

  // active_mission_count is the number of currently running missions
  int32 active_mission_count = 11;
}

// RunMissionRequest starts a mission execution.
message RunMissionRequest {
  // workflow_path is the path to the mission workflow YAML file
  string workflow_path = 1;

  // mission_id is an optional custom mission identifier
  string mission_id = 2;

  // variables contains workflow variables to override
  map<string, string> variables = 3;

  // memory_continuity defines how agent memory is shared across mission runs
  // Valid values: "isolated" (default), "inherit", "shared"
  string memory_continuity = 4;
}

// MissionEvent represents a mission execution event.
message MissionEvent {
  // event_type identifies the type of event
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // mission_id is the unique mission identifier
  string mission_id = 3;

  // node_id is the workflow node ID (if applicable)
  string node_id = 4;

  // message is a human-readable event message
  string message = 5;

  // data contains event-specific data (typed map)
  gibson.common.TypedMap data = 6;

  // error contains error information if the event represents an error
  string error = 7;

  // result contains typed operation metrics (for mission.completed events)
  OperationResult result = 8;
}

// StopMissionRequest requests mission termination.
message StopMissionRequest {
  // mission_id is the identifier of the mission to stop
  string mission_id = 1;

  // force indicates whether to force-kill the mission (default: graceful)
  bool force = 2;
}

// StopMissionResponse confirms mission stop request.
message StopMissionResponse {
  // success indicates if the stop request was accepted
  bool success = 1;

  // message provides additional context
  string message = 2;
}

// ListMissionsRequest queries mission list.
message ListMissionsRequest {
  // active_only filters to only running missions
  bool active_only = 1;

  // limit restricts the number of results
  int32 limit = 2;

  // offset is the pagination offset
  int32 offset = 3;

  // status_filter filters missions by status (running, completed, failed, cancelled)
  string status_filter = 4;

  // name_pattern filters missions by name using glob pattern matching
  string name_pattern = 5;
}

// ListMissionsResponse returns mission list.
message ListMissionsResponse {
  // missions is the list of missions
  repeated MissionInfo missions = 1;

  // total is the total count of missions (for pagination)
  int32 total = 2;
}

// MissionInfo describes a mission.
message MissionInfo {
  // id is the unique mission identifier
  string id = 1;

  // workflow_path is the path to the workflow file (legacy, may be "<inline>")
  string workflow_path = 2;

  // status is the mission status (running, completed, failed)
  string status = 3;

  // start_time is when the mission started (Unix timestamp)
  int64 start_time = 4;

  // end_time is when the mission ended (Unix timestamp, 0 if running)
  int64 end_time = 5;

  // finding_count is the number of findings discovered
  int32 finding_count = 6;

  // name is the human-readable mission name
  string name = 7;
}

// ListAgentsRequest queries agent registry.
message ListAgentsRequest {
  // kind filters by component kind (empty = all agents)
  string kind = 1;
}

// ListAgentsResponse returns registered agents.
message ListAgentsResponse {
  // agents is the list of registered agents
  repeated AgentInfo agents = 1;
}

// AgentInfo describes a registered agent.
message AgentInfo {
  // id is the unique agent identifier
  string id = 1;

  // name is the agent name
  string name = 2;

  // kind is the component kind (always "agent")
  string kind = 3;

  // version is the agent version
  string version = 4;

  // endpoint is the gRPC endpoint for the agent
  string endpoint = 5;

  // capabilities lists agent capabilities
  repeated string capabilities = 6;

  // health is the agent health status (healthy, unhealthy)
  string health = 7;

  // last_seen is when the agent was last seen (Unix timestamp)
  int64 last_seen = 8;
}

// GetAgentStatusRequest queries a specific agent.
message GetAgentStatusRequest {
  // agent_id is the unique agent identifier
  string agent_id = 1;
}

// AgentStatusResponse returns agent status.
message AgentStatusResponse {
  // agent is the agent information
  AgentInfo agent = 1;

  // active indicates if the agent is currently executing a task
  bool active = 2;

  // current_task describes the active task (if any)
  string current_task = 3;

  // task_start_time is when the current task started (Unix timestamp)
  int64 task_start_time = 4;
}

// ListToolsRequest queries tool registry.
message ListToolsRequest {}

// ListToolsResponse returns registered tools.
message ListToolsResponse {
  // tools is the list of registered tools
  repeated ToolInfo tools = 1;
}

// ToolInfo describes a registered tool.
message ToolInfo {
  // id is the unique tool identifier
  string id = 1;

  // name is the tool name
  string name = 2;

  // version is the tool version
  string version = 3;

  // endpoint is the gRPC endpoint for the tool
  string endpoint = 4;

  // description is the tool description
  string description = 5;

  // health is the tool health status (healthy, unhealthy)
  string health = 6;

  // last_seen is when the tool was last seen (Unix timestamp)
  int64 last_seen = 7;
}

// ListPluginsRequest queries plugin registry.
message ListPluginsRequest {}

// ListPluginsResponse returns registered plugins.
message ListPluginsResponse {
  // plugins is the list of registered plugins
  repeated PluginInfo plugins = 1;
}

// PluginInfo describes a registered plugin.
message PluginInfo {
  // id is the unique plugin identifier
  string id = 1;

  // name is the plugin name
  string name = 2;

  // version is the plugin version
  string version = 3;

  // endpoint is the gRPC endpoint for the plugin
  string endpoint = 4;

  // description is the plugin description
  string description = 5;

  // health is the plugin health status (healthy, unhealthy)
  string health = 6;

  // last_seen is when the plugin was last seen (Unix timestamp)
  int64 last_seen = 7;
}

// QueryPluginRequest executes a method on a plugin.
message QueryPluginRequest {
  // name is the plugin name to query
  string name = 1;

  // method is the method name to execute
  string method = 2;

  // params is the typed parameters for the method
  gibson.common.TypedMap params = 3;

  // timeout_ms is the optional timeout in milliseconds (0 = default)
  int64 timeout_ms = 4;

  // Reserved field numbers for removed fields
  reserved 5;
  reserved "params_json";
}

// QueryPluginResponse returns the result of a plugin query.
message QueryPluginResponse {
  // result is the typed result from the plugin method
  gibson.common.TypedValue result = 1;

  // error is set if the query failed
  string error = 2;

  // duration_ms is how long the query took in milliseconds
  int64 duration_ms = 3;

  // Reserved field numbers for removed fields
  reserved 4;
  reserved "result_json";
}

// RunAttackRequest executes an attack.
message RunAttackRequest {
  // target is the target URL or identifier
  string target = 1;

  // attack_type is the type of attack to execute
  string attack_type = 2;

  // agent_id is the agent to use (optional, auto-select if empty)
  string agent_id = 3;

  // payload_filter filters which payloads to use
  string payload_filter = 4;

  // options contains attack-specific options
  map<string, string> options = 5;

  // target_name is the name of a stored target to look up from the database
  string target_name = 6;
}

// AttackEvent represents an attack execution event.
message AttackEvent {
  // event_type identifies the type of event
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // attack_id is the unique attack identifier
  string attack_id = 3;

  // message is a human-readable event message
  string message = 4;

  // data contains event-specific data (typed map)
  gibson.common.TypedMap data = 5;

  // error contains error information if the event represents an error
  string error = 6;

  // finding describes a discovered finding (if applicable)
  FindingInfo finding = 7;

  // result contains typed operation metrics (for attack.completed events)
  OperationResult result = 8;
}

// FindingInfo describes a discovered vulnerability.
message FindingInfo {
  // id is the unique finding identifier
  string id = 1;

  // title is the finding title
  string title = 2;

  // severity is the severity level (info, low, medium, high, critical)
  string severity = 3;

  // category is the finding category
  string category = 4;

  // description is the detailed finding description
  string description = 5;

  // technique is the MITRE ATT&CK or ATLAS technique ID
  string technique = 6;

  // evidence contains supporting evidence
  string evidence = 7;

  // timestamp is when the finding was discovered (Unix timestamp)
  int64 timestamp = 8;
}

// SubscribeRequest establishes an event stream.
message SubscribeRequest {
  // event_types filters which event types to receive (empty = all)
  repeated string event_types = 1;

  // mission_id filters to a specific mission (empty = all)
  string mission_id = 2;
}

// Event represents a generic daemon event.
message Event {
  // event_type identifies the type of event
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // source is the event source (mission, agent, daemon, etc.)
  string source = 3;

  // data contains event-specific data (typed map)
  gibson.common.TypedMap data = 4;

  // Specific event types (only one will be set)
  oneof event {
    MissionEvent mission_event = 5;
    AttackEvent attack_event = 6;
    AgentEvent agent_event = 7;
    FindingEvent finding_event = 8;
  }
}

// AgentEvent represents an agent lifecycle event.
message AgentEvent {
  // event_type identifies the agent event type (registered, unregistered, health_change)
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // agent_id is the agent identifier
  string agent_id = 3;

  // agent_name is the agent name
  string agent_name = 4;

  // message is a human-readable message
  string message = 5;

  // data contains event-specific data (typed map)
  gibson.common.TypedMap data = 6;
}

// FindingEvent represents a finding discovery event.
message FindingEvent {
  // event_type identifies the finding event type (discovered, updated)
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // finding is the finding information
  FindingInfo finding = 3;

  // mission_id is the mission that discovered the finding
  string mission_id = 4;
}

// StartComponentRequest requests starting a component.
message StartComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name
  string name = 2;
}

// StartComponentResponse returns the result of starting a component.
message StartComponentResponse {
  // success indicates if the component was started successfully
  bool success = 1;

  // pid is the process ID of the started component
  int32 pid = 2;

  // port is the port the component is listening on
  int32 port = 3;

  // message provides additional context or error information
  string message = 4;

  // log_path is the path to the component's log file
  string log_path = 5;
}

// StopComponentRequest requests stopping a component.
message StopComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name
  string name = 2;

  // force indicates whether to skip graceful shutdown (SIGKILL instead of SIGTERM)
  bool force = 3;
}

// StopComponentResponse returns the result of stopping a component.
message StopComponentResponse {
  // success indicates if the component was stopped successfully
  bool success = 1;

  // stopped_count is the number of instances successfully stopped
  int32 stopped_count = 2;

  // total_count is the total number of instances that were running
  int32 total_count = 3;

  // message provides additional context or error information
  string message = 4;
}

// OperationResult represents the unified result of a long-running operation (attack or mission).
// This provides typed metrics instead of JSON-encoded strings.
message OperationResult {
  // status of the operation ("success", "failed", "timeout", "cancelled")
  string status = 1;

  // duration_ms is the total duration in milliseconds
  int64 duration_ms = 2;

  // started_at is the Unix timestamp (milliseconds) when the operation started
  int64 started_at = 3;

  // completed_at is the Unix timestamp (milliseconds) when the operation completed
  int64 completed_at = 4;

  // turns_used is the number of agent turns/iterations executed
  int32 turns_used = 5;

  // tokens_used is the total LLM tokens consumed
  int64 tokens_used = 6;

  // nodes_executed is the number of workflow nodes that ran successfully
  int32 nodes_executed = 7;

  // nodes_failed is the number of workflow nodes that failed
  int32 nodes_failed = 8;

  // findings_count is the total number of findings discovered
  int32 findings_count = 9;

  // critical_count is the number of critical severity findings
  int32 critical_count = 10;

  // high_count is the number of high severity findings
  int32 high_count = 11;

  // medium_count is the number of medium severity findings
  int32 medium_count = 12;

  // low_count is the number of low severity findings
  int32 low_count = 13;

  // error_message contains the error message if status == "failed"
  string error_message = 14;

  // error_code contains a machine-readable error code if status == "failed"
  string error_code = 15;
}

// PauseMissionRequest requests pausing a running mission.
message PauseMissionRequest {
  // mission_id is the unique identifier of the mission to pause
  string mission_id = 1;

  // force indicates whether to pause immediately without waiting for a clean checkpoint boundary
  // If false (default), waits for the current node to complete before pausing
  bool force = 2;
}

// PauseMissionResponse confirms the mission pause request.
message PauseMissionResponse {
  // success indicates if the pause request was accepted
  bool success = 1;

  // checkpoint_id is the ID of the checkpoint created during pause
  string checkpoint_id = 2;

  // message provides additional context about the pause operation
  string message = 3;
}

// ResumeMissionRequest requests resuming a paused mission.
message ResumeMissionRequest {
  // mission_id is the unique identifier of the mission to resume
  string mission_id = 1;

  // checkpoint_id optionally specifies a specific checkpoint to resume from
  // If empty, resumes from the latest checkpoint
  string checkpoint_id = 2;
}

// GetMissionHistoryRequest queries mission execution history by name.
message GetMissionHistoryRequest {
  // name is the mission name to query history for
  string name = 1;

  // limit restricts the number of results (default: 100)
  int32 limit = 2;

  // offset is the pagination offset (default: 0)
  int32 offset = 3;
}

// GetMissionHistoryResponse returns mission execution history.
message GetMissionHistoryResponse {
  // runs contains all mission runs for the requested name
  repeated MissionRun runs = 1;

  // total is the total count of runs (for pagination)
  int32 total = 2;
}

// MissionRun represents a single execution instance of a mission.
message MissionRun {
  // mission_id is the unique identifier for this run
  string mission_id = 1;

  // run_number is the sequential run number for this mission name
  int32 run_number = 2;

  // status is the final status of this run (running, completed, failed, cancelled, paused)
  string status = 3;

  // created_at is when this run was created (Unix timestamp)
  int64 created_at = 4;

  // completed_at is when this run completed (Unix timestamp, 0 if not completed)
  int64 completed_at = 5;

  // findings_count is the number of findings discovered in this run
  int32 findings_count = 6;

  // previous_run_id is the ID of the previous run (if any)
  string previous_run_id = 7;
}

// GetMissionCheckpointsRequest queries checkpoints for a mission.
message GetMissionCheckpointsRequest {
  // mission_id is the unique identifier of the mission to query checkpoints for
  string mission_id = 1;
}

// GetMissionCheckpointsResponse returns all checkpoints for a mission.
message GetMissionCheckpointsResponse {
  // checkpoints contains all checkpoints for the requested mission
  repeated CheckpointInfo checkpoints = 1;
}

// CheckpointInfo provides metadata about a mission checkpoint.
message CheckpointInfo {
  // checkpoint_id is the unique identifier for this checkpoint
  string checkpoint_id = 1;

  // created_at is when this checkpoint was created (Unix timestamp)
  int64 created_at = 2;

  // completed_nodes is the number of nodes that had completed at checkpoint time
  int32 completed_nodes = 3;

  // total_nodes is the total number of nodes in the workflow
  int32 total_nodes = 4;

  // findings_count is the number of findings at checkpoint time
  int32 findings_count = 5;

  // version is the checkpoint format version
  int32 version = 6;
}

// ExecuteToolRequest executes a tool via the Tool Executor Service.
message ExecuteToolRequest {
  // name is the tool name to execute
  string name = 1;

  // input is the typed input parameters for the tool
  gibson.common.TypedMap input = 2;

  // timeout_ms is the execution timeout in milliseconds (0 = default 5 minutes)
  int64 timeout_ms = 3;

  // Reserved field numbers for removed fields
  reserved 4;
  reserved "input_json";
}

// ExecuteToolResponse returns the result of tool execution.
message ExecuteToolResponse {
  // success indicates if the tool executed successfully
  bool success = 1;

  // output is the typed output from the tool (if success)
  gibson.common.TypedValue output = 2;

  // error is the error message (if !success)
  string error = 3;

  // duration_ms is the actual execution duration in milliseconds
  int64 duration_ms = 4;

  // Reserved field numbers for removed fields
  reserved 5;
  reserved "output_json";
}

// GetAvailableToolsRequest queries available tools from the Tool Executor Service.
message GetAvailableToolsRequest {}

// GetAvailableToolsResponse returns all available tools with their capabilities.
message GetAvailableToolsResponse {
  // tools is the list of available tools with detailed information
  repeated AvailableToolInfo tools = 1;
}

// AvailableToolInfo describes a tool's capabilities and execution metrics.
// This is distinct from ToolInfo which represents registry information.
message AvailableToolInfo {
  // name is the tool name
  string name = 1;

  // version is the tool version
  string version = 2;

  // description is the tool description
  string description = 3;

  // tags are tool categorization tags
  repeated string tags = 4;

  // input_schema_json is the JSON-encoded JSON Schema for tool input
  string input_schema_json = 5;

  // output_schema_json is the JSON-encoded JSON Schema for tool output
  string output_schema_json = 6;

  // status is the tool readiness status ("ready", "schema-unknown", "error")
  string status = 7;

  // error_message is non-empty if status is "error"
  string error_message = 8;

  // metrics contains execution statistics for this tool
  ToolExecutionMetrics metrics = 9;

  // input_schema is the structured input schema with taxonomy support (new in v0.12.0)
  JSONSchemaNode input_schema = 10;

  // output_schema is the structured output schema with taxonomy support (new in v0.12.0)
  JSONSchemaNode output_schema = 11;

  // input_message_type is the fully-qualified proto message type for input (e.g., "gibson.tools.NmapRequest")
  string input_message_type = 12;

  // output_message_type is the fully-qualified proto message type for output (e.g., "gibson.tools.NmapResponse")
  string output_message_type = 13;
}

// ToolExecutionMetrics tracks execution statistics for a tool.
message ToolExecutionMetrics {
  // total_calls is the total number of executions
  int64 total_calls = 1;

  // success_calls is the number of successful executions
  int64 success_calls = 2;

  // failed_calls is the number of failed executions
  int64 failed_calls = 3;

  // avg_duration_ms is the average execution duration in milliseconds
  int64 avg_duration_ms = 4;

  // last_executed_at is the Unix timestamp in milliseconds of the last execution
  int64 last_executed_at = 5;
}

// JSONSchemaNode represents a JSON schema with optional taxonomy mapping.
// This mirrors sdk/schema.JSON for gRPC transport with taxonomy support.
message JSONSchemaNode {
  // type is the JSON schema type (string, integer, number, boolean, array, object)
  string type = 1;

  // description is the human-readable description of this schema node
  string description = 2;

  // properties maps property names to their schemas (for object types)
  map<string, JSONSchemaNode> properties = 3;

  // required lists required property names (for object types)
  repeated string required = 4;

  // items defines the schema for array elements (for array types)
  JSONSchemaNode items = 5;

  // enum_values lists allowed values (for enum constraints)
  repeated string enum_values = 6;

  // default_value is the JSON-encoded default value
  string default_value = 7;

  // minimum is the minimum numeric value constraint
  double minimum = 8;

  // maximum is the maximum numeric value constraint
  double maximum = 9;

  // min_length is the minimum string length constraint
  int32 min_length = 10;

  // max_length is the maximum string length constraint
  int32 max_length = 11;

  // pattern is the regex pattern constraint for strings
  string pattern = 12;

  // format is the string format hint (e.g., uri, email, date-time, uuid)
  string format = 13;

  // ref is the JSON schema $ref reference
  string ref = 14;

  // taxonomy defines how this schema node maps to a graph node (the key feature)
  TaxonomyMapping taxonomy = 15;
}

// TaxonomyMapping defines how tool output maps to graph nodes and relationships.
// It specifies the node type, identifying properties for deterministic ID generation,
// property mappings, and relationships to create when processing data.
message TaxonomyMapping {
  // node_type is the type of node to create in the graph (e.g., "host", "port", "vulnerability")
  string node_type = 1;

  // identifying_properties maps property names to JSONPath expressions for deterministic ID generation
  map<string, string> identifying_properties = 2;

  // properties maps source data fields to node properties
  repeated PropertyMapping properties = 3;

  // relationships defines edges to create to/from this node
  repeated RelationshipMapping relationships = 4;
}

// PropertyMapping defines how to map a source field to a target node property.
// It supports default values and transformation functions.
message PropertyMapping {
  // source is the field name in the source data
  string source = 1;

  // target is the property name in the target node
  string target = 2;

  // default_value is the JSON-encoded default value if source is missing or empty
  string default_value = 3;

  // transform is a transformation function to apply (e.g., "lowercase", "uppercase", "trim")
  string transform = 4;
}

// NodeReference identifies a node by type and property mappings.
// Use type="self" to reference the current node being mapped.
message NodeReference {
  // type is the node type (e.g., "host", "port") or "self" for current node
  string type = 1;

  // properties maps identifying property names to JSONPath expressions
  map<string, string> properties = 2;
}

// RelationshipMapping defines a relationship to create between nodes.
// It supports conditional relationships and property mappings on the edge itself.
message RelationshipMapping {
  // type is the relationship type (e.g., "HAS_PORT", "AFFECTS", "RUNS_ON")
  string type = 1;

  // from identifies the source node of the relationship (use type="self" for current node)
  NodeReference from = 2;

  // to identifies the target node of the relationship
  NodeReference to = 3;

  // condition is an optional condition for creating this relationship
  string condition = 4;

  // rel_properties are property mappings for the relationship edge
  repeated PropertyMapping rel_properties = 5;
}

// InstallComponentRequest requests installing a component from a Git repository.
message InstallComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // url is the Git repository URL to clone
  string url = 2;

  // branch is the Git branch to checkout (optional)
  string branch = 3;

  // tag is the Git tag to checkout (optional)
  string tag = 4;

  // force indicates whether to reinstall if already exists
  bool force = 5;

  // skip_build skips the build step after cloning
  bool skip_build = 6;

  // verbose enables detailed build output streaming
  bool verbose = 7;
}

// InstallComponentResponse returns the result of installing a component.
message InstallComponentResponse {
  // success indicates if the component was installed successfully
  bool success = 1;

  // name is the installed component name
  string name = 2;

  // version is the installed component version
  string version = 3;

  // repo_path is the local repository path
  string repo_path = 4;

  // bin_path is the path to the built binary (if built)
  string bin_path = 5;

  // build_output contains build stdout/stderr (if verbose)
  string build_output = 6;

  // duration_ms is the total install time in milliseconds
  int64 duration_ms = 7;

  // message provides additional context or error information
  string message = 8;
}

// InstallAllComponentRequest requests installing all components from a mono-repo.
message InstallAllComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // url is the Git repository URL to clone
  string url = 2;

  // branch is the Git branch to checkout (optional)
  string branch = 3;

  // tag is the Git tag to checkout (optional)
  string tag = 4;

  // force indicates whether to reinstall if already exists
  bool force = 5;

  // skip_build skips the build step after cloning
  bool skip_build = 6;

  // verbose enables detailed build output streaming
  bool verbose = 7;
}

// InstallAllComponentResponse returns the result of installing multiple components.
message InstallAllComponentResponse {
  // success indicates if the operation completed (even with partial failures)
  bool success = 1;

  // components_found is the total number of components discovered
  int32 components_found = 2;

  // successful_count is the number of successfully installed components
  int32 successful_count = 3;

  // skipped_count is the number of components skipped (already installed)
  int32 skipped_count = 4;

  // failed_count is the number of components that failed to install
  int32 failed_count = 5;

  // successful contains details of successfully installed components
  repeated InstallAllResultItem successful = 6;

  // skipped contains details of skipped components
  repeated InstallAllResultItem skipped = 7;

  // failed contains details of failed components
  repeated InstallAllFailedItem failed = 8;

  // duration_ms is the total installation time in milliseconds
  int64 duration_ms = 9;

  // message provides additional context or error information
  string message = 10;
}

// InstallAllResultItem represents a successful or skipped component installation.
message InstallAllResultItem {
  // name is the component name
  string name = 1;

  // version is the component version
  string version = 2;

  // path is the local repository path
  string path = 3;
}

// InstallAllFailedItem represents a failed component installation.
message InstallAllFailedItem {
  // name is the component name (if available)
  string name = 1;

  // path is the local path where the failure occurred
  string path = 2;

  // error is the error message
  string error = 3;
}

// UninstallComponentRequest requests removing a component.
message UninstallComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name to uninstall
  string name = 2;

  // force indicates whether to uninstall even if running
  bool force = 3;
}

// UninstallComponentResponse returns the result of uninstalling a component.
message UninstallComponentResponse {
  // success indicates if the component was uninstalled successfully
  bool success = 1;

  // message provides additional context or error information
  string message = 2;
}

// UpdateComponentRequest requests updating a component to the latest version.
message UpdateComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name to update
  string name = 2;

  // restart indicates whether to restart if running
  bool restart = 3;

  // skip_build skips the rebuild step after pulling
  bool skip_build = 4;

  // verbose enables detailed build output streaming
  bool verbose = 5;
}

// UpdateComponentResponse returns the result of updating a component.
message UpdateComponentResponse {
  // success indicates if the component was updated successfully
  bool success = 1;

  // updated indicates if there were actually changes (false if already latest)
  bool updated = 2;

  // old_version is the previous version
  string old_version = 3;

  // new_version is the new version after update
  string new_version = 4;

  // build_output contains build stdout/stderr (if verbose)
  string build_output = 5;

  // duration_ms is the total update time in milliseconds
  int64 duration_ms = 6;

  // message provides additional context or error information
  string message = 7;
}

// BuildComponentRequest requests rebuilding a component from source.
message BuildComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name to build
  string name = 2;
}

// BuildComponentResponse returns the result of building a component.
message BuildComponentResponse {
  // success indicates if the build was successful
  bool success = 1;

  // stdout contains the build standard output
  string stdout = 2;

  // stderr contains the build standard error
  string stderr = 3;

  // duration_ms is the build time in milliseconds
  int64 duration_ms = 4;

  // message provides additional context or error information
  string message = 5;
}

// ShowComponentRequest requests detailed information about a component.
message ShowComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name to show
  string name = 2;
}

// ShowComponentResponse returns detailed component information.
message ShowComponentResponse {
  // success indicates if the component was found
  bool success = 1;

  // name is the component name
  string name = 2;

  // version is the component version
  string version = 3;

  // kind is the component kind
  string kind = 4;

  // status is the component status (installed, running, stopped)
  string status = 5;

  // source is the Git repository URL
  string source = 6;

  // repo_path is the local repository path
  string repo_path = 7;

  // bin_path is the path to the binary
  string bin_path = 8;

  // port is the listening port (if running)
  int32 port = 9;

  // pid is the process ID (if running)
  int32 pid = 10;

  // created_at is when the component was installed (Unix timestamp)
  int64 created_at = 11;

  // updated_at is when the component was last updated (Unix timestamp)
  int64 updated_at = 12;

  // started_at is when the component was started (Unix timestamp, 0 if not running)
  int64 started_at = 13;

  // stopped_at is when the component was stopped (Unix timestamp, 0 if never stopped)
  int64 stopped_at = 14;

  // manifest_info contains manifest details (JSON-encoded)
  string manifest_info = 15;

  // message provides additional context or error information
  string message = 16;
}

// GetComponentLogsRequest requests log entries for a component.
message GetComponentLogsRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name to get logs for
  string name = 2;

  // follow indicates whether to stream logs continuously
  bool follow = 3;

  // lines is the number of lines to return (0 = all, default 50)
  int32 lines = 4;
}

// LogEntry represents a single log entry from a component.
message LogEntry {
  // timestamp is when the log entry was created (Unix timestamp)
  int64 timestamp = 1;

  // level is the log level (debug, info, warn, error)
  string level = 2;

  // message is the log message
  string message = 3;

  // fields contains additional structured log fields (typed map)
  gibson.common.TypedMap fields = 4;
}

// InstallMissionRequest requests installing a mission from a Git repository.
message InstallMissionRequest {
  // url is the Git repository URL to clone
  string url = 1;

  // branch is the Git branch to checkout (optional)
  string branch = 2;

  // tag is the Git tag to checkout (optional)
  string tag = 3;

  // force indicates whether to reinstall if already exists
  bool force = 4;

  // yes auto-confirms dependency installation prompts
  bool yes = 5;

  // timeout_ms is the installation timeout in milliseconds (0 = default 5 minutes)
  int64 timeout_ms = 6;
}

// InstallMissionResponse returns the result of installing a mission.
message InstallMissionResponse {
  // success indicates if the mission was installed successfully
  bool success = 1;

  // name is the installed mission name
  string name = 2;

  // version is the installed mission version
  string version = 3;

  // path is the local installation path
  string path = 4;

  // dependencies contains information about installed dependencies
  repeated InstalledDependency dependencies = 5;

  // duration_ms is the total install time in milliseconds
  int64 duration_ms = 6;

  // message provides additional context or error information
  string message = 7;
}

// InstalledDependency represents a dependency that was installed.
message InstalledDependency {
  // type is the dependency type (agent, tool, plugin)
  string type = 1;

  // name is the dependency name
  string name = 2;

  // already_installed indicates if it was already installed
  bool already_installed = 3;
}

// UninstallMissionRequest requests removing an installed mission.
message UninstallMissionRequest {
  // name is the mission name to uninstall
  string name = 1;

  // force indicates whether to skip confirmation
  bool force = 2;
}

// UninstallMissionResponse returns the result of uninstalling a mission.
message UninstallMissionResponse {
  // success indicates if the mission was uninstalled successfully
  bool success = 1;

  // message provides additional context or error information
  string message = 2;
}

// ListMissionDefinitionsRequest queries installed mission definitions.
message ListMissionDefinitionsRequest {
  // limit restricts the number of results (0 = all)
  int32 limit = 1;

  // offset is the pagination offset
  int32 offset = 2;
}

// ListMissionDefinitionsResponse returns installed mission definitions.
message ListMissionDefinitionsResponse {
  // missions is the list of installed mission definitions
  repeated MissionDefinitionInfo missions = 1;

  // total is the total count of mission definitions (for pagination)
  int32 total = 2;
}

// MissionDefinitionInfo describes an installed mission definition.
message MissionDefinitionInfo {
  // name is the mission name
  string name = 1;

  // version is the mission version
  string version = 2;

  // description is the mission description
  string description = 3;

  // source is the Git repository URL
  string source = 4;

  // installed_at is when the mission was installed (Unix timestamp)
  int64 installed_at = 5;

  // updated_at is when the mission was last updated (Unix timestamp)
  int64 updated_at = 6;

  // node_count is the number of nodes in the mission
  int32 node_count = 7;
}

// UpdateMissionRequest requests updating a mission to the latest version.
message UpdateMissionRequest {
  // name is the mission name to update
  string name = 1;

  // timeout_ms is the update timeout in milliseconds (0 = default 5 minutes)
  int64 timeout_ms = 2;
}

// UpdateMissionResponse returns the result of updating a mission.
message UpdateMissionResponse {
  // success indicates if the mission was updated successfully
  bool success = 1;

  // updated indicates if there were actually changes (false if already latest)
  bool updated = 2;

  // old_version is the previous version
  string old_version = 3;

  // new_version is the new version after update
  string new_version = 4;

  // duration_ms is the total update time in milliseconds
  int64 duration_ms = 5;

  // message provides additional context or error information
  string message = 6;
}

// ResolveMissionDependenciesRequest requests dependency resolution for a mission.
message ResolveMissionDependenciesRequest {
  // workflow_path is the path to the mission workflow YAML file
  string workflow_path = 1;
}

// ResolveMissionDependenciesResponse returns the complete dependency tree.
message ResolveMissionDependenciesResponse {
  // success indicates if resolution was successful
  bool success = 1;

  // tree is the complete resolved dependency tree
  DependencyTree tree = 2;

  // message provides additional context or error information
  string message = 3;
}

// ValidateMissionDependenciesRequest requests validation of mission dependencies.
message ValidateMissionDependenciesRequest {
  // workflow_path is the path to the mission workflow YAML file
  string workflow_path = 1;
}

// ValidateMissionDependenciesResponse returns validation results.
message ValidateMissionDependenciesResponse {
  // success indicates if validation check was performed (not if dependencies are valid)
  bool success = 1;

  // result contains the detailed validation results
  ValidationResult result = 2;

  // message provides additional context or error information
  string message = 3;
}

// EnsureDependenciesRunningRequest requests starting stopped dependencies.
message EnsureDependenciesRunningRequest {
  // workflow_path is the path to the mission workflow YAML file
  string workflow_path = 1;

  // timeout_ms is the timeout for starting all dependencies in milliseconds (0 = default 5 minutes)
  int64 timeout_ms = 2;
}

// EnsureDependenciesRunningResponse returns the result of starting dependencies.
message EnsureDependenciesRunningResponse {
  // success indicates if all dependencies were started successfully
  bool success = 1;

  // started_count is the number of components that were started
  int32 started_count = 2;

  // skipped_count is the number of components that were already running
  int32 skipped_count = 3;

  // message provides additional context or error information
  string message = 4;
}

// DependencyTree represents the complete resolved dependency graph.
message DependencyTree {
  // roots are the root nodes (direct mission dependencies)
  repeated DependencyNode roots = 1;

  // nodes maps component keys (kind:name) to dependency nodes
  map<string, DependencyNode> nodes = 2;

  // agents is a flattened list of all agent dependencies
  repeated DependencyNode agents = 3;

  // tools is a flattened list of all tool dependencies
  repeated DependencyNode tools = 4;

  // plugins is a flattened list of all plugin dependencies
  repeated DependencyNode plugins = 5;

  // resolved_at is when the tree was resolved (Unix timestamp)
  int64 resolved_at = 6;

  // mission_ref is the mission name or path that was resolved
  string mission_ref = 7;
}

// DependencyNode represents a single component in the dependency tree.
message DependencyNode {
  // kind is the component kind (agent, tool, plugin)
  string kind = 1;

  // name is the component name
  string name = 2;

  // version is the required version (may be a constraint like ">=2.0")
  string version = 3;

  // required_by lists component keys that depend on this component
  repeated string required_by = 4;

  // depends_on lists component keys this component depends on
  repeated string depends_on = 5;

  // source indicates where this dependency was discovered
  DependencySource source = 6;

  // source_ref is a reference to the source (node ID, manifest path, etc.)
  string source_ref = 7;

  // installed indicates if the component is installed
  bool installed = 8;

  // running indicates if the component is currently running
  bool running = 9;

  // healthy indicates if the component is healthy (if running)
  bool healthy = 10;

  // actual_version is the installed version (may differ from required version)
  string actual_version = 11;
}

// DependencySource indicates where a dependency was discovered.
enum DependencySource {
  // SOURCE_UNKNOWN is the default unspecified source
  SOURCE_UNKNOWN = 0;

  // SOURCE_MISSION_EXPLICIT means the dependency is explicitly listed in mission dependencies
  SOURCE_MISSION_EXPLICIT = 1;

  // SOURCE_MISSION_NODE means the dependency is referenced by a mission node
  SOURCE_MISSION_NODE = 2;

  // SOURCE_MANIFEST means the dependency is from a component's manifest dependencies
  SOURCE_MANIFEST = 3;
}

// ValidationResult contains the outcome of dependency validation.
message ValidationResult {
  // valid indicates if all dependencies are satisfied and running
  bool valid = 1;

  // summary is a human-readable validation summary
  string summary = 2;

  // total_components is the total number of components in the tree
  int32 total_components = 3;

  // installed_count is the number of installed components
  int32 installed_count = 4;

  // running_count is the number of running components
  int32 running_count = 5;

  // healthy_count is the number of healthy components
  int32 healthy_count = 6;

  // not_installed lists components that are not installed
  repeated DependencyNode not_installed = 7;

  // not_running lists components that are installed but not running
  repeated DependencyNode not_running = 8;

  // unhealthy lists components that are running but unhealthy
  repeated DependencyNode unhealthy = 9;

  // version_mismatches lists components with version constraint violations
  repeated VersionMismatchInfo version_mismatches = 10;

  // validated_at is when validation was performed (Unix timestamp)
  int64 validated_at = 11;

  // duration_ms is how long validation took in milliseconds
  int64 duration_ms = 12;
}

// VersionMismatchInfo describes a version constraint violation.
message VersionMismatchInfo {
  // node is the component with the version mismatch
  DependencyNode node = 1;

  // required_version is the version constraint that was required
  string required_version = 2;

  // actual_version is the version that is actually installed
  string actual_version = 3;
}

// Mission represents a complete mission execution instance with full state.
message Mission {
  // id is the unique mission identifier
  string id = 1;

  // name is the human-readable mission name
  string name = 2;

  // status is the current mission status
  MissionStatus status = 3;

  // target_id is the target identifier
  string target_id = 4;

  // workflow_id is the workflow definition identifier
  string workflow_id = 5;

  // constraints defines execution constraints
  MissionConstraints constraints = 6;

  // metrics contains current execution metrics
  MissionMetrics metrics = 7;

  // checkpoint is the latest checkpoint (if any)
  MissionCheckpoint checkpoint = 8;

  // run_number is the sequential run number for this mission name
  int32 run_number = 9;

  // created_at is when the mission was created (Unix timestamp in milliseconds)
  int64 created_at = 10;

  // updated_at is when the mission was last updated (Unix timestamp in milliseconds)
  int64 updated_at = 11;

  // started_at is when the mission execution started (Unix timestamp in milliseconds)
  int64 started_at = 12;

  // completed_at is when the mission execution completed (Unix timestamp in milliseconds, 0 if not completed)
  int64 completed_at = 13;
}

// MissionConstraints defines execution constraints for a mission.
message MissionConstraints {
  // max_duration_seconds is the maximum mission duration in seconds (0 = no limit)
  int32 max_duration_seconds = 1;

  // max_findings is the maximum number of findings to collect (0 = no limit)
  int32 max_findings = 2;

  // max_tokens is the maximum LLM tokens to consume (0 = no limit)
  int32 max_tokens = 3;

  // max_turns_per_agent is the maximum turns per agent (0 = no limit)
  int32 max_turns_per_agent = 4;

  // allowed_techniques is the list of allowed MITRE techniques (empty = all allowed)
  repeated string allowed_techniques = 5;

  // blocked_techniques is the list of blocked MITRE techniques (empty = none blocked)
  repeated string blocked_techniques = 6;
}

// MissionMetrics contains execution metrics for a mission.
message MissionMetrics {
  // turns_used is the number of agent turns/iterations executed
  int32 turns_used = 1;

  // nodes_executed is the number of workflow nodes that ran successfully
  int32 nodes_executed = 2;

  // nodes_failed is the number of workflow nodes that failed
  int32 nodes_failed = 3;

  // findings_count is the total number of findings discovered
  int32 findings_count = 4;

  // critical_count is the number of critical severity findings
  int32 critical_count = 5;

  // high_count is the number of high severity findings
  int32 high_count = 6;

  // medium_count is the number of medium severity findings
  int32 medium_count = 7;

  // low_count is the number of low severity findings
  int32 low_count = 8;

  // tokens_used is the total LLM tokens consumed
  int64 tokens_used = 9;
}

// MissionCheckpoint represents a saved checkpoint state for pause/resume.
message MissionCheckpoint {
  // id is the unique checkpoint identifier
  string id = 1;

  // version is the checkpoint format version
  int32 version = 2;

  // completed_nodes is the number of nodes that had completed at checkpoint time
  int32 completed_nodes = 3;

  // total_nodes is the total number of nodes in the workflow
  int32 total_nodes = 4;

  // created_at is when this checkpoint was created (Unix timestamp in milliseconds)
  int64 created_at = 5;

  // state_data is the serialized checkpoint state (opaque blob)
  bytes state_data = 6;
}

// MissionDefinition represents an installed mission workflow definition.
message MissionDefinition {
  // name is the mission name
  string name = 1;

  // version is the mission version
  string version = 2;

  // description is the mission description
  string description = 3;

  // source is the Git repository URL
  string source = 4;

  // node_count is the number of nodes in the mission workflow
  int32 node_count = 5;

  // installed_at is when the mission was installed (Unix timestamp in milliseconds)
  int64 installed_at = 6;

  // updated_at is when the mission was last updated (Unix timestamp in milliseconds)
  int64 updated_at = 7;
}
