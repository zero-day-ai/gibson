syntax = "proto3";

package gibson.daemon.v1;

option go_package = "github.com/zero-day-ai/gibson/internal/daemon/api;api";

// DaemonService provides the gRPC API for Gibson daemon client communication.
//
// This service exposes all daemon functionality including mission execution,
// agent management, attack operations, and real-time event streaming for the TUI.
service DaemonService {
  // Connect establishes a client connection to the daemon.
  // Returns connection metadata and daemon version info.
  rpc Connect(ConnectRequest) returns (ConnectResponse);

  // Ping checks if the daemon is responsive.
  // Used for health checks and connection validation.
  rpc Ping(PingRequest) returns (PingResponse);

  // Status returns the current daemon status including uptime,
  // service endpoints, and component counts.
  rpc Status(StatusRequest) returns (StatusResponse);

  // RunMission starts a mission and streams execution events.
  // The stream remains open until the mission completes or is stopped.
  rpc RunMission(RunMissionRequest) returns (stream MissionEvent);

  // StopMission gracefully stops a running mission.
  rpc StopMission(StopMissionRequest) returns (StopMissionResponse);

  // ListMissions returns all missions (past and active).
  rpc ListMissions(ListMissionsRequest) returns (ListMissionsResponse);

  // ListAgents returns all registered agents from the etcd registry.
  rpc ListAgents(ListAgentsRequest) returns (ListAgentsResponse);

  // GetAgentStatus returns the current status of a specific agent.
  rpc GetAgentStatus(GetAgentStatusRequest) returns (AgentStatusResponse);

  // ListTools returns all registered tools from the etcd registry.
  rpc ListTools(ListToolsRequest) returns (ListToolsResponse);

  // ListPlugins returns all registered plugins from the etcd registry.
  rpc ListPlugins(ListPluginsRequest) returns (ListPluginsResponse);

  // QueryPlugin executes a method on a plugin and returns the result.
  // The plugin must be registered in the etcd registry.
  rpc QueryPlugin(QueryPluginRequest) returns (QueryPluginResponse);

  // RunAttack executes an attack and streams progress events.
  // The stream remains open until the attack completes or is stopped.
  rpc RunAttack(RunAttackRequest) returns (stream AttackEvent);

  // Subscribe establishes an event stream for TUI real-time updates.
  // Streams mission events, agent events, finding events, etc.
  rpc Subscribe(SubscribeRequest) returns (stream Event);

  // StartComponent starts a component (agent, tool, or plugin) by kind and name.
  // The component must be installed in the local database.
  rpc StartComponent(StartComponentRequest) returns (StartComponentResponse);

  // StopComponent stops a running component (agent, tool, or plugin) by kind and name.
  // If force is true, sends SIGKILL immediately instead of graceful SIGTERM.
  rpc StopComponent(StopComponentRequest) returns (StopComponentResponse);

  // PauseMission pauses a running mission at the next clean checkpoint boundary.
  // If force is true, pauses immediately without waiting for a clean boundary.
  rpc PauseMission(PauseMissionRequest) returns (PauseMissionResponse);

  // ResumeMission resumes a paused mission from its last checkpoint.
  // Returns a stream of mission events as execution continues.
  rpc ResumeMission(ResumeMissionRequest) returns (stream MissionEvent);

  // GetMissionHistory returns all runs for a mission name, showing the
  // complete history of mission executions with the same workflow name.
  rpc GetMissionHistory(GetMissionHistoryRequest) returns (GetMissionHistoryResponse);

  // GetMissionCheckpoints returns all checkpoints for a specific mission,
  // providing visibility into saved execution states for resume capability.
  rpc GetMissionCheckpoints(GetMissionCheckpointsRequest) returns (GetMissionCheckpointsResponse);

  // ExecuteTool executes a tool via the Tool Executor Service.
  // Routes tool execution through the centralized tool executor which handles
  // schema validation, timeout management, and execution tracking.
  rpc ExecuteTool(ExecuteToolRequest) returns (ExecuteToolResponse);

  // GetAvailableTools returns all available tools from the Tool Executor Service.
  // Provides detailed information about each tool including schemas, capabilities,
  // and execution metrics.
  rpc GetAvailableTools(GetAvailableToolsRequest) returns (GetAvailableToolsResponse);
}

// ConnectRequest initiates a client connection to the daemon.
message ConnectRequest {
  // client_version is the version of the Gibson CLI client
  string client_version = 1;

  // client_id is an optional unique identifier for this client
  string client_id = 2;
}

// ConnectResponse returns connection metadata.
message ConnectResponse {
  // daemon_version is the version of the running daemon
  string daemon_version = 1;

  // session_id is a unique identifier for this client session
  string session_id = 2;

  // grpc_address is the address the daemon is listening on
  string grpc_address = 3;
}

// PingRequest is an empty health check request.
message PingRequest {}

// PingResponse confirms the daemon is responsive.
message PingResponse {
  // timestamp is the server time when the ping was received
  int64 timestamp = 1;
}

// StatusRequest queries daemon status.
message StatusRequest {}

// StatusResponse returns complete daemon status information.
message StatusResponse {
  // running indicates if the daemon is running (always true if responding)
  bool running = 1;

  // pid is the process ID of the daemon
  int32 pid = 2;

  // start_time is when the daemon started (Unix timestamp)
  int64 start_time = 3;

  // uptime is the human-readable uptime string
  string uptime = 4;

  // grpc_address is the gRPC server address
  string grpc_address = 5;

  // registry_type is the type of registry (embedded, external)
  string registry_type = 6;

  // registry_addr is the registry endpoint address
  string registry_addr = 7;

  // callback_addr is the callback server address
  string callback_addr = 8;

  // agent_count is the number of registered agents
  int32 agent_count = 9;

  // mission_count is the total number of missions
  int32 mission_count = 10;

  // active_mission_count is the number of currently running missions
  int32 active_mission_count = 11;
}

// RunMissionRequest starts a mission execution.
message RunMissionRequest {
  // workflow_path is the path to the mission workflow YAML file
  string workflow_path = 1;

  // mission_id is an optional custom mission identifier
  string mission_id = 2;

  // variables contains workflow variables to override
  map<string, string> variables = 3;

  // memory_continuity defines how agent memory is shared across mission runs
  // Valid values: "isolated" (default), "inherit", "shared"
  string memory_continuity = 4;
}

// MissionEvent represents a mission execution event.
message MissionEvent {
  // event_type identifies the type of event
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // mission_id is the unique mission identifier
  string mission_id = 3;

  // node_id is the workflow node ID (if applicable)
  string node_id = 4;

  // message is a human-readable event message
  string message = 5;

  // data contains event-specific data (JSON-encoded)
  string data = 6;

  // error contains error information if the event represents an error
  string error = 7;

  // result contains typed operation metrics (for mission.completed events)
  OperationResult result = 8;
}

// StopMissionRequest requests mission termination.
message StopMissionRequest {
  // mission_id is the identifier of the mission to stop
  string mission_id = 1;

  // force indicates whether to force-kill the mission (default: graceful)
  bool force = 2;
}

// StopMissionResponse confirms mission stop request.
message StopMissionResponse {
  // success indicates if the stop request was accepted
  bool success = 1;

  // message provides additional context
  string message = 2;
}

// ListMissionsRequest queries mission list.
message ListMissionsRequest {
  // active_only filters to only running missions
  bool active_only = 1;

  // limit restricts the number of results
  int32 limit = 2;

  // offset is the pagination offset
  int32 offset = 3;

  // status_filter filters missions by status (running, completed, failed, cancelled)
  string status_filter = 4;

  // name_pattern filters missions by name using glob pattern matching
  string name_pattern = 5;
}

// ListMissionsResponse returns mission list.
message ListMissionsResponse {
  // missions is the list of missions
  repeated MissionInfo missions = 1;

  // total is the total count of missions (for pagination)
  int32 total = 2;
}

// MissionInfo describes a mission.
message MissionInfo {
  // id is the unique mission identifier
  string id = 1;

  // workflow_path is the path to the workflow file
  string workflow_path = 2;

  // status is the mission status (running, completed, failed)
  string status = 3;

  // start_time is when the mission started (Unix timestamp)
  int64 start_time = 4;

  // end_time is when the mission ended (Unix timestamp, 0 if running)
  int64 end_time = 5;

  // finding_count is the number of findings discovered
  int32 finding_count = 6;
}

// ListAgentsRequest queries agent registry.
message ListAgentsRequest {
  // kind filters by component kind (empty = all agents)
  string kind = 1;
}

// ListAgentsResponse returns registered agents.
message ListAgentsResponse {
  // agents is the list of registered agents
  repeated AgentInfo agents = 1;
}

// AgentInfo describes a registered agent.
message AgentInfo {
  // id is the unique agent identifier
  string id = 1;

  // name is the agent name
  string name = 2;

  // kind is the component kind (always "agent")
  string kind = 3;

  // version is the agent version
  string version = 4;

  // endpoint is the gRPC endpoint for the agent
  string endpoint = 5;

  // capabilities lists agent capabilities
  repeated string capabilities = 6;

  // health is the agent health status (healthy, unhealthy)
  string health = 7;

  // last_seen is when the agent was last seen (Unix timestamp)
  int64 last_seen = 8;
}

// GetAgentStatusRequest queries a specific agent.
message GetAgentStatusRequest {
  // agent_id is the unique agent identifier
  string agent_id = 1;
}

// AgentStatusResponse returns agent status.
message AgentStatusResponse {
  // agent is the agent information
  AgentInfo agent = 1;

  // active indicates if the agent is currently executing a task
  bool active = 2;

  // current_task describes the active task (if any)
  string current_task = 3;

  // task_start_time is when the current task started (Unix timestamp)
  int64 task_start_time = 4;
}

// ListToolsRequest queries tool registry.
message ListToolsRequest {}

// ListToolsResponse returns registered tools.
message ListToolsResponse {
  // tools is the list of registered tools
  repeated ToolInfo tools = 1;
}

// ToolInfo describes a registered tool.
message ToolInfo {
  // id is the unique tool identifier
  string id = 1;

  // name is the tool name
  string name = 2;

  // version is the tool version
  string version = 3;

  // endpoint is the gRPC endpoint for the tool
  string endpoint = 4;

  // description is the tool description
  string description = 5;

  // health is the tool health status (healthy, unhealthy)
  string health = 6;

  // last_seen is when the tool was last seen (Unix timestamp)
  int64 last_seen = 7;
}

// ListPluginsRequest queries plugin registry.
message ListPluginsRequest {}

// ListPluginsResponse returns registered plugins.
message ListPluginsResponse {
  // plugins is the list of registered plugins
  repeated PluginInfo plugins = 1;
}

// PluginInfo describes a registered plugin.
message PluginInfo {
  // id is the unique plugin identifier
  string id = 1;

  // name is the plugin name
  string name = 2;

  // version is the plugin version
  string version = 3;

  // endpoint is the gRPC endpoint for the plugin
  string endpoint = 4;

  // description is the plugin description
  string description = 5;

  // health is the plugin health status (healthy, unhealthy)
  string health = 6;

  // last_seen is when the plugin was last seen (Unix timestamp)
  int64 last_seen = 7;
}

// QueryPluginRequest executes a method on a plugin.
message QueryPluginRequest {
  // name is the plugin name to query
  string name = 1;

  // method is the method name to execute
  string method = 2;

  // params_json is the JSON-encoded parameters for the method
  string params_json = 3;

  // timeout_ms is the optional timeout in milliseconds (0 = default)
  int64 timeout_ms = 4;
}

// QueryPluginResponse returns the result of a plugin query.
message QueryPluginResponse {
  // result_json is the JSON-encoded result from the plugin method
  string result_json = 1;

  // error is set if the query failed
  string error = 2;

  // duration_ms is how long the query took in milliseconds
  int64 duration_ms = 3;
}

// RunAttackRequest executes an attack.
message RunAttackRequest {
  // target is the target URL or identifier
  string target = 1;

  // attack_type is the type of attack to execute
  string attack_type = 2;

  // agent_id is the agent to use (optional, auto-select if empty)
  string agent_id = 3;

  // payload_filter filters which payloads to use
  string payload_filter = 4;

  // options contains attack-specific options
  map<string, string> options = 5;

  // target_name is the name of a stored target to look up from the database
  string target_name = 6;
}

// AttackEvent represents an attack execution event.
message AttackEvent {
  // event_type identifies the type of event
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // attack_id is the unique attack identifier
  string attack_id = 3;

  // message is a human-readable event message
  string message = 4;

  // data contains event-specific data (JSON-encoded)
  string data = 5;

  // error contains error information if the event represents an error
  string error = 6;

  // finding describes a discovered finding (if applicable)
  FindingInfo finding = 7;

  // result contains typed operation metrics (for attack.completed events)
  OperationResult result = 8;
}

// FindingInfo describes a discovered vulnerability.
message FindingInfo {
  // id is the unique finding identifier
  string id = 1;

  // title is the finding title
  string title = 2;

  // severity is the severity level (info, low, medium, high, critical)
  string severity = 3;

  // category is the finding category
  string category = 4;

  // description is the detailed finding description
  string description = 5;

  // technique is the MITRE ATT&CK or ATLAS technique ID
  string technique = 6;

  // evidence contains supporting evidence
  string evidence = 7;

  // timestamp is when the finding was discovered (Unix timestamp)
  int64 timestamp = 8;
}

// SubscribeRequest establishes an event stream.
message SubscribeRequest {
  // event_types filters which event types to receive (empty = all)
  repeated string event_types = 1;

  // mission_id filters to a specific mission (empty = all)
  string mission_id = 2;
}

// Event represents a generic daemon event.
message Event {
  // event_type identifies the type of event
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // source is the event source (mission, agent, daemon, etc.)
  string source = 3;

  // data contains event-specific data (JSON-encoded)
  string data = 4;

  // Specific event types (only one will be set)
  oneof event {
    MissionEvent mission_event = 5;
    AttackEvent attack_event = 6;
    AgentEvent agent_event = 7;
    FindingEvent finding_event = 8;
  }
}

// AgentEvent represents an agent lifecycle event.
message AgentEvent {
  // event_type identifies the agent event type (registered, unregistered, health_change)
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // agent_id is the agent identifier
  string agent_id = 3;

  // agent_name is the agent name
  string agent_name = 4;

  // message is a human-readable message
  string message = 5;

  // data contains event-specific data (JSON-encoded)
  string data = 6;
}

// FindingEvent represents a finding discovery event.
message FindingEvent {
  // event_type identifies the finding event type (discovered, updated)
  string event_type = 1;

  // timestamp is when the event occurred (Unix timestamp)
  int64 timestamp = 2;

  // finding is the finding information
  FindingInfo finding = 3;

  // mission_id is the mission that discovered the finding
  string mission_id = 4;
}

// StartComponentRequest requests starting a component.
message StartComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name
  string name = 2;
}

// StartComponentResponse returns the result of starting a component.
message StartComponentResponse {
  // success indicates if the component was started successfully
  bool success = 1;

  // pid is the process ID of the started component
  int32 pid = 2;

  // port is the port the component is listening on
  int32 port = 3;

  // message provides additional context or error information
  string message = 4;

  // log_path is the path to the component's log file
  string log_path = 5;
}

// StopComponentRequest requests stopping a component.
message StopComponentRequest {
  // kind is the component kind ("agent", "tool", "plugin")
  string kind = 1;

  // name is the component name
  string name = 2;

  // force indicates whether to skip graceful shutdown (SIGKILL instead of SIGTERM)
  bool force = 3;
}

// StopComponentResponse returns the result of stopping a component.
message StopComponentResponse {
  // success indicates if the component was stopped successfully
  bool success = 1;

  // stopped_count is the number of instances successfully stopped
  int32 stopped_count = 2;

  // total_count is the total number of instances that were running
  int32 total_count = 3;

  // message provides additional context or error information
  string message = 4;
}

// OperationResult represents the unified result of a long-running operation (attack or mission).
// This provides typed metrics instead of JSON-encoded strings.
message OperationResult {
  // status of the operation ("success", "failed", "timeout", "cancelled")
  string status = 1;

  // duration_ms is the total duration in milliseconds
  int64 duration_ms = 2;

  // started_at is the Unix timestamp (milliseconds) when the operation started
  int64 started_at = 3;

  // completed_at is the Unix timestamp (milliseconds) when the operation completed
  int64 completed_at = 4;

  // turns_used is the number of agent turns/iterations executed
  int32 turns_used = 5;

  // tokens_used is the total LLM tokens consumed
  int64 tokens_used = 6;

  // nodes_executed is the number of workflow nodes that ran successfully
  int32 nodes_executed = 7;

  // nodes_failed is the number of workflow nodes that failed
  int32 nodes_failed = 8;

  // findings_count is the total number of findings discovered
  int32 findings_count = 9;

  // critical_count is the number of critical severity findings
  int32 critical_count = 10;

  // high_count is the number of high severity findings
  int32 high_count = 11;

  // medium_count is the number of medium severity findings
  int32 medium_count = 12;

  // low_count is the number of low severity findings
  int32 low_count = 13;

  // error_message contains the error message if status == "failed"
  string error_message = 14;

  // error_code contains a machine-readable error code if status == "failed"
  string error_code = 15;
}

// PauseMissionRequest requests pausing a running mission.
message PauseMissionRequest {
  // mission_id is the unique identifier of the mission to pause
  string mission_id = 1;

  // force indicates whether to pause immediately without waiting for a clean checkpoint boundary
  // If false (default), waits for the current node to complete before pausing
  bool force = 2;
}

// PauseMissionResponse confirms the mission pause request.
message PauseMissionResponse {
  // success indicates if the pause request was accepted
  bool success = 1;

  // checkpoint_id is the ID of the checkpoint created during pause
  string checkpoint_id = 2;

  // message provides additional context about the pause operation
  string message = 3;
}

// ResumeMissionRequest requests resuming a paused mission.
message ResumeMissionRequest {
  // mission_id is the unique identifier of the mission to resume
  string mission_id = 1;

  // checkpoint_id optionally specifies a specific checkpoint to resume from
  // If empty, resumes from the latest checkpoint
  string checkpoint_id = 2;
}

// GetMissionHistoryRequest queries mission execution history by name.
message GetMissionHistoryRequest {
  // name is the mission name to query history for
  string name = 1;

  // limit restricts the number of results (default: 100)
  int32 limit = 2;

  // offset is the pagination offset (default: 0)
  int32 offset = 3;
}

// GetMissionHistoryResponse returns mission execution history.
message GetMissionHistoryResponse {
  // runs contains all mission runs for the requested name
  repeated MissionRun runs = 1;

  // total is the total count of runs (for pagination)
  int32 total = 2;
}

// MissionRun represents a single execution instance of a mission.
message MissionRun {
  // mission_id is the unique identifier for this run
  string mission_id = 1;

  // run_number is the sequential run number for this mission name
  int32 run_number = 2;

  // status is the final status of this run (running, completed, failed, cancelled, paused)
  string status = 3;

  // created_at is when this run was created (Unix timestamp)
  int64 created_at = 4;

  // completed_at is when this run completed (Unix timestamp, 0 if not completed)
  int64 completed_at = 5;

  // findings_count is the number of findings discovered in this run
  int32 findings_count = 6;

  // previous_run_id is the ID of the previous run (if any)
  string previous_run_id = 7;
}

// GetMissionCheckpointsRequest queries checkpoints for a mission.
message GetMissionCheckpointsRequest {
  // mission_id is the unique identifier of the mission to query checkpoints for
  string mission_id = 1;
}

// GetMissionCheckpointsResponse returns all checkpoints for a mission.
message GetMissionCheckpointsResponse {
  // checkpoints contains all checkpoints for the requested mission
  repeated CheckpointInfo checkpoints = 1;
}

// CheckpointInfo provides metadata about a mission checkpoint.
message CheckpointInfo {
  // checkpoint_id is the unique identifier for this checkpoint
  string checkpoint_id = 1;

  // created_at is when this checkpoint was created (Unix timestamp)
  int64 created_at = 2;

  // completed_nodes is the number of nodes that had completed at checkpoint time
  int32 completed_nodes = 3;

  // total_nodes is the total number of nodes in the workflow
  int32 total_nodes = 4;

  // findings_count is the number of findings at checkpoint time
  int32 findings_count = 5;

  // version is the checkpoint format version
  int32 version = 6;
}

// ExecuteToolRequest executes a tool via the Tool Executor Service.
message ExecuteToolRequest {
  // name is the tool name to execute
  string name = 1;

  // input_json is the JSON-encoded input parameters for the tool
  string input_json = 2;

  // timeout_ms is the execution timeout in milliseconds (0 = default 5 minutes)
  int64 timeout_ms = 3;
}

// ExecuteToolResponse returns the result of tool execution.
message ExecuteToolResponse {
  // success indicates if the tool executed successfully
  bool success = 1;

  // output_json is the JSON-encoded output from the tool (if success)
  string output_json = 2;

  // error is the error message (if !success)
  string error = 3;

  // duration_ms is the actual execution duration in milliseconds
  int64 duration_ms = 4;
}

// GetAvailableToolsRequest queries available tools from the Tool Executor Service.
message GetAvailableToolsRequest {}

// GetAvailableToolsResponse returns all available tools with their capabilities.
message GetAvailableToolsResponse {
  // tools is the list of available tools with detailed information
  repeated AvailableToolInfo tools = 1;
}

// AvailableToolInfo describes a tool's capabilities and execution metrics.
// This is distinct from ToolInfo which represents registry information.
message AvailableToolInfo {
  // name is the tool name
  string name = 1;

  // version is the tool version
  string version = 2;

  // description is the tool description
  string description = 3;

  // tags are tool categorization tags
  repeated string tags = 4;

  // input_schema_json is the JSON-encoded JSON Schema for tool input
  string input_schema_json = 5;

  // output_schema_json is the JSON-encoded JSON Schema for tool output
  string output_schema_json = 6;

  // status is the tool readiness status ("ready", "schema-unknown", "error")
  string status = 7;

  // error_message is non-empty if status is "error"
  string error_message = 8;

  // metrics contains execution statistics for this tool
  ToolExecutionMetrics metrics = 9;

  // input_schema is the structured input schema with taxonomy support (new in v0.12.0)
  JSONSchemaNode input_schema = 10;

  // output_schema is the structured output schema with taxonomy support (new in v0.12.0)
  JSONSchemaNode output_schema = 11;
}

// ToolExecutionMetrics tracks execution statistics for a tool.
message ToolExecutionMetrics {
  // total_calls is the total number of executions
  int64 total_calls = 1;

  // success_calls is the number of successful executions
  int64 success_calls = 2;

  // failed_calls is the number of failed executions
  int64 failed_calls = 3;

  // avg_duration_ms is the average execution duration in milliseconds
  int64 avg_duration_ms = 4;

  // last_executed_at is the Unix timestamp in milliseconds of the last execution
  int64 last_executed_at = 5;
}

// JSONSchemaNode represents a JSON schema with optional taxonomy mapping.
// This mirrors sdk/schema.JSON for gRPC transport with taxonomy support.
message JSONSchemaNode {
  // type is the JSON schema type (string, integer, number, boolean, array, object)
  string type = 1;

  // description is the human-readable description of this schema node
  string description = 2;

  // properties maps property names to their schemas (for object types)
  map<string, JSONSchemaNode> properties = 3;

  // required lists required property names (for object types)
  repeated string required = 4;

  // items defines the schema for array elements (for array types)
  JSONSchemaNode items = 5;

  // enum_values lists allowed values (for enum constraints)
  repeated string enum_values = 6;

  // default_value is the JSON-encoded default value
  string default_value = 7;

  // minimum is the minimum numeric value constraint
  double minimum = 8;

  // maximum is the maximum numeric value constraint
  double maximum = 9;

  // min_length is the minimum string length constraint
  int32 min_length = 10;

  // max_length is the maximum string length constraint
  int32 max_length = 11;

  // pattern is the regex pattern constraint for strings
  string pattern = 12;

  // format is the string format hint (e.g., uri, email, date-time, uuid)
  string format = 13;

  // ref is the JSON schema $ref reference
  string ref = 14;

  // taxonomy defines how this schema node maps to a graph node (the key feature)
  TaxonomyMapping taxonomy = 15;
}

// TaxonomyMapping defines how tool output maps to graph nodes and relationships.
// It specifies the node type, ID generation, property mappings, and relationships
// to create when processing data according to a taxonomy.
message TaxonomyMapping {
  // node_type is the type of node to create in the graph (e.g., "host", "port", "vulnerability")
  string node_type = 1;

  // id_template is a template string for generating node IDs (e.g., "host:{.ip}")
  string id_template = 2;

  // properties maps source data fields to node properties
  repeated PropertyMapping properties = 3;

  // relationships defines edges to create to/from this node
  repeated RelationshipMapping relationships = 4;
}

// PropertyMapping defines how to map a source field to a target node property.
// It supports default values and transformation functions.
message PropertyMapping {
  // source is the field name in the source data
  string source = 1;

  // target is the property name in the target node
  string target = 2;

  // default_value is the JSON-encoded default value if source is missing or empty
  string default_value = 3;

  // transform is a transformation function to apply (e.g., "lowercase", "uppercase", "trim")
  string transform = 4;
}

// RelationshipMapping defines a relationship to create between nodes.
// It supports conditional relationships and property mappings on the edge itself.
message RelationshipMapping {
  // type is the relationship type (e.g., "HAS_PORT", "AFFECTS", "RUNS_ON")
  string type = 1;

  // from_template is a template for the source node ID (e.g., "host:{.ip}")
  string from_template = 2;

  // to_template is a template for the target node ID (e.g., "port:{.port}")
  string to_template = 3;

  // condition is an optional condition for creating this relationship (e.g., "{{.severity}} == 'critical'")
  string condition = 4;

  // properties are property mappings for the relationship edge
  repeated PropertyMapping properties = 5;
}
