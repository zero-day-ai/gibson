// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v4.25.1
// source: daemon.proto

package api

import (
	proto "github.com/zero-day-ai/sdk/api/gen/proto"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// MissionStatus represents the execution status of a mission.
type MissionStatus int32

const (
	MissionStatus_MISSION_STATUS_UNSPECIFIED MissionStatus = 0
	MissionStatus_MISSION_STATUS_PENDING     MissionStatus = 1
	MissionStatus_MISSION_STATUS_RUNNING     MissionStatus = 2
	MissionStatus_MISSION_STATUS_PAUSED      MissionStatus = 3
	MissionStatus_MISSION_STATUS_COMPLETED   MissionStatus = 4
	MissionStatus_MISSION_STATUS_FAILED      MissionStatus = 5
	MissionStatus_MISSION_STATUS_CANCELLED   MissionStatus = 6
)

// Enum value maps for MissionStatus.
var (
	MissionStatus_name = map[int32]string{
		0: "MISSION_STATUS_UNSPECIFIED",
		1: "MISSION_STATUS_PENDING",
		2: "MISSION_STATUS_RUNNING",
		3: "MISSION_STATUS_PAUSED",
		4: "MISSION_STATUS_COMPLETED",
		5: "MISSION_STATUS_FAILED",
		6: "MISSION_STATUS_CANCELLED",
	}
	MissionStatus_value = map[string]int32{
		"MISSION_STATUS_UNSPECIFIED": 0,
		"MISSION_STATUS_PENDING":     1,
		"MISSION_STATUS_RUNNING":     2,
		"MISSION_STATUS_PAUSED":      3,
		"MISSION_STATUS_COMPLETED":   4,
		"MISSION_STATUS_FAILED":      5,
		"MISSION_STATUS_CANCELLED":   6,
	}
)

func (x MissionStatus) Enum() *MissionStatus {
	p := new(MissionStatus)
	*p = x
	return p
}

func (x MissionStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MissionStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_daemon_proto_enumTypes[0].Descriptor()
}

func (MissionStatus) Type() protoreflect.EnumType {
	return &file_daemon_proto_enumTypes[0]
}

func (x MissionStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MissionStatus.Descriptor instead.
func (MissionStatus) EnumDescriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{0}
}

// DependencySource indicates where a dependency was discovered.
type DependencySource int32

const (
	// SOURCE_UNKNOWN is the default unspecified source
	DependencySource_SOURCE_UNKNOWN DependencySource = 0
	// SOURCE_MISSION_EXPLICIT means the dependency is explicitly listed in mission dependencies
	DependencySource_SOURCE_MISSION_EXPLICIT DependencySource = 1
	// SOURCE_MISSION_NODE means the dependency is referenced by a mission node
	DependencySource_SOURCE_MISSION_NODE DependencySource = 2
	// SOURCE_MANIFEST means the dependency is from a component's manifest dependencies
	DependencySource_SOURCE_MANIFEST DependencySource = 3
)

// Enum value maps for DependencySource.
var (
	DependencySource_name = map[int32]string{
		0: "SOURCE_UNKNOWN",
		1: "SOURCE_MISSION_EXPLICIT",
		2: "SOURCE_MISSION_NODE",
		3: "SOURCE_MANIFEST",
	}
	DependencySource_value = map[string]int32{
		"SOURCE_UNKNOWN":          0,
		"SOURCE_MISSION_EXPLICIT": 1,
		"SOURCE_MISSION_NODE":     2,
		"SOURCE_MANIFEST":         3,
	}
)

func (x DependencySource) Enum() *DependencySource {
	p := new(DependencySource)
	*p = x
	return p
}

func (x DependencySource) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DependencySource) Descriptor() protoreflect.EnumDescriptor {
	return file_daemon_proto_enumTypes[1].Descriptor()
}

func (DependencySource) Type() protoreflect.EnumType {
	return &file_daemon_proto_enumTypes[1]
}

func (x DependencySource) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DependencySource.Descriptor instead.
func (DependencySource) EnumDescriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{1}
}

// ConnectRequest initiates a client connection to the daemon.
type ConnectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// client_version is the version of the Gibson CLI client
	ClientVersion string `protobuf:"bytes,1,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	// client_id is an optional unique identifier for this client
	ClientId      string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectRequest) Reset() {
	*x = ConnectRequest{}
	mi := &file_daemon_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectRequest) ProtoMessage() {}

func (x *ConnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{0}
}

func (x *ConnectRequest) GetClientVersion() string {
	if x != nil {
		return x.ClientVersion
	}
	return ""
}

func (x *ConnectRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

// ConnectResponse returns connection metadata.
type ConnectResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// daemon_version is the version of the running daemon
	DaemonVersion string `protobuf:"bytes,1,opt,name=daemon_version,json=daemonVersion,proto3" json:"daemon_version,omitempty"`
	// session_id is a unique identifier for this client session
	SessionId string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// grpc_address is the address the daemon is listening on
	GrpcAddress   string `protobuf:"bytes,3,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectResponse) Reset() {
	*x = ConnectResponse{}
	mi := &file_daemon_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectResponse) ProtoMessage() {}

func (x *ConnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{1}
}

func (x *ConnectResponse) GetDaemonVersion() string {
	if x != nil {
		return x.DaemonVersion
	}
	return ""
}

func (x *ConnectResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ConnectResponse) GetGrpcAddress() string {
	if x != nil {
		return x.GrpcAddress
	}
	return ""
}

// PingRequest is an empty health check request.
type PingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() {
	*x = PingRequest{}
	mi := &file_daemon_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PingRequest) ProtoMessage() {}

func (x *PingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{2}
}

// PingResponse confirms the daemon is responsive.
type PingResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// timestamp is the server time when the ping was received
	Timestamp     int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() {
	*x = PingResponse{}
	mi := &file_daemon_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PingResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PingResponse) ProtoMessage() {}

func (x *PingResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{3}
}

func (x *PingResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// StatusRequest queries daemon status.
type StatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusRequest) Reset() {
	*x = StatusRequest{}
	mi := &file_daemon_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusRequest) ProtoMessage() {}

func (x *StatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{4}
}

// StatusResponse returns complete daemon status information.
type StatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// running indicates if the daemon is running (always true if responding)
	Running bool `protobuf:"varint,1,opt,name=running,proto3" json:"running,omitempty"`
	// pid is the process ID of the daemon
	Pid int32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	// start_time is when the daemon started (Unix timestamp)
	StartTime int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// uptime is the human-readable uptime string
	Uptime string `protobuf:"bytes,4,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// grpc_address is the gRPC server address
	GrpcAddress string `protobuf:"bytes,5,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
	// registry_type is the type of registry (embedded, external)
	RegistryType string `protobuf:"bytes,6,opt,name=registry_type,json=registryType,proto3" json:"registry_type,omitempty"`
	// registry_addr is the registry endpoint address
	RegistryAddr string `protobuf:"bytes,7,opt,name=registry_addr,json=registryAddr,proto3" json:"registry_addr,omitempty"`
	// callback_addr is the callback server address
	CallbackAddr string `protobuf:"bytes,8,opt,name=callback_addr,json=callbackAddr,proto3" json:"callback_addr,omitempty"`
	// agent_count is the number of registered agents
	AgentCount int32 `protobuf:"varint,9,opt,name=agent_count,json=agentCount,proto3" json:"agent_count,omitempty"`
	// mission_count is the total number of missions
	MissionCount int32 `protobuf:"varint,10,opt,name=mission_count,json=missionCount,proto3" json:"mission_count,omitempty"`
	// active_mission_count is the number of currently running missions
	ActiveMissionCount int32 `protobuf:"varint,11,opt,name=active_mission_count,json=activeMissionCount,proto3" json:"active_mission_count,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StatusResponse) Reset() {
	*x = StatusResponse{}
	mi := &file_daemon_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusResponse) ProtoMessage() {}

func (x *StatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{5}
}

func (x *StatusResponse) GetRunning() bool {
	if x != nil {
		return x.Running
	}
	return false
}

func (x *StatusResponse) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *StatusResponse) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *StatusResponse) GetUptime() string {
	if x != nil {
		return x.Uptime
	}
	return ""
}

func (x *StatusResponse) GetGrpcAddress() string {
	if x != nil {
		return x.GrpcAddress
	}
	return ""
}

func (x *StatusResponse) GetRegistryType() string {
	if x != nil {
		return x.RegistryType
	}
	return ""
}

func (x *StatusResponse) GetRegistryAddr() string {
	if x != nil {
		return x.RegistryAddr
	}
	return ""
}

func (x *StatusResponse) GetCallbackAddr() string {
	if x != nil {
		return x.CallbackAddr
	}
	return ""
}

func (x *StatusResponse) GetAgentCount() int32 {
	if x != nil {
		return x.AgentCount
	}
	return 0
}

func (x *StatusResponse) GetMissionCount() int32 {
	if x != nil {
		return x.MissionCount
	}
	return 0
}

func (x *StatusResponse) GetActiveMissionCount() int32 {
	if x != nil {
		return x.ActiveMissionCount
	}
	return 0
}

// RunMissionRequest starts a mission execution.
type RunMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// workflow_path is the path to the mission workflow YAML file
	WorkflowPath string `protobuf:"bytes,1,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	// mission_id is an optional custom mission identifier
	MissionId string `protobuf:"bytes,2,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// variables contains workflow variables to override
	Variables map[string]string `protobuf:"bytes,3,rep,name=variables,proto3" json:"variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// memory_continuity defines how agent memory is shared across mission runs
	// Valid values: "isolated" (default), "inherit", "shared"
	MemoryContinuity string `protobuf:"bytes,4,opt,name=memory_continuity,json=memoryContinuity,proto3" json:"memory_continuity,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RunMissionRequest) Reset() {
	*x = RunMissionRequest{}
	mi := &file_daemon_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RunMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RunMissionRequest) ProtoMessage() {}

func (x *RunMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RunMissionRequest.ProtoReflect.Descriptor instead.
func (*RunMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{6}
}

func (x *RunMissionRequest) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

func (x *RunMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *RunMissionRequest) GetVariables() map[string]string {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *RunMissionRequest) GetMemoryContinuity() string {
	if x != nil {
		return x.MemoryContinuity
	}
	return ""
}

// MissionEvent represents a mission execution event.
type MissionEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the type of event
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// mission_id is the unique mission identifier
	MissionId string `protobuf:"bytes,3,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// node_id is the workflow node ID (if applicable)
	NodeId string `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// message is a human-readable event message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// data contains event-specific data (typed map)
	Data *proto.TypedMap `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// error contains error information if the event represents an error
	Error string `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
	// result contains typed operation metrics (for mission.completed events)
	Result        *OperationResult `protobuf:"bytes,8,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionEvent) Reset() {
	*x = MissionEvent{}
	mi := &file_daemon_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionEvent) ProtoMessage() {}

func (x *MissionEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionEvent.ProtoReflect.Descriptor instead.
func (*MissionEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{7}
}

func (x *MissionEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *MissionEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MissionEvent) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *MissionEvent) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *MissionEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *MissionEvent) GetData() *proto.TypedMap {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *MissionEvent) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *MissionEvent) GetResult() *OperationResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// StopMissionRequest requests mission termination.
type StopMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the identifier of the mission to stop
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// force indicates whether to force-kill the mission (default: graceful)
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopMissionRequest) Reset() {
	*x = StopMissionRequest{}
	mi := &file_daemon_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopMissionRequest) ProtoMessage() {}

func (x *StopMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopMissionRequest.ProtoReflect.Descriptor instead.
func (*StopMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{8}
}

func (x *StopMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *StopMissionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// StopMissionResponse confirms mission stop request.
type StopMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the stop request was accepted
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// message provides additional context
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopMissionResponse) Reset() {
	*x = StopMissionResponse{}
	mi := &file_daemon_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopMissionResponse) ProtoMessage() {}

func (x *StopMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopMissionResponse.ProtoReflect.Descriptor instead.
func (*StopMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{9}
}

func (x *StopMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StopMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ListMissionsRequest queries mission list.
type ListMissionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// active_only filters to only running missions
	ActiveOnly bool `protobuf:"varint,1,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
	// limit restricts the number of results
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// offset is the pagination offset
	Offset int32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// status_filter filters missions by status (running, completed, failed, cancelled)
	StatusFilter string `protobuf:"bytes,4,opt,name=status_filter,json=statusFilter,proto3" json:"status_filter,omitempty"`
	// name_pattern filters missions by name using glob pattern matching
	NamePattern   string `protobuf:"bytes,5,opt,name=name_pattern,json=namePattern,proto3" json:"name_pattern,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMissionsRequest) Reset() {
	*x = ListMissionsRequest{}
	mi := &file_daemon_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMissionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMissionsRequest) ProtoMessage() {}

func (x *ListMissionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMissionsRequest.ProtoReflect.Descriptor instead.
func (*ListMissionsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{10}
}

func (x *ListMissionsRequest) GetActiveOnly() bool {
	if x != nil {
		return x.ActiveOnly
	}
	return false
}

func (x *ListMissionsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListMissionsRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *ListMissionsRequest) GetStatusFilter() string {
	if x != nil {
		return x.StatusFilter
	}
	return ""
}

func (x *ListMissionsRequest) GetNamePattern() string {
	if x != nil {
		return x.NamePattern
	}
	return ""
}

// ListMissionsResponse returns mission list.
type ListMissionsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// missions is the list of missions
	Missions []*MissionInfo `protobuf:"bytes,1,rep,name=missions,proto3" json:"missions,omitempty"`
	// total is the total count of missions (for pagination)
	Total         int32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMissionsResponse) Reset() {
	*x = ListMissionsResponse{}
	mi := &file_daemon_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMissionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMissionsResponse) ProtoMessage() {}

func (x *ListMissionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMissionsResponse.ProtoReflect.Descriptor instead.
func (*ListMissionsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{11}
}

func (x *ListMissionsResponse) GetMissions() []*MissionInfo {
	if x != nil {
		return x.Missions
	}
	return nil
}

func (x *ListMissionsResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// MissionInfo describes a mission.
type MissionInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique mission identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// workflow_path is the path to the workflow file (legacy, may be "<inline>")
	WorkflowPath string `protobuf:"bytes,2,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	// status is the mission status (running, completed, failed)
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// start_time is when the mission started (Unix timestamp)
	StartTime int64 `protobuf:"varint,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end_time is when the mission ended (Unix timestamp, 0 if running)
	EndTime int64 `protobuf:"varint,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// finding_count is the number of findings discovered
	FindingCount int32 `protobuf:"varint,6,opt,name=finding_count,json=findingCount,proto3" json:"finding_count,omitempty"`
	// name is the human-readable mission name
	Name          string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionInfo) Reset() {
	*x = MissionInfo{}
	mi := &file_daemon_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionInfo) ProtoMessage() {}

func (x *MissionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionInfo.ProtoReflect.Descriptor instead.
func (*MissionInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{12}
}

func (x *MissionInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *MissionInfo) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

func (x *MissionInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *MissionInfo) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *MissionInfo) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *MissionInfo) GetFindingCount() int32 {
	if x != nil {
		return x.FindingCount
	}
	return 0
}

func (x *MissionInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// ListAgentsRequest queries agent registry.
type ListAgentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind filters by component kind (empty = all agents)
	Kind          string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAgentsRequest) Reset() {
	*x = ListAgentsRequest{}
	mi := &file_daemon_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAgentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAgentsRequest) ProtoMessage() {}

func (x *ListAgentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAgentsRequest.ProtoReflect.Descriptor instead.
func (*ListAgentsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{13}
}

func (x *ListAgentsRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

// ListAgentsResponse returns registered agents.
type ListAgentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// agents is the list of registered agents
	Agents        []*AgentInfo `protobuf:"bytes,1,rep,name=agents,proto3" json:"agents,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAgentsResponse) Reset() {
	*x = ListAgentsResponse{}
	mi := &file_daemon_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAgentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAgentsResponse) ProtoMessage() {}

func (x *ListAgentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAgentsResponse.ProtoReflect.Descriptor instead.
func (*ListAgentsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{14}
}

func (x *ListAgentsResponse) GetAgents() []*AgentInfo {
	if x != nil {
		return x.Agents
	}
	return nil
}

// AgentInfo describes a registered agent.
type AgentInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique agent identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the agent name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// kind is the component kind (always "agent")
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// version is the agent version
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// endpoint is the gRPC endpoint for the agent
	Endpoint string `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// capabilities lists agent capabilities
	Capabilities []string `protobuf:"bytes,6,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	// health is the agent health status (healthy, unhealthy)
	Health string `protobuf:"bytes,7,opt,name=health,proto3" json:"health,omitempty"`
	// last_seen is when the agent was last seen (Unix timestamp)
	LastSeen      int64 `protobuf:"varint,8,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentInfo) Reset() {
	*x = AgentInfo{}
	mi := &file_daemon_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentInfo) ProtoMessage() {}

func (x *AgentInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentInfo.ProtoReflect.Descriptor instead.
func (*AgentInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{15}
}

func (x *AgentInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AgentInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AgentInfo) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *AgentInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AgentInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *AgentInfo) GetCapabilities() []string {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *AgentInfo) GetHealth() string {
	if x != nil {
		return x.Health
	}
	return ""
}

func (x *AgentInfo) GetLastSeen() int64 {
	if x != nil {
		return x.LastSeen
	}
	return 0
}

// GetAgentStatusRequest queries a specific agent.
type GetAgentStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// agent_id is the unique agent identifier
	AgentId       string `protobuf:"bytes,1,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAgentStatusRequest) Reset() {
	*x = GetAgentStatusRequest{}
	mi := &file_daemon_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAgentStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAgentStatusRequest) ProtoMessage() {}

func (x *GetAgentStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAgentStatusRequest.ProtoReflect.Descriptor instead.
func (*GetAgentStatusRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{16}
}

func (x *GetAgentStatusRequest) GetAgentId() string {
	if x != nil {
		return x.AgentId
	}
	return ""
}

// AgentStatusResponse returns agent status.
type AgentStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// agent is the agent information
	Agent *AgentInfo `protobuf:"bytes,1,opt,name=agent,proto3" json:"agent,omitempty"`
	// active indicates if the agent is currently executing a task
	Active bool `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
	// current_task describes the active task (if any)
	CurrentTask string `protobuf:"bytes,3,opt,name=current_task,json=currentTask,proto3" json:"current_task,omitempty"`
	// task_start_time is when the current task started (Unix timestamp)
	TaskStartTime int64 `protobuf:"varint,4,opt,name=task_start_time,json=taskStartTime,proto3" json:"task_start_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentStatusResponse) Reset() {
	*x = AgentStatusResponse{}
	mi := &file_daemon_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentStatusResponse) ProtoMessage() {}

func (x *AgentStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentStatusResponse.ProtoReflect.Descriptor instead.
func (*AgentStatusResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{17}
}

func (x *AgentStatusResponse) GetAgent() *AgentInfo {
	if x != nil {
		return x.Agent
	}
	return nil
}

func (x *AgentStatusResponse) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *AgentStatusResponse) GetCurrentTask() string {
	if x != nil {
		return x.CurrentTask
	}
	return ""
}

func (x *AgentStatusResponse) GetTaskStartTime() int64 {
	if x != nil {
		return x.TaskStartTime
	}
	return 0
}

// ListToolsRequest queries tool registry.
type ListToolsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListToolsRequest) Reset() {
	*x = ListToolsRequest{}
	mi := &file_daemon_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListToolsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListToolsRequest) ProtoMessage() {}

func (x *ListToolsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListToolsRequest.ProtoReflect.Descriptor instead.
func (*ListToolsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{18}
}

// ListToolsResponse returns registered tools.
type ListToolsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tools is the list of registered tools
	Tools         []*ToolInfo `protobuf:"bytes,1,rep,name=tools,proto3" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListToolsResponse) Reset() {
	*x = ListToolsResponse{}
	mi := &file_daemon_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListToolsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListToolsResponse) ProtoMessage() {}

func (x *ListToolsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListToolsResponse.ProtoReflect.Descriptor instead.
func (*ListToolsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{19}
}

func (x *ListToolsResponse) GetTools() []*ToolInfo {
	if x != nil {
		return x.Tools
	}
	return nil
}

// ToolInfo describes a registered tool.
type ToolInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique tool identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the tool name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the tool version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// endpoint is the gRPC endpoint for the tool
	Endpoint string `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// description is the tool description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// health is the tool health status (healthy, unhealthy)
	Health string `protobuf:"bytes,6,opt,name=health,proto3" json:"health,omitempty"`
	// last_seen is when the tool was last seen (Unix timestamp)
	LastSeen      int64 `protobuf:"varint,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolInfo) Reset() {
	*x = ToolInfo{}
	mi := &file_daemon_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolInfo) ProtoMessage() {}

func (x *ToolInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolInfo.ProtoReflect.Descriptor instead.
func (*ToolInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{20}
}

func (x *ToolInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ToolInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ToolInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ToolInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *ToolInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ToolInfo) GetHealth() string {
	if x != nil {
		return x.Health
	}
	return ""
}

func (x *ToolInfo) GetLastSeen() int64 {
	if x != nil {
		return x.LastSeen
	}
	return 0
}

// ListPluginsRequest queries plugin registry.
type ListPluginsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPluginsRequest) Reset() {
	*x = ListPluginsRequest{}
	mi := &file_daemon_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPluginsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPluginsRequest) ProtoMessage() {}

func (x *ListPluginsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPluginsRequest.ProtoReflect.Descriptor instead.
func (*ListPluginsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{21}
}

// ListPluginsResponse returns registered plugins.
type ListPluginsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// plugins is the list of registered plugins
	Plugins       []*PluginInfo `protobuf:"bytes,1,rep,name=plugins,proto3" json:"plugins,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPluginsResponse) Reset() {
	*x = ListPluginsResponse{}
	mi := &file_daemon_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPluginsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPluginsResponse) ProtoMessage() {}

func (x *ListPluginsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPluginsResponse.ProtoReflect.Descriptor instead.
func (*ListPluginsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{22}
}

func (x *ListPluginsResponse) GetPlugins() []*PluginInfo {
	if x != nil {
		return x.Plugins
	}
	return nil
}

// PluginInfo describes a registered plugin.
type PluginInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique plugin identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the plugin name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the plugin version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// endpoint is the gRPC endpoint for the plugin
	Endpoint string `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// description is the plugin description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// health is the plugin health status (healthy, unhealthy)
	Health string `protobuf:"bytes,6,opt,name=health,proto3" json:"health,omitempty"`
	// last_seen is when the plugin was last seen (Unix timestamp)
	LastSeen      int64 `protobuf:"varint,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginInfo) Reset() {
	*x = PluginInfo{}
	mi := &file_daemon_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginInfo) ProtoMessage() {}

func (x *PluginInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginInfo.ProtoReflect.Descriptor instead.
func (*PluginInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{23}
}

func (x *PluginInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *PluginInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PluginInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *PluginInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *PluginInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *PluginInfo) GetHealth() string {
	if x != nil {
		return x.Health
	}
	return ""
}

func (x *PluginInfo) GetLastSeen() int64 {
	if x != nil {
		return x.LastSeen
	}
	return 0
}

// QueryPluginRequest executes a method on a plugin.
type QueryPluginRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the plugin name to query
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// method is the method name to execute
	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	// params is the typed parameters for the method
	Params *proto.TypedMap `protobuf:"bytes,3,opt,name=params,proto3" json:"params,omitempty"`
	// timeout_ms is the optional timeout in milliseconds (0 = default)
	TimeoutMs     int64 `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryPluginRequest) Reset() {
	*x = QueryPluginRequest{}
	mi := &file_daemon_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryPluginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryPluginRequest) ProtoMessage() {}

func (x *QueryPluginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryPluginRequest.ProtoReflect.Descriptor instead.
func (*QueryPluginRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{24}
}

func (x *QueryPluginRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *QueryPluginRequest) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *QueryPluginRequest) GetParams() *proto.TypedMap {
	if x != nil {
		return x.Params
	}
	return nil
}

func (x *QueryPluginRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// QueryPluginResponse returns the result of a plugin query.
type QueryPluginResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// result is the typed result from the plugin method
	Result *proto.TypedValue `protobuf:"bytes,1,opt,name=result,proto3" json:"result,omitempty"`
	// error is set if the query failed
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// duration_ms is how long the query took in milliseconds
	DurationMs    int64 `protobuf:"varint,3,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryPluginResponse) Reset() {
	*x = QueryPluginResponse{}
	mi := &file_daemon_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryPluginResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryPluginResponse) ProtoMessage() {}

func (x *QueryPluginResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryPluginResponse.ProtoReflect.Descriptor instead.
func (*QueryPluginResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{25}
}

func (x *QueryPluginResponse) GetResult() *proto.TypedValue {
	if x != nil {
		return x.Result
	}
	return nil
}

func (x *QueryPluginResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *QueryPluginResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// RunAttackRequest executes an attack.
type RunAttackRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target is the target URL or identifier
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// attack_type is the type of attack to execute
	AttackType string `protobuf:"bytes,2,opt,name=attack_type,json=attackType,proto3" json:"attack_type,omitempty"`
	// agent_id is the agent to use (optional, auto-select if empty)
	AgentId string `protobuf:"bytes,3,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	// payload_filter filters which payloads to use
	PayloadFilter string `protobuf:"bytes,4,opt,name=payload_filter,json=payloadFilter,proto3" json:"payload_filter,omitempty"`
	// options contains attack-specific options
	Options map[string]string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// target_name is the name of a stored target to look up from the database
	TargetName    string `protobuf:"bytes,6,opt,name=target_name,json=targetName,proto3" json:"target_name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RunAttackRequest) Reset() {
	*x = RunAttackRequest{}
	mi := &file_daemon_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RunAttackRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RunAttackRequest) ProtoMessage() {}

func (x *RunAttackRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RunAttackRequest.ProtoReflect.Descriptor instead.
func (*RunAttackRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{26}
}

func (x *RunAttackRequest) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *RunAttackRequest) GetAttackType() string {
	if x != nil {
		return x.AttackType
	}
	return ""
}

func (x *RunAttackRequest) GetAgentId() string {
	if x != nil {
		return x.AgentId
	}
	return ""
}

func (x *RunAttackRequest) GetPayloadFilter() string {
	if x != nil {
		return x.PayloadFilter
	}
	return ""
}

func (x *RunAttackRequest) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *RunAttackRequest) GetTargetName() string {
	if x != nil {
		return x.TargetName
	}
	return ""
}

// AttackEvent represents an attack execution event.
type AttackEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the type of event
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// attack_id is the unique attack identifier
	AttackId string `protobuf:"bytes,3,opt,name=attack_id,json=attackId,proto3" json:"attack_id,omitempty"`
	// message is a human-readable event message
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// data contains event-specific data (typed map)
	Data *proto.TypedMap `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	// error contains error information if the event represents an error
	Error string `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
	// finding describes a discovered finding (if applicable)
	Finding *FindingInfo `protobuf:"bytes,7,opt,name=finding,proto3" json:"finding,omitempty"`
	// result contains typed operation metrics (for attack.completed events)
	Result        *OperationResult `protobuf:"bytes,8,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttackEvent) Reset() {
	*x = AttackEvent{}
	mi := &file_daemon_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttackEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttackEvent) ProtoMessage() {}

func (x *AttackEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttackEvent.ProtoReflect.Descriptor instead.
func (*AttackEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{27}
}

func (x *AttackEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *AttackEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *AttackEvent) GetAttackId() string {
	if x != nil {
		return x.AttackId
	}
	return ""
}

func (x *AttackEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *AttackEvent) GetData() *proto.TypedMap {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *AttackEvent) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AttackEvent) GetFinding() *FindingInfo {
	if x != nil {
		return x.Finding
	}
	return nil
}

func (x *AttackEvent) GetResult() *OperationResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// FindingInfo describes a discovered vulnerability.
type FindingInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique finding identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// title is the finding title
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// severity is the severity level (info, low, medium, high, critical)
	Severity string `protobuf:"bytes,3,opt,name=severity,proto3" json:"severity,omitempty"`
	// category is the finding category
	Category string `protobuf:"bytes,4,opt,name=category,proto3" json:"category,omitempty"`
	// description is the detailed finding description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// technique is the MITRE ATT&CK or ATLAS technique ID
	Technique string `protobuf:"bytes,6,opt,name=technique,proto3" json:"technique,omitempty"`
	// evidence contains supporting evidence
	Evidence string `protobuf:"bytes,7,opt,name=evidence,proto3" json:"evidence,omitempty"`
	// timestamp is when the finding was discovered (Unix timestamp)
	Timestamp     int64 `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FindingInfo) Reset() {
	*x = FindingInfo{}
	mi := &file_daemon_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FindingInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindingInfo) ProtoMessage() {}

func (x *FindingInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindingInfo.ProtoReflect.Descriptor instead.
func (*FindingInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{28}
}

func (x *FindingInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *FindingInfo) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *FindingInfo) GetSeverity() string {
	if x != nil {
		return x.Severity
	}
	return ""
}

func (x *FindingInfo) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *FindingInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *FindingInfo) GetTechnique() string {
	if x != nil {
		return x.Technique
	}
	return ""
}

func (x *FindingInfo) GetEvidence() string {
	if x != nil {
		return x.Evidence
	}
	return ""
}

func (x *FindingInfo) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// SubscribeRequest establishes an event stream.
type SubscribeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_types filters which event types to receive (empty = all)
	EventTypes []string `protobuf:"bytes,1,rep,name=event_types,json=eventTypes,proto3" json:"event_types,omitempty"`
	// mission_id filters to a specific mission (empty = all)
	MissionId     string `protobuf:"bytes,2,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeRequest) Reset() {
	*x = SubscribeRequest{}
	mi := &file_daemon_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeRequest) ProtoMessage() {}

func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeRequest.ProtoReflect.Descriptor instead.
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{29}
}

func (x *SubscribeRequest) GetEventTypes() []string {
	if x != nil {
		return x.EventTypes
	}
	return nil
}

func (x *SubscribeRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

// Event represents a generic daemon event.
type Event struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the type of event
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// source is the event source (mission, agent, daemon, etc.)
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// data contains event-specific data (typed map)
	Data *proto.TypedMap `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	// Specific event types (only one will be set)
	//
	// Types that are valid to be assigned to Event:
	//
	//	*Event_MissionEvent
	//	*Event_AttackEvent
	//	*Event_AgentEvent
	//	*Event_FindingEvent
	Event         isEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Event) Reset() {
	*x = Event{}
	mi := &file_daemon_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Event) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Event) ProtoMessage() {}

func (x *Event) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Event.ProtoReflect.Descriptor instead.
func (*Event) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{30}
}

func (x *Event) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *Event) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Event) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Event) GetData() *proto.TypedMap {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *Event) GetEvent() isEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *Event) GetMissionEvent() *MissionEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_MissionEvent); ok {
			return x.MissionEvent
		}
	}
	return nil
}

func (x *Event) GetAttackEvent() *AttackEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_AttackEvent); ok {
			return x.AttackEvent
		}
	}
	return nil
}

func (x *Event) GetAgentEvent() *AgentEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_AgentEvent); ok {
			return x.AgentEvent
		}
	}
	return nil
}

func (x *Event) GetFindingEvent() *FindingEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_FindingEvent); ok {
			return x.FindingEvent
		}
	}
	return nil
}

type isEvent_Event interface {
	isEvent_Event()
}

type Event_MissionEvent struct {
	MissionEvent *MissionEvent `protobuf:"bytes,5,opt,name=mission_event,json=missionEvent,proto3,oneof"`
}

type Event_AttackEvent struct {
	AttackEvent *AttackEvent `protobuf:"bytes,6,opt,name=attack_event,json=attackEvent,proto3,oneof"`
}

type Event_AgentEvent struct {
	AgentEvent *AgentEvent `protobuf:"bytes,7,opt,name=agent_event,json=agentEvent,proto3,oneof"`
}

type Event_FindingEvent struct {
	FindingEvent *FindingEvent `protobuf:"bytes,8,opt,name=finding_event,json=findingEvent,proto3,oneof"`
}

func (*Event_MissionEvent) isEvent_Event() {}

func (*Event_AttackEvent) isEvent_Event() {}

func (*Event_AgentEvent) isEvent_Event() {}

func (*Event_FindingEvent) isEvent_Event() {}

// AgentEvent represents an agent lifecycle event.
type AgentEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the agent event type (registered, unregistered, health_change)
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// agent_id is the agent identifier
	AgentId string `protobuf:"bytes,3,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	// agent_name is the agent name
	AgentName string `protobuf:"bytes,4,opt,name=agent_name,json=agentName,proto3" json:"agent_name,omitempty"`
	// message is a human-readable message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// data contains event-specific data (typed map)
	Data          *proto.TypedMap `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentEvent) Reset() {
	*x = AgentEvent{}
	mi := &file_daemon_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentEvent) ProtoMessage() {}

func (x *AgentEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentEvent.ProtoReflect.Descriptor instead.
func (*AgentEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{31}
}

func (x *AgentEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *AgentEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *AgentEvent) GetAgentId() string {
	if x != nil {
		return x.AgentId
	}
	return ""
}

func (x *AgentEvent) GetAgentName() string {
	if x != nil {
		return x.AgentName
	}
	return ""
}

func (x *AgentEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *AgentEvent) GetData() *proto.TypedMap {
	if x != nil {
		return x.Data
	}
	return nil
}

// FindingEvent represents a finding discovery event.
type FindingEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the finding event type (discovered, updated)
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// finding is the finding information
	Finding *FindingInfo `protobuf:"bytes,3,opt,name=finding,proto3" json:"finding,omitempty"`
	// mission_id is the mission that discovered the finding
	MissionId     string `protobuf:"bytes,4,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FindingEvent) Reset() {
	*x = FindingEvent{}
	mi := &file_daemon_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FindingEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindingEvent) ProtoMessage() {}

func (x *FindingEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindingEvent.ProtoReflect.Descriptor instead.
func (*FindingEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{32}
}

func (x *FindingEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *FindingEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *FindingEvent) GetFinding() *FindingInfo {
	if x != nil {
		return x.Finding
	}
	return nil
}

func (x *FindingEvent) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

// StartComponentRequest requests starting a component.
type StartComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartComponentRequest) Reset() {
	*x = StartComponentRequest{}
	mi := &file_daemon_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartComponentRequest) ProtoMessage() {}

func (x *StartComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartComponentRequest.ProtoReflect.Descriptor instead.
func (*StartComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{33}
}

func (x *StartComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *StartComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// StartComponentResponse returns the result of starting a component.
type StartComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was started successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// pid is the process ID of the started component
	Pid int32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	// port is the port the component is listening on
	Port int32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// message provides additional context or error information
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// log_path is the path to the component's log file
	LogPath       string `protobuf:"bytes,5,opt,name=log_path,json=logPath,proto3" json:"log_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartComponentResponse) Reset() {
	*x = StartComponentResponse{}
	mi := &file_daemon_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartComponentResponse) ProtoMessage() {}

func (x *StartComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartComponentResponse.ProtoReflect.Descriptor instead.
func (*StartComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{34}
}

func (x *StartComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StartComponentResponse) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *StartComponentResponse) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *StartComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *StartComponentResponse) GetLogPath() string {
	if x != nil {
		return x.LogPath
	}
	return ""
}

// StopComponentRequest requests stopping a component.
type StopComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// force indicates whether to skip graceful shutdown (SIGKILL instead of SIGTERM)
	Force         bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopComponentRequest) Reset() {
	*x = StopComponentRequest{}
	mi := &file_daemon_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopComponentRequest) ProtoMessage() {}

func (x *StopComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopComponentRequest.ProtoReflect.Descriptor instead.
func (*StopComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{35}
}

func (x *StopComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *StopComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StopComponentRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// StopComponentResponse returns the result of stopping a component.
type StopComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was stopped successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// stopped_count is the number of instances successfully stopped
	StoppedCount int32 `protobuf:"varint,2,opt,name=stopped_count,json=stoppedCount,proto3" json:"stopped_count,omitempty"`
	// total_count is the total number of instances that were running
	TotalCount int32 `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopComponentResponse) Reset() {
	*x = StopComponentResponse{}
	mi := &file_daemon_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopComponentResponse) ProtoMessage() {}

func (x *StopComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopComponentResponse.ProtoReflect.Descriptor instead.
func (*StopComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{36}
}

func (x *StopComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StopComponentResponse) GetStoppedCount() int32 {
	if x != nil {
		return x.StoppedCount
	}
	return 0
}

func (x *StopComponentResponse) GetTotalCount() int32 {
	if x != nil {
		return x.TotalCount
	}
	return 0
}

func (x *StopComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// OperationResult represents the unified result of a long-running operation (attack or mission).
// This provides typed metrics instead of JSON-encoded strings.
type OperationResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status of the operation ("success", "failed", "timeout", "cancelled")
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// duration_ms is the total duration in milliseconds
	DurationMs int64 `protobuf:"varint,2,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// started_at is the Unix timestamp (milliseconds) when the operation started
	StartedAt int64 `protobuf:"varint,3,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// completed_at is the Unix timestamp (milliseconds) when the operation completed
	CompletedAt int64 `protobuf:"varint,4,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	// turns_used is the number of agent turns/iterations executed
	TurnsUsed int32 `protobuf:"varint,5,opt,name=turns_used,json=turnsUsed,proto3" json:"turns_used,omitempty"`
	// tokens_used is the total LLM tokens consumed
	TokensUsed int64 `protobuf:"varint,6,opt,name=tokens_used,json=tokensUsed,proto3" json:"tokens_used,omitempty"`
	// nodes_executed is the number of workflow nodes that ran successfully
	NodesExecuted int32 `protobuf:"varint,7,opt,name=nodes_executed,json=nodesExecuted,proto3" json:"nodes_executed,omitempty"`
	// nodes_failed is the number of workflow nodes that failed
	NodesFailed int32 `protobuf:"varint,8,opt,name=nodes_failed,json=nodesFailed,proto3" json:"nodes_failed,omitempty"`
	// findings_count is the total number of findings discovered
	FindingsCount int32 `protobuf:"varint,9,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// critical_count is the number of critical severity findings
	CriticalCount int32 `protobuf:"varint,10,opt,name=critical_count,json=criticalCount,proto3" json:"critical_count,omitempty"`
	// high_count is the number of high severity findings
	HighCount int32 `protobuf:"varint,11,opt,name=high_count,json=highCount,proto3" json:"high_count,omitempty"`
	// medium_count is the number of medium severity findings
	MediumCount int32 `protobuf:"varint,12,opt,name=medium_count,json=mediumCount,proto3" json:"medium_count,omitempty"`
	// low_count is the number of low severity findings
	LowCount int32 `protobuf:"varint,13,opt,name=low_count,json=lowCount,proto3" json:"low_count,omitempty"`
	// error_message contains the error message if status == "failed"
	ErrorMessage string `protobuf:"bytes,14,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// error_code contains a machine-readable error code if status == "failed"
	ErrorCode     string `protobuf:"bytes,15,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationResult) Reset() {
	*x = OperationResult{}
	mi := &file_daemon_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationResult) ProtoMessage() {}

func (x *OperationResult) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationResult.ProtoReflect.Descriptor instead.
func (*OperationResult) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{37}
}

func (x *OperationResult) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *OperationResult) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *OperationResult) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *OperationResult) GetCompletedAt() int64 {
	if x != nil {
		return x.CompletedAt
	}
	return 0
}

func (x *OperationResult) GetTurnsUsed() int32 {
	if x != nil {
		return x.TurnsUsed
	}
	return 0
}

func (x *OperationResult) GetTokensUsed() int64 {
	if x != nil {
		return x.TokensUsed
	}
	return 0
}

func (x *OperationResult) GetNodesExecuted() int32 {
	if x != nil {
		return x.NodesExecuted
	}
	return 0
}

func (x *OperationResult) GetNodesFailed() int32 {
	if x != nil {
		return x.NodesFailed
	}
	return 0
}

func (x *OperationResult) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *OperationResult) GetCriticalCount() int32 {
	if x != nil {
		return x.CriticalCount
	}
	return 0
}

func (x *OperationResult) GetHighCount() int32 {
	if x != nil {
		return x.HighCount
	}
	return 0
}

func (x *OperationResult) GetMediumCount() int32 {
	if x != nil {
		return x.MediumCount
	}
	return 0
}

func (x *OperationResult) GetLowCount() int32 {
	if x != nil {
		return x.LowCount
	}
	return 0
}

func (x *OperationResult) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *OperationResult) GetErrorCode() string {
	if x != nil {
		return x.ErrorCode
	}
	return ""
}

// PauseMissionRequest requests pausing a running mission.
type PauseMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier of the mission to pause
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// force indicates whether to pause immediately without waiting for a clean checkpoint boundary
	// If false (default), waits for the current node to complete before pausing
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PauseMissionRequest) Reset() {
	*x = PauseMissionRequest{}
	mi := &file_daemon_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PauseMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PauseMissionRequest) ProtoMessage() {}

func (x *PauseMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PauseMissionRequest.ProtoReflect.Descriptor instead.
func (*PauseMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{38}
}

func (x *PauseMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *PauseMissionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// PauseMissionResponse confirms the mission pause request.
type PauseMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the pause request was accepted
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// checkpoint_id is the ID of the checkpoint created during pause
	CheckpointId string `protobuf:"bytes,2,opt,name=checkpoint_id,json=checkpointId,proto3" json:"checkpoint_id,omitempty"`
	// message provides additional context about the pause operation
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PauseMissionResponse) Reset() {
	*x = PauseMissionResponse{}
	mi := &file_daemon_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PauseMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PauseMissionResponse) ProtoMessage() {}

func (x *PauseMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PauseMissionResponse.ProtoReflect.Descriptor instead.
func (*PauseMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{39}
}

func (x *PauseMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *PauseMissionResponse) GetCheckpointId() string {
	if x != nil {
		return x.CheckpointId
	}
	return ""
}

func (x *PauseMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ResumeMissionRequest requests resuming a paused mission.
type ResumeMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier of the mission to resume
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// checkpoint_id optionally specifies a specific checkpoint to resume from
	// If empty, resumes from the latest checkpoint
	CheckpointId  string `protobuf:"bytes,2,opt,name=checkpoint_id,json=checkpointId,proto3" json:"checkpoint_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResumeMissionRequest) Reset() {
	*x = ResumeMissionRequest{}
	mi := &file_daemon_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResumeMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResumeMissionRequest) ProtoMessage() {}

func (x *ResumeMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResumeMissionRequest.ProtoReflect.Descriptor instead.
func (*ResumeMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{40}
}

func (x *ResumeMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *ResumeMissionRequest) GetCheckpointId() string {
	if x != nil {
		return x.CheckpointId
	}
	return ""
}

// GetMissionHistoryRequest queries mission execution history by name.
type GetMissionHistoryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the mission name to query history for
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// limit restricts the number of results (default: 100)
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// offset is the pagination offset (default: 0)
	Offset        int32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionHistoryRequest) Reset() {
	*x = GetMissionHistoryRequest{}
	mi := &file_daemon_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionHistoryRequest) ProtoMessage() {}

func (x *GetMissionHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetMissionHistoryRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{41}
}

func (x *GetMissionHistoryRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetMissionHistoryRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *GetMissionHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// GetMissionHistoryResponse returns mission execution history.
type GetMissionHistoryResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// runs contains all mission runs for the requested name
	Runs []*MissionRun `protobuf:"bytes,1,rep,name=runs,proto3" json:"runs,omitempty"`
	// total is the total count of runs (for pagination)
	Total         int32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionHistoryResponse) Reset() {
	*x = GetMissionHistoryResponse{}
	mi := &file_daemon_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionHistoryResponse) ProtoMessage() {}

func (x *GetMissionHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetMissionHistoryResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{42}
}

func (x *GetMissionHistoryResponse) GetRuns() []*MissionRun {
	if x != nil {
		return x.Runs
	}
	return nil
}

func (x *GetMissionHistoryResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// MissionRun represents a single execution instance of a mission.
type MissionRun struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier for this run
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// run_number is the sequential run number for this mission name
	RunNumber int32 `protobuf:"varint,2,opt,name=run_number,json=runNumber,proto3" json:"run_number,omitempty"`
	// status is the final status of this run (running, completed, failed, cancelled, paused)
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// created_at is when this run was created (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// completed_at is when this run completed (Unix timestamp, 0 if not completed)
	CompletedAt int64 `protobuf:"varint,5,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	// findings_count is the number of findings discovered in this run
	FindingsCount int32 `protobuf:"varint,6,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// previous_run_id is the ID of the previous run (if any)
	PreviousRunId string `protobuf:"bytes,7,opt,name=previous_run_id,json=previousRunId,proto3" json:"previous_run_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionRun) Reset() {
	*x = MissionRun{}
	mi := &file_daemon_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionRun) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionRun) ProtoMessage() {}

func (x *MissionRun) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionRun.ProtoReflect.Descriptor instead.
func (*MissionRun) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{43}
}

func (x *MissionRun) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *MissionRun) GetRunNumber() int32 {
	if x != nil {
		return x.RunNumber
	}
	return 0
}

func (x *MissionRun) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *MissionRun) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *MissionRun) GetCompletedAt() int64 {
	if x != nil {
		return x.CompletedAt
	}
	return 0
}

func (x *MissionRun) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *MissionRun) GetPreviousRunId() string {
	if x != nil {
		return x.PreviousRunId
	}
	return ""
}

// GetMissionCheckpointsRequest queries checkpoints for a mission.
type GetMissionCheckpointsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier of the mission to query checkpoints for
	MissionId     string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionCheckpointsRequest) Reset() {
	*x = GetMissionCheckpointsRequest{}
	mi := &file_daemon_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionCheckpointsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionCheckpointsRequest) ProtoMessage() {}

func (x *GetMissionCheckpointsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionCheckpointsRequest.ProtoReflect.Descriptor instead.
func (*GetMissionCheckpointsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{44}
}

func (x *GetMissionCheckpointsRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

// GetMissionCheckpointsResponse returns all checkpoints for a mission.
type GetMissionCheckpointsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// checkpoints contains all checkpoints for the requested mission
	Checkpoints   []*CheckpointInfo `protobuf:"bytes,1,rep,name=checkpoints,proto3" json:"checkpoints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionCheckpointsResponse) Reset() {
	*x = GetMissionCheckpointsResponse{}
	mi := &file_daemon_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionCheckpointsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionCheckpointsResponse) ProtoMessage() {}

func (x *GetMissionCheckpointsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionCheckpointsResponse.ProtoReflect.Descriptor instead.
func (*GetMissionCheckpointsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{45}
}

func (x *GetMissionCheckpointsResponse) GetCheckpoints() []*CheckpointInfo {
	if x != nil {
		return x.Checkpoints
	}
	return nil
}

// CheckpointInfo provides metadata about a mission checkpoint.
type CheckpointInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// checkpoint_id is the unique identifier for this checkpoint
	CheckpointId string `protobuf:"bytes,1,opt,name=checkpoint_id,json=checkpointId,proto3" json:"checkpoint_id,omitempty"`
	// created_at is when this checkpoint was created (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// completed_nodes is the number of nodes that had completed at checkpoint time
	CompletedNodes int32 `protobuf:"varint,3,opt,name=completed_nodes,json=completedNodes,proto3" json:"completed_nodes,omitempty"`
	// total_nodes is the total number of nodes in the workflow
	TotalNodes int32 `protobuf:"varint,4,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
	// findings_count is the number of findings at checkpoint time
	FindingsCount int32 `protobuf:"varint,5,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// version is the checkpoint format version
	Version       int32 `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckpointInfo) Reset() {
	*x = CheckpointInfo{}
	mi := &file_daemon_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckpointInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckpointInfo) ProtoMessage() {}

func (x *CheckpointInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckpointInfo.ProtoReflect.Descriptor instead.
func (*CheckpointInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{46}
}

func (x *CheckpointInfo) GetCheckpointId() string {
	if x != nil {
		return x.CheckpointId
	}
	return ""
}

func (x *CheckpointInfo) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *CheckpointInfo) GetCompletedNodes() int32 {
	if x != nil {
		return x.CompletedNodes
	}
	return 0
}

func (x *CheckpointInfo) GetTotalNodes() int32 {
	if x != nil {
		return x.TotalNodes
	}
	return 0
}

func (x *CheckpointInfo) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *CheckpointInfo) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

// ExecuteToolRequest executes a tool via the Tool Executor Service.
type ExecuteToolRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the tool name to execute
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// input is the typed input parameters for the tool
	Input *proto.TypedMap `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	// timeout_ms is the execution timeout in milliseconds (0 = default 5 minutes)
	TimeoutMs     int64 `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteToolRequest) Reset() {
	*x = ExecuteToolRequest{}
	mi := &file_daemon_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteToolRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteToolRequest) ProtoMessage() {}

func (x *ExecuteToolRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteToolRequest.ProtoReflect.Descriptor instead.
func (*ExecuteToolRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{47}
}

func (x *ExecuteToolRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ExecuteToolRequest) GetInput() *proto.TypedMap {
	if x != nil {
		return x.Input
	}
	return nil
}

func (x *ExecuteToolRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// ExecuteToolResponse returns the result of tool execution.
type ExecuteToolResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the tool executed successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// output is the typed output from the tool (if success)
	Output *proto.TypedValue `protobuf:"bytes,2,opt,name=output,proto3" json:"output,omitempty"`
	// error is the error message (if !success)
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// duration_ms is the actual execution duration in milliseconds
	DurationMs    int64 `protobuf:"varint,4,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteToolResponse) Reset() {
	*x = ExecuteToolResponse{}
	mi := &file_daemon_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteToolResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteToolResponse) ProtoMessage() {}

func (x *ExecuteToolResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteToolResponse.ProtoReflect.Descriptor instead.
func (*ExecuteToolResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{48}
}

func (x *ExecuteToolResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ExecuteToolResponse) GetOutput() *proto.TypedValue {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *ExecuteToolResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ExecuteToolResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// GetAvailableToolsRequest queries available tools from the Tool Executor Service.
type GetAvailableToolsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAvailableToolsRequest) Reset() {
	*x = GetAvailableToolsRequest{}
	mi := &file_daemon_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAvailableToolsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAvailableToolsRequest) ProtoMessage() {}

func (x *GetAvailableToolsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAvailableToolsRequest.ProtoReflect.Descriptor instead.
func (*GetAvailableToolsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{49}
}

// GetAvailableToolsResponse returns all available tools with their capabilities.
type GetAvailableToolsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tools is the list of available tools with detailed information
	Tools         []*AvailableToolInfo `protobuf:"bytes,1,rep,name=tools,proto3" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAvailableToolsResponse) Reset() {
	*x = GetAvailableToolsResponse{}
	mi := &file_daemon_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAvailableToolsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAvailableToolsResponse) ProtoMessage() {}

func (x *GetAvailableToolsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAvailableToolsResponse.ProtoReflect.Descriptor instead.
func (*GetAvailableToolsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{50}
}

func (x *GetAvailableToolsResponse) GetTools() []*AvailableToolInfo {
	if x != nil {
		return x.Tools
	}
	return nil
}

// AvailableToolInfo describes a tool's capabilities and execution metrics.
// This is distinct from ToolInfo which represents registry information.
type AvailableToolInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the tool name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version is the tool version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// description is the tool description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// tags are tool categorization tags
	Tags []string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	// input_schema_json is the JSON-encoded JSON Schema for tool input
	InputSchemaJson string `protobuf:"bytes,5,opt,name=input_schema_json,json=inputSchemaJson,proto3" json:"input_schema_json,omitempty"`
	// output_schema_json is the JSON-encoded JSON Schema for tool output
	OutputSchemaJson string `protobuf:"bytes,6,opt,name=output_schema_json,json=outputSchemaJson,proto3" json:"output_schema_json,omitempty"`
	// status is the tool readiness status ("ready", "schema-unknown", "error")
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// error_message is non-empty if status is "error"
	ErrorMessage string `protobuf:"bytes,8,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// metrics contains execution statistics for this tool
	Metrics *ToolExecutionMetrics `protobuf:"bytes,9,opt,name=metrics,proto3" json:"metrics,omitempty"`
	// input_schema is the structured input schema with taxonomy support (new in v0.12.0)
	InputSchema *JSONSchemaNode `protobuf:"bytes,10,opt,name=input_schema,json=inputSchema,proto3" json:"input_schema,omitempty"`
	// output_schema is the structured output schema with taxonomy support (new in v0.12.0)
	OutputSchema  *JSONSchemaNode `protobuf:"bytes,11,opt,name=output_schema,json=outputSchema,proto3" json:"output_schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AvailableToolInfo) Reset() {
	*x = AvailableToolInfo{}
	mi := &file_daemon_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailableToolInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailableToolInfo) ProtoMessage() {}

func (x *AvailableToolInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailableToolInfo.ProtoReflect.Descriptor instead.
func (*AvailableToolInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{51}
}

func (x *AvailableToolInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AvailableToolInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AvailableToolInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AvailableToolInfo) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *AvailableToolInfo) GetInputSchemaJson() string {
	if x != nil {
		return x.InputSchemaJson
	}
	return ""
}

func (x *AvailableToolInfo) GetOutputSchemaJson() string {
	if x != nil {
		return x.OutputSchemaJson
	}
	return ""
}

func (x *AvailableToolInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AvailableToolInfo) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *AvailableToolInfo) GetMetrics() *ToolExecutionMetrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

func (x *AvailableToolInfo) GetInputSchema() *JSONSchemaNode {
	if x != nil {
		return x.InputSchema
	}
	return nil
}

func (x *AvailableToolInfo) GetOutputSchema() *JSONSchemaNode {
	if x != nil {
		return x.OutputSchema
	}
	return nil
}

// ToolExecutionMetrics tracks execution statistics for a tool.
type ToolExecutionMetrics struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// total_calls is the total number of executions
	TotalCalls int64 `protobuf:"varint,1,opt,name=total_calls,json=totalCalls,proto3" json:"total_calls,omitempty"`
	// success_calls is the number of successful executions
	SuccessCalls int64 `protobuf:"varint,2,opt,name=success_calls,json=successCalls,proto3" json:"success_calls,omitempty"`
	// failed_calls is the number of failed executions
	FailedCalls int64 `protobuf:"varint,3,opt,name=failed_calls,json=failedCalls,proto3" json:"failed_calls,omitempty"`
	// avg_duration_ms is the average execution duration in milliseconds
	AvgDurationMs int64 `protobuf:"varint,4,opt,name=avg_duration_ms,json=avgDurationMs,proto3" json:"avg_duration_ms,omitempty"`
	// last_executed_at is the Unix timestamp in milliseconds of the last execution
	LastExecutedAt int64 `protobuf:"varint,5,opt,name=last_executed_at,json=lastExecutedAt,proto3" json:"last_executed_at,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ToolExecutionMetrics) Reset() {
	*x = ToolExecutionMetrics{}
	mi := &file_daemon_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolExecutionMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolExecutionMetrics) ProtoMessage() {}

func (x *ToolExecutionMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolExecutionMetrics.ProtoReflect.Descriptor instead.
func (*ToolExecutionMetrics) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{52}
}

func (x *ToolExecutionMetrics) GetTotalCalls() int64 {
	if x != nil {
		return x.TotalCalls
	}
	return 0
}

func (x *ToolExecutionMetrics) GetSuccessCalls() int64 {
	if x != nil {
		return x.SuccessCalls
	}
	return 0
}

func (x *ToolExecutionMetrics) GetFailedCalls() int64 {
	if x != nil {
		return x.FailedCalls
	}
	return 0
}

func (x *ToolExecutionMetrics) GetAvgDurationMs() int64 {
	if x != nil {
		return x.AvgDurationMs
	}
	return 0
}

func (x *ToolExecutionMetrics) GetLastExecutedAt() int64 {
	if x != nil {
		return x.LastExecutedAt
	}
	return 0
}

// JSONSchemaNode represents a JSON schema with optional taxonomy mapping.
// This mirrors sdk/schema.JSON for gRPC transport with taxonomy support.
type JSONSchemaNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// type is the JSON schema type (string, integer, number, boolean, array, object)
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// description is the human-readable description of this schema node
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// properties maps property names to their schemas (for object types)
	Properties map[string]*JSONSchemaNode `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// required lists required property names (for object types)
	Required []string `protobuf:"bytes,4,rep,name=required,proto3" json:"required,omitempty"`
	// items defines the schema for array elements (for array types)
	Items *JSONSchemaNode `protobuf:"bytes,5,opt,name=items,proto3" json:"items,omitempty"`
	// enum_values lists allowed values (for enum constraints)
	EnumValues []string `protobuf:"bytes,6,rep,name=enum_values,json=enumValues,proto3" json:"enum_values,omitempty"`
	// default_value is the JSON-encoded default value
	DefaultValue string `protobuf:"bytes,7,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	// minimum is the minimum numeric value constraint
	Minimum float64 `protobuf:"fixed64,8,opt,name=minimum,proto3" json:"minimum,omitempty"`
	// maximum is the maximum numeric value constraint
	Maximum float64 `protobuf:"fixed64,9,opt,name=maximum,proto3" json:"maximum,omitempty"`
	// min_length is the minimum string length constraint
	MinLength int32 `protobuf:"varint,10,opt,name=min_length,json=minLength,proto3" json:"min_length,omitempty"`
	// max_length is the maximum string length constraint
	MaxLength int32 `protobuf:"varint,11,opt,name=max_length,json=maxLength,proto3" json:"max_length,omitempty"`
	// pattern is the regex pattern constraint for strings
	Pattern string `protobuf:"bytes,12,opt,name=pattern,proto3" json:"pattern,omitempty"`
	// format is the string format hint (e.g., uri, email, date-time, uuid)
	Format string `protobuf:"bytes,13,opt,name=format,proto3" json:"format,omitempty"`
	// ref is the JSON schema $ref reference
	Ref string `protobuf:"bytes,14,opt,name=ref,proto3" json:"ref,omitempty"`
	// taxonomy defines how this schema node maps to a graph node (the key feature)
	Taxonomy      *TaxonomyMapping `protobuf:"bytes,15,opt,name=taxonomy,proto3" json:"taxonomy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JSONSchemaNode) Reset() {
	*x = JSONSchemaNode{}
	mi := &file_daemon_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JSONSchemaNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JSONSchemaNode) ProtoMessage() {}

func (x *JSONSchemaNode) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JSONSchemaNode.ProtoReflect.Descriptor instead.
func (*JSONSchemaNode) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{53}
}

func (x *JSONSchemaNode) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *JSONSchemaNode) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *JSONSchemaNode) GetProperties() map[string]*JSONSchemaNode {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *JSONSchemaNode) GetRequired() []string {
	if x != nil {
		return x.Required
	}
	return nil
}

func (x *JSONSchemaNode) GetItems() *JSONSchemaNode {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *JSONSchemaNode) GetEnumValues() []string {
	if x != nil {
		return x.EnumValues
	}
	return nil
}

func (x *JSONSchemaNode) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

func (x *JSONSchemaNode) GetMinimum() float64 {
	if x != nil {
		return x.Minimum
	}
	return 0
}

func (x *JSONSchemaNode) GetMaximum() float64 {
	if x != nil {
		return x.Maximum
	}
	return 0
}

func (x *JSONSchemaNode) GetMinLength() int32 {
	if x != nil {
		return x.MinLength
	}
	return 0
}

func (x *JSONSchemaNode) GetMaxLength() int32 {
	if x != nil {
		return x.MaxLength
	}
	return 0
}

func (x *JSONSchemaNode) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *JSONSchemaNode) GetFormat() string {
	if x != nil {
		return x.Format
	}
	return ""
}

func (x *JSONSchemaNode) GetRef() string {
	if x != nil {
		return x.Ref
	}
	return ""
}

func (x *JSONSchemaNode) GetTaxonomy() *TaxonomyMapping {
	if x != nil {
		return x.Taxonomy
	}
	return nil
}

// TaxonomyMapping defines how tool output maps to graph nodes and relationships.
// It specifies the node type, identifying properties for deterministic ID generation,
// property mappings, and relationships to create when processing data.
type TaxonomyMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// node_type is the type of node to create in the graph (e.g., "host", "port", "vulnerability")
	NodeType string `protobuf:"bytes,1,opt,name=node_type,json=nodeType,proto3" json:"node_type,omitempty"`
	// identifying_properties maps property names to JSONPath expressions for deterministic ID generation
	IdentifyingProperties map[string]string `protobuf:"bytes,2,rep,name=identifying_properties,json=identifyingProperties,proto3" json:"identifying_properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// properties maps source data fields to node properties
	Properties []*PropertyMapping `protobuf:"bytes,3,rep,name=properties,proto3" json:"properties,omitempty"`
	// relationships defines edges to create to/from this node
	Relationships []*RelationshipMapping `protobuf:"bytes,4,rep,name=relationships,proto3" json:"relationships,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TaxonomyMapping) Reset() {
	*x = TaxonomyMapping{}
	mi := &file_daemon_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TaxonomyMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TaxonomyMapping) ProtoMessage() {}

func (x *TaxonomyMapping) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TaxonomyMapping.ProtoReflect.Descriptor instead.
func (*TaxonomyMapping) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{54}
}

func (x *TaxonomyMapping) GetNodeType() string {
	if x != nil {
		return x.NodeType
	}
	return ""
}

func (x *TaxonomyMapping) GetIdentifyingProperties() map[string]string {
	if x != nil {
		return x.IdentifyingProperties
	}
	return nil
}

func (x *TaxonomyMapping) GetProperties() []*PropertyMapping {
	if x != nil {
		return x.Properties
	}
	return nil
}

func (x *TaxonomyMapping) GetRelationships() []*RelationshipMapping {
	if x != nil {
		return x.Relationships
	}
	return nil
}

// PropertyMapping defines how to map a source field to a target node property.
// It supports default values and transformation functions.
type PropertyMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// source is the field name in the source data
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// target is the property name in the target node
	Target string `protobuf:"bytes,2,opt,name=target,proto3" json:"target,omitempty"`
	// default_value is the JSON-encoded default value if source is missing or empty
	DefaultValue string `protobuf:"bytes,3,opt,name=default_value,json=defaultValue,proto3" json:"default_value,omitempty"`
	// transform is a transformation function to apply (e.g., "lowercase", "uppercase", "trim")
	Transform     string `protobuf:"bytes,4,opt,name=transform,proto3" json:"transform,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PropertyMapping) Reset() {
	*x = PropertyMapping{}
	mi := &file_daemon_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PropertyMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PropertyMapping) ProtoMessage() {}

func (x *PropertyMapping) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PropertyMapping.ProtoReflect.Descriptor instead.
func (*PropertyMapping) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{55}
}

func (x *PropertyMapping) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *PropertyMapping) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *PropertyMapping) GetDefaultValue() string {
	if x != nil {
		return x.DefaultValue
	}
	return ""
}

func (x *PropertyMapping) GetTransform() string {
	if x != nil {
		return x.Transform
	}
	return ""
}

// NodeReference identifies a node by type and property mappings.
// Use type="self" to reference the current node being mapped.
type NodeReference struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// type is the node type (e.g., "host", "port") or "self" for current node
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// properties maps identifying property names to JSONPath expressions
	Properties    map[string]string `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeReference) Reset() {
	*x = NodeReference{}
	mi := &file_daemon_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeReference) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeReference) ProtoMessage() {}

func (x *NodeReference) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeReference.ProtoReflect.Descriptor instead.
func (*NodeReference) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{56}
}

func (x *NodeReference) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *NodeReference) GetProperties() map[string]string {
	if x != nil {
		return x.Properties
	}
	return nil
}

// RelationshipMapping defines a relationship to create between nodes.
// It supports conditional relationships and property mappings on the edge itself.
type RelationshipMapping struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// type is the relationship type (e.g., "HAS_PORT", "AFFECTS", "RUNS_ON")
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// from identifies the source node of the relationship (use type="self" for current node)
	From *NodeReference `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	// to identifies the target node of the relationship
	To *NodeReference `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// condition is an optional condition for creating this relationship
	Condition string `protobuf:"bytes,4,opt,name=condition,proto3" json:"condition,omitempty"`
	// rel_properties are property mappings for the relationship edge
	RelProperties []*PropertyMapping `protobuf:"bytes,5,rep,name=rel_properties,json=relProperties,proto3" json:"rel_properties,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RelationshipMapping) Reset() {
	*x = RelationshipMapping{}
	mi := &file_daemon_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RelationshipMapping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RelationshipMapping) ProtoMessage() {}

func (x *RelationshipMapping) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RelationshipMapping.ProtoReflect.Descriptor instead.
func (*RelationshipMapping) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{57}
}

func (x *RelationshipMapping) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *RelationshipMapping) GetFrom() *NodeReference {
	if x != nil {
		return x.From
	}
	return nil
}

func (x *RelationshipMapping) GetTo() *NodeReference {
	if x != nil {
		return x.To
	}
	return nil
}

func (x *RelationshipMapping) GetCondition() string {
	if x != nil {
		return x.Condition
	}
	return ""
}

func (x *RelationshipMapping) GetRelProperties() []*PropertyMapping {
	if x != nil {
		return x.RelProperties
	}
	return nil
}

// InstallComponentRequest requests installing a component from a Git repository.
type InstallComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// url is the Git repository URL to clone
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// branch is the Git branch to checkout (optional)
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	// tag is the Git tag to checkout (optional)
	Tag string `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
	// force indicates whether to reinstall if already exists
	Force bool `protobuf:"varint,5,opt,name=force,proto3" json:"force,omitempty"`
	// skip_build skips the build step after cloning
	SkipBuild bool `protobuf:"varint,6,opt,name=skip_build,json=skipBuild,proto3" json:"skip_build,omitempty"`
	// verbose enables detailed build output streaming
	Verbose       bool `protobuf:"varint,7,opt,name=verbose,proto3" json:"verbose,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallComponentRequest) Reset() {
	*x = InstallComponentRequest{}
	mi := &file_daemon_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallComponentRequest) ProtoMessage() {}

func (x *InstallComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallComponentRequest.ProtoReflect.Descriptor instead.
func (*InstallComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{58}
}

func (x *InstallComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *InstallComponentRequest) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *InstallComponentRequest) GetBranch() string {
	if x != nil {
		return x.Branch
	}
	return ""
}

func (x *InstallComponentRequest) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *InstallComponentRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *InstallComponentRequest) GetSkipBuild() bool {
	if x != nil {
		return x.SkipBuild
	}
	return false
}

func (x *InstallComponentRequest) GetVerbose() bool {
	if x != nil {
		return x.Verbose
	}
	return false
}

// InstallComponentResponse returns the result of installing a component.
type InstallComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was installed successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// name is the installed component name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the installed component version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// repo_path is the local repository path
	RepoPath string `protobuf:"bytes,4,opt,name=repo_path,json=repoPath,proto3" json:"repo_path,omitempty"`
	// bin_path is the path to the built binary (if built)
	BinPath string `protobuf:"bytes,5,opt,name=bin_path,json=binPath,proto3" json:"bin_path,omitempty"`
	// build_output contains build stdout/stderr (if verbose)
	BuildOutput string `protobuf:"bytes,6,opt,name=build_output,json=buildOutput,proto3" json:"build_output,omitempty"`
	// duration_ms is the total install time in milliseconds
	DurationMs int64 `protobuf:"varint,7,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,8,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallComponentResponse) Reset() {
	*x = InstallComponentResponse{}
	mi := &file_daemon_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallComponentResponse) ProtoMessage() {}

func (x *InstallComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallComponentResponse.ProtoReflect.Descriptor instead.
func (*InstallComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{59}
}

func (x *InstallComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *InstallComponentResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InstallComponentResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *InstallComponentResponse) GetRepoPath() string {
	if x != nil {
		return x.RepoPath
	}
	return ""
}

func (x *InstallComponentResponse) GetBinPath() string {
	if x != nil {
		return x.BinPath
	}
	return ""
}

func (x *InstallComponentResponse) GetBuildOutput() string {
	if x != nil {
		return x.BuildOutput
	}
	return ""
}

func (x *InstallComponentResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *InstallComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// InstallAllComponentRequest requests installing all components from a mono-repo.
type InstallAllComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// url is the Git repository URL to clone
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	// branch is the Git branch to checkout (optional)
	Branch string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	// tag is the Git tag to checkout (optional)
	Tag string `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
	// force indicates whether to reinstall if already exists
	Force bool `protobuf:"varint,5,opt,name=force,proto3" json:"force,omitempty"`
	// skip_build skips the build step after cloning
	SkipBuild bool `protobuf:"varint,6,opt,name=skip_build,json=skipBuild,proto3" json:"skip_build,omitempty"`
	// verbose enables detailed build output streaming
	Verbose       bool `protobuf:"varint,7,opt,name=verbose,proto3" json:"verbose,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallAllComponentRequest) Reset() {
	*x = InstallAllComponentRequest{}
	mi := &file_daemon_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallAllComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallAllComponentRequest) ProtoMessage() {}

func (x *InstallAllComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallAllComponentRequest.ProtoReflect.Descriptor instead.
func (*InstallAllComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{60}
}

func (x *InstallAllComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *InstallAllComponentRequest) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *InstallAllComponentRequest) GetBranch() string {
	if x != nil {
		return x.Branch
	}
	return ""
}

func (x *InstallAllComponentRequest) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *InstallAllComponentRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *InstallAllComponentRequest) GetSkipBuild() bool {
	if x != nil {
		return x.SkipBuild
	}
	return false
}

func (x *InstallAllComponentRequest) GetVerbose() bool {
	if x != nil {
		return x.Verbose
	}
	return false
}

// InstallAllComponentResponse returns the result of installing multiple components.
type InstallAllComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the operation completed (even with partial failures)
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// components_found is the total number of components discovered
	ComponentsFound int32 `protobuf:"varint,2,opt,name=components_found,json=componentsFound,proto3" json:"components_found,omitempty"`
	// successful_count is the number of successfully installed components
	SuccessfulCount int32 `protobuf:"varint,3,opt,name=successful_count,json=successfulCount,proto3" json:"successful_count,omitempty"`
	// skipped_count is the number of components skipped (already installed)
	SkippedCount int32 `protobuf:"varint,4,opt,name=skipped_count,json=skippedCount,proto3" json:"skipped_count,omitempty"`
	// failed_count is the number of components that failed to install
	FailedCount int32 `protobuf:"varint,5,opt,name=failed_count,json=failedCount,proto3" json:"failed_count,omitempty"`
	// successful contains details of successfully installed components
	Successful []*InstallAllResultItem `protobuf:"bytes,6,rep,name=successful,proto3" json:"successful,omitempty"`
	// skipped contains details of skipped components
	Skipped []*InstallAllResultItem `protobuf:"bytes,7,rep,name=skipped,proto3" json:"skipped,omitempty"`
	// failed contains details of failed components
	Failed []*InstallAllFailedItem `protobuf:"bytes,8,rep,name=failed,proto3" json:"failed,omitempty"`
	// duration_ms is the total installation time in milliseconds
	DurationMs int64 `protobuf:"varint,9,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,10,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallAllComponentResponse) Reset() {
	*x = InstallAllComponentResponse{}
	mi := &file_daemon_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallAllComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallAllComponentResponse) ProtoMessage() {}

func (x *InstallAllComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallAllComponentResponse.ProtoReflect.Descriptor instead.
func (*InstallAllComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{61}
}

func (x *InstallAllComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *InstallAllComponentResponse) GetComponentsFound() int32 {
	if x != nil {
		return x.ComponentsFound
	}
	return 0
}

func (x *InstallAllComponentResponse) GetSuccessfulCount() int32 {
	if x != nil {
		return x.SuccessfulCount
	}
	return 0
}

func (x *InstallAllComponentResponse) GetSkippedCount() int32 {
	if x != nil {
		return x.SkippedCount
	}
	return 0
}

func (x *InstallAllComponentResponse) GetFailedCount() int32 {
	if x != nil {
		return x.FailedCount
	}
	return 0
}

func (x *InstallAllComponentResponse) GetSuccessful() []*InstallAllResultItem {
	if x != nil {
		return x.Successful
	}
	return nil
}

func (x *InstallAllComponentResponse) GetSkipped() []*InstallAllResultItem {
	if x != nil {
		return x.Skipped
	}
	return nil
}

func (x *InstallAllComponentResponse) GetFailed() []*InstallAllFailedItem {
	if x != nil {
		return x.Failed
	}
	return nil
}

func (x *InstallAllComponentResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *InstallAllComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// InstallAllResultItem represents a successful or skipped component installation.
type InstallAllResultItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the component name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version is the component version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// path is the local repository path
	Path          string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallAllResultItem) Reset() {
	*x = InstallAllResultItem{}
	mi := &file_daemon_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallAllResultItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallAllResultItem) ProtoMessage() {}

func (x *InstallAllResultItem) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallAllResultItem.ProtoReflect.Descriptor instead.
func (*InstallAllResultItem) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{62}
}

func (x *InstallAllResultItem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InstallAllResultItem) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *InstallAllResultItem) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

// InstallAllFailedItem represents a failed component installation.
type InstallAllFailedItem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the component name (if available)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// path is the local path where the failure occurred
	Path string `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	// error is the error message
	Error         string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallAllFailedItem) Reset() {
	*x = InstallAllFailedItem{}
	mi := &file_daemon_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallAllFailedItem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallAllFailedItem) ProtoMessage() {}

func (x *InstallAllFailedItem) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallAllFailedItem.ProtoReflect.Descriptor instead.
func (*InstallAllFailedItem) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{63}
}

func (x *InstallAllFailedItem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InstallAllFailedItem) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *InstallAllFailedItem) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

// UninstallComponentRequest requests removing a component.
type UninstallComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name to uninstall
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// force indicates whether to uninstall even if running
	Force         bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UninstallComponentRequest) Reset() {
	*x = UninstallComponentRequest{}
	mi := &file_daemon_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UninstallComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UninstallComponentRequest) ProtoMessage() {}

func (x *UninstallComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UninstallComponentRequest.ProtoReflect.Descriptor instead.
func (*UninstallComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{64}
}

func (x *UninstallComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *UninstallComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UninstallComponentRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// UninstallComponentResponse returns the result of uninstalling a component.
type UninstallComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was uninstalled successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UninstallComponentResponse) Reset() {
	*x = UninstallComponentResponse{}
	mi := &file_daemon_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UninstallComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UninstallComponentResponse) ProtoMessage() {}

func (x *UninstallComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UninstallComponentResponse.ProtoReflect.Descriptor instead.
func (*UninstallComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{65}
}

func (x *UninstallComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UninstallComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// UpdateComponentRequest requests updating a component to the latest version.
type UpdateComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name to update
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// restart indicates whether to restart if running
	Restart bool `protobuf:"varint,3,opt,name=restart,proto3" json:"restart,omitempty"`
	// skip_build skips the rebuild step after pulling
	SkipBuild bool `protobuf:"varint,4,opt,name=skip_build,json=skipBuild,proto3" json:"skip_build,omitempty"`
	// verbose enables detailed build output streaming
	Verbose       bool `protobuf:"varint,5,opt,name=verbose,proto3" json:"verbose,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateComponentRequest) Reset() {
	*x = UpdateComponentRequest{}
	mi := &file_daemon_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateComponentRequest) ProtoMessage() {}

func (x *UpdateComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateComponentRequest.ProtoReflect.Descriptor instead.
func (*UpdateComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{66}
}

func (x *UpdateComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *UpdateComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateComponentRequest) GetRestart() bool {
	if x != nil {
		return x.Restart
	}
	return false
}

func (x *UpdateComponentRequest) GetSkipBuild() bool {
	if x != nil {
		return x.SkipBuild
	}
	return false
}

func (x *UpdateComponentRequest) GetVerbose() bool {
	if x != nil {
		return x.Verbose
	}
	return false
}

// UpdateComponentResponse returns the result of updating a component.
type UpdateComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was updated successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// updated indicates if there were actually changes (false if already latest)
	Updated bool `protobuf:"varint,2,opt,name=updated,proto3" json:"updated,omitempty"`
	// old_version is the previous version
	OldVersion string `protobuf:"bytes,3,opt,name=old_version,json=oldVersion,proto3" json:"old_version,omitempty"`
	// new_version is the new version after update
	NewVersion string `protobuf:"bytes,4,opt,name=new_version,json=newVersion,proto3" json:"new_version,omitempty"`
	// build_output contains build stdout/stderr (if verbose)
	BuildOutput string `protobuf:"bytes,5,opt,name=build_output,json=buildOutput,proto3" json:"build_output,omitempty"`
	// duration_ms is the total update time in milliseconds
	DurationMs int64 `protobuf:"varint,6,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateComponentResponse) Reset() {
	*x = UpdateComponentResponse{}
	mi := &file_daemon_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateComponentResponse) ProtoMessage() {}

func (x *UpdateComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateComponentResponse.ProtoReflect.Descriptor instead.
func (*UpdateComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{67}
}

func (x *UpdateComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UpdateComponentResponse) GetUpdated() bool {
	if x != nil {
		return x.Updated
	}
	return false
}

func (x *UpdateComponentResponse) GetOldVersion() string {
	if x != nil {
		return x.OldVersion
	}
	return ""
}

func (x *UpdateComponentResponse) GetNewVersion() string {
	if x != nil {
		return x.NewVersion
	}
	return ""
}

func (x *UpdateComponentResponse) GetBuildOutput() string {
	if x != nil {
		return x.BuildOutput
	}
	return ""
}

func (x *UpdateComponentResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *UpdateComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// BuildComponentRequest requests rebuilding a component from source.
type BuildComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name to build
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildComponentRequest) Reset() {
	*x = BuildComponentRequest{}
	mi := &file_daemon_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildComponentRequest) ProtoMessage() {}

func (x *BuildComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildComponentRequest.ProtoReflect.Descriptor instead.
func (*BuildComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{68}
}

func (x *BuildComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *BuildComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// BuildComponentResponse returns the result of building a component.
type BuildComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the build was successful
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// stdout contains the build standard output
	Stdout string `protobuf:"bytes,2,opt,name=stdout,proto3" json:"stdout,omitempty"`
	// stderr contains the build standard error
	Stderr string `protobuf:"bytes,3,opt,name=stderr,proto3" json:"stderr,omitempty"`
	// duration_ms is the build time in milliseconds
	DurationMs int64 `protobuf:"varint,4,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BuildComponentResponse) Reset() {
	*x = BuildComponentResponse{}
	mi := &file_daemon_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BuildComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BuildComponentResponse) ProtoMessage() {}

func (x *BuildComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BuildComponentResponse.ProtoReflect.Descriptor instead.
func (*BuildComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{69}
}

func (x *BuildComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *BuildComponentResponse) GetStdout() string {
	if x != nil {
		return x.Stdout
	}
	return ""
}

func (x *BuildComponentResponse) GetStderr() string {
	if x != nil {
		return x.Stderr
	}
	return ""
}

func (x *BuildComponentResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *BuildComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ShowComponentRequest requests detailed information about a component.
type ShowComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name to show
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShowComponentRequest) Reset() {
	*x = ShowComponentRequest{}
	mi := &file_daemon_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShowComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShowComponentRequest) ProtoMessage() {}

func (x *ShowComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShowComponentRequest.ProtoReflect.Descriptor instead.
func (*ShowComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{70}
}

func (x *ShowComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *ShowComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// ShowComponentResponse returns detailed component information.
type ShowComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was found
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// name is the component name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the component version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// kind is the component kind
	Kind string `protobuf:"bytes,4,opt,name=kind,proto3" json:"kind,omitempty"`
	// status is the component status (installed, running, stopped)
	Status string `protobuf:"bytes,5,opt,name=status,proto3" json:"status,omitempty"`
	// source is the Git repository URL
	Source string `protobuf:"bytes,6,opt,name=source,proto3" json:"source,omitempty"`
	// repo_path is the local repository path
	RepoPath string `protobuf:"bytes,7,opt,name=repo_path,json=repoPath,proto3" json:"repo_path,omitempty"`
	// bin_path is the path to the binary
	BinPath string `protobuf:"bytes,8,opt,name=bin_path,json=binPath,proto3" json:"bin_path,omitempty"`
	// port is the listening port (if running)
	Port int32 `protobuf:"varint,9,opt,name=port,proto3" json:"port,omitempty"`
	// pid is the process ID (if running)
	Pid int32 `protobuf:"varint,10,opt,name=pid,proto3" json:"pid,omitempty"`
	// created_at is when the component was installed (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,11,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// updated_at is when the component was last updated (Unix timestamp)
	UpdatedAt int64 `protobuf:"varint,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// started_at is when the component was started (Unix timestamp, 0 if not running)
	StartedAt int64 `protobuf:"varint,13,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// stopped_at is when the component was stopped (Unix timestamp, 0 if never stopped)
	StoppedAt int64 `protobuf:"varint,14,opt,name=stopped_at,json=stoppedAt,proto3" json:"stopped_at,omitempty"`
	// manifest_info contains manifest details (JSON-encoded)
	ManifestInfo string `protobuf:"bytes,15,opt,name=manifest_info,json=manifestInfo,proto3" json:"manifest_info,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,16,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShowComponentResponse) Reset() {
	*x = ShowComponentResponse{}
	mi := &file_daemon_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShowComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShowComponentResponse) ProtoMessage() {}

func (x *ShowComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShowComponentResponse.ProtoReflect.Descriptor instead.
func (*ShowComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{71}
}

func (x *ShowComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ShowComponentResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ShowComponentResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ShowComponentResponse) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *ShowComponentResponse) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *ShowComponentResponse) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *ShowComponentResponse) GetRepoPath() string {
	if x != nil {
		return x.RepoPath
	}
	return ""
}

func (x *ShowComponentResponse) GetBinPath() string {
	if x != nil {
		return x.BinPath
	}
	return ""
}

func (x *ShowComponentResponse) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *ShowComponentResponse) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *ShowComponentResponse) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *ShowComponentResponse) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

func (x *ShowComponentResponse) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *ShowComponentResponse) GetStoppedAt() int64 {
	if x != nil {
		return x.StoppedAt
	}
	return 0
}

func (x *ShowComponentResponse) GetManifestInfo() string {
	if x != nil {
		return x.ManifestInfo
	}
	return ""
}

func (x *ShowComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// GetComponentLogsRequest requests log entries for a component.
type GetComponentLogsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name to get logs for
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// follow indicates whether to stream logs continuously
	Follow bool `protobuf:"varint,3,opt,name=follow,proto3" json:"follow,omitempty"`
	// lines is the number of lines to return (0 = all, default 50)
	Lines         int32 `protobuf:"varint,4,opt,name=lines,proto3" json:"lines,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetComponentLogsRequest) Reset() {
	*x = GetComponentLogsRequest{}
	mi := &file_daemon_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetComponentLogsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetComponentLogsRequest) ProtoMessage() {}

func (x *GetComponentLogsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetComponentLogsRequest.ProtoReflect.Descriptor instead.
func (*GetComponentLogsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{72}
}

func (x *GetComponentLogsRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *GetComponentLogsRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetComponentLogsRequest) GetFollow() bool {
	if x != nil {
		return x.Follow
	}
	return false
}

func (x *GetComponentLogsRequest) GetLines() int32 {
	if x != nil {
		return x.Lines
	}
	return 0
}

// LogEntry represents a single log entry from a component.
type LogEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// timestamp is when the log entry was created (Unix timestamp)
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// level is the log level (debug, info, warn, error)
	Level string `protobuf:"bytes,2,opt,name=level,proto3" json:"level,omitempty"`
	// message is the log message
	Message string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// fields contains additional structured log fields (typed map)
	Fields        *proto.TypedMap `protobuf:"bytes,4,opt,name=fields,proto3" json:"fields,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogEntry) Reset() {
	*x = LogEntry{}
	mi := &file_daemon_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogEntry) ProtoMessage() {}

func (x *LogEntry) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogEntry.ProtoReflect.Descriptor instead.
func (*LogEntry) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{73}
}

func (x *LogEntry) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *LogEntry) GetLevel() string {
	if x != nil {
		return x.Level
	}
	return ""
}

func (x *LogEntry) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *LogEntry) GetFields() *proto.TypedMap {
	if x != nil {
		return x.Fields
	}
	return nil
}

// InstallMissionRequest requests installing a mission from a Git repository.
type InstallMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// url is the Git repository URL to clone
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	// branch is the Git branch to checkout (optional)
	Branch string `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	// tag is the Git tag to checkout (optional)
	Tag string `protobuf:"bytes,3,opt,name=tag,proto3" json:"tag,omitempty"`
	// force indicates whether to reinstall if already exists
	Force bool `protobuf:"varint,4,opt,name=force,proto3" json:"force,omitempty"`
	// yes auto-confirms dependency installation prompts
	Yes bool `protobuf:"varint,5,opt,name=yes,proto3" json:"yes,omitempty"`
	// timeout_ms is the installation timeout in milliseconds (0 = default 5 minutes)
	TimeoutMs     int64 `protobuf:"varint,6,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallMissionRequest) Reset() {
	*x = InstallMissionRequest{}
	mi := &file_daemon_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallMissionRequest) ProtoMessage() {}

func (x *InstallMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallMissionRequest.ProtoReflect.Descriptor instead.
func (*InstallMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{74}
}

func (x *InstallMissionRequest) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

func (x *InstallMissionRequest) GetBranch() string {
	if x != nil {
		return x.Branch
	}
	return ""
}

func (x *InstallMissionRequest) GetTag() string {
	if x != nil {
		return x.Tag
	}
	return ""
}

func (x *InstallMissionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *InstallMissionRequest) GetYes() bool {
	if x != nil {
		return x.Yes
	}
	return false
}

func (x *InstallMissionRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// InstallMissionResponse returns the result of installing a mission.
type InstallMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the mission was installed successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// name is the installed mission name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the installed mission version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// path is the local installation path
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// dependencies contains information about installed dependencies
	Dependencies []*InstalledDependency `protobuf:"bytes,5,rep,name=dependencies,proto3" json:"dependencies,omitempty"`
	// duration_ms is the total install time in milliseconds
	DurationMs int64 `protobuf:"varint,6,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,7,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstallMissionResponse) Reset() {
	*x = InstallMissionResponse{}
	mi := &file_daemon_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstallMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstallMissionResponse) ProtoMessage() {}

func (x *InstallMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstallMissionResponse.ProtoReflect.Descriptor instead.
func (*InstallMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{75}
}

func (x *InstallMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *InstallMissionResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InstallMissionResponse) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *InstallMissionResponse) GetPath() string {
	if x != nil {
		return x.Path
	}
	return ""
}

func (x *InstallMissionResponse) GetDependencies() []*InstalledDependency {
	if x != nil {
		return x.Dependencies
	}
	return nil
}

func (x *InstallMissionResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *InstallMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// InstalledDependency represents a dependency that was installed.
type InstalledDependency struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// type is the dependency type (agent, tool, plugin)
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// name is the dependency name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// already_installed indicates if it was already installed
	AlreadyInstalled bool `protobuf:"varint,3,opt,name=already_installed,json=alreadyInstalled,proto3" json:"already_installed,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *InstalledDependency) Reset() {
	*x = InstalledDependency{}
	mi := &file_daemon_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstalledDependency) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstalledDependency) ProtoMessage() {}

func (x *InstalledDependency) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstalledDependency.ProtoReflect.Descriptor instead.
func (*InstalledDependency) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{76}
}

func (x *InstalledDependency) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *InstalledDependency) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InstalledDependency) GetAlreadyInstalled() bool {
	if x != nil {
		return x.AlreadyInstalled
	}
	return false
}

// UninstallMissionRequest requests removing an installed mission.
type UninstallMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the mission name to uninstall
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// force indicates whether to skip confirmation
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UninstallMissionRequest) Reset() {
	*x = UninstallMissionRequest{}
	mi := &file_daemon_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UninstallMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UninstallMissionRequest) ProtoMessage() {}

func (x *UninstallMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UninstallMissionRequest.ProtoReflect.Descriptor instead.
func (*UninstallMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{77}
}

func (x *UninstallMissionRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UninstallMissionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// UninstallMissionResponse returns the result of uninstalling a mission.
type UninstallMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the mission was uninstalled successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UninstallMissionResponse) Reset() {
	*x = UninstallMissionResponse{}
	mi := &file_daemon_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UninstallMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UninstallMissionResponse) ProtoMessage() {}

func (x *UninstallMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UninstallMissionResponse.ProtoReflect.Descriptor instead.
func (*UninstallMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{78}
}

func (x *UninstallMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UninstallMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ListMissionDefinitionsRequest queries installed mission definitions.
type ListMissionDefinitionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// limit restricts the number of results (0 = all)
	Limit int32 `protobuf:"varint,1,opt,name=limit,proto3" json:"limit,omitempty"`
	// offset is the pagination offset
	Offset        int32 `protobuf:"varint,2,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMissionDefinitionsRequest) Reset() {
	*x = ListMissionDefinitionsRequest{}
	mi := &file_daemon_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMissionDefinitionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMissionDefinitionsRequest) ProtoMessage() {}

func (x *ListMissionDefinitionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMissionDefinitionsRequest.ProtoReflect.Descriptor instead.
func (*ListMissionDefinitionsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{79}
}

func (x *ListMissionDefinitionsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListMissionDefinitionsRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// ListMissionDefinitionsResponse returns installed mission definitions.
type ListMissionDefinitionsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// missions is the list of installed mission definitions
	Missions []*MissionDefinitionInfo `protobuf:"bytes,1,rep,name=missions,proto3" json:"missions,omitempty"`
	// total is the total count of mission definitions (for pagination)
	Total         int32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMissionDefinitionsResponse) Reset() {
	*x = ListMissionDefinitionsResponse{}
	mi := &file_daemon_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMissionDefinitionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMissionDefinitionsResponse) ProtoMessage() {}

func (x *ListMissionDefinitionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMissionDefinitionsResponse.ProtoReflect.Descriptor instead.
func (*ListMissionDefinitionsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{80}
}

func (x *ListMissionDefinitionsResponse) GetMissions() []*MissionDefinitionInfo {
	if x != nil {
		return x.Missions
	}
	return nil
}

func (x *ListMissionDefinitionsResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// MissionDefinitionInfo describes an installed mission definition.
type MissionDefinitionInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the mission name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version is the mission version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// description is the mission description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// source is the Git repository URL
	Source string `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`
	// installed_at is when the mission was installed (Unix timestamp)
	InstalledAt int64 `protobuf:"varint,5,opt,name=installed_at,json=installedAt,proto3" json:"installed_at,omitempty"`
	// updated_at is when the mission was last updated (Unix timestamp)
	UpdatedAt int64 `protobuf:"varint,6,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// node_count is the number of nodes in the mission
	NodeCount     int32 `protobuf:"varint,7,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionDefinitionInfo) Reset() {
	*x = MissionDefinitionInfo{}
	mi := &file_daemon_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionDefinitionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionDefinitionInfo) ProtoMessage() {}

func (x *MissionDefinitionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionDefinitionInfo.ProtoReflect.Descriptor instead.
func (*MissionDefinitionInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{81}
}

func (x *MissionDefinitionInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MissionDefinitionInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *MissionDefinitionInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *MissionDefinitionInfo) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *MissionDefinitionInfo) GetInstalledAt() int64 {
	if x != nil {
		return x.InstalledAt
	}
	return 0
}

func (x *MissionDefinitionInfo) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

func (x *MissionDefinitionInfo) GetNodeCount() int32 {
	if x != nil {
		return x.NodeCount
	}
	return 0
}

// UpdateMissionRequest requests updating a mission to the latest version.
type UpdateMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the mission name to update
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// timeout_ms is the update timeout in milliseconds (0 = default 5 minutes)
	TimeoutMs     int64 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateMissionRequest) Reset() {
	*x = UpdateMissionRequest{}
	mi := &file_daemon_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateMissionRequest) ProtoMessage() {}

func (x *UpdateMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateMissionRequest.ProtoReflect.Descriptor instead.
func (*UpdateMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{82}
}

func (x *UpdateMissionRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateMissionRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// UpdateMissionResponse returns the result of updating a mission.
type UpdateMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the mission was updated successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// updated indicates if there were actually changes (false if already latest)
	Updated bool `protobuf:"varint,2,opt,name=updated,proto3" json:"updated,omitempty"`
	// old_version is the previous version
	OldVersion string `protobuf:"bytes,3,opt,name=old_version,json=oldVersion,proto3" json:"old_version,omitempty"`
	// new_version is the new version after update
	NewVersion string `protobuf:"bytes,4,opt,name=new_version,json=newVersion,proto3" json:"new_version,omitempty"`
	// duration_ms is the total update time in milliseconds
	DurationMs int64 `protobuf:"varint,5,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,6,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateMissionResponse) Reset() {
	*x = UpdateMissionResponse{}
	mi := &file_daemon_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateMissionResponse) ProtoMessage() {}

func (x *UpdateMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateMissionResponse.ProtoReflect.Descriptor instead.
func (*UpdateMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{83}
}

func (x *UpdateMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *UpdateMissionResponse) GetUpdated() bool {
	if x != nil {
		return x.Updated
	}
	return false
}

func (x *UpdateMissionResponse) GetOldVersion() string {
	if x != nil {
		return x.OldVersion
	}
	return ""
}

func (x *UpdateMissionResponse) GetNewVersion() string {
	if x != nil {
		return x.NewVersion
	}
	return ""
}

func (x *UpdateMissionResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *UpdateMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ResolveMissionDependenciesRequest requests dependency resolution for a mission.
type ResolveMissionDependenciesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// workflow_path is the path to the mission workflow YAML file
	WorkflowPath  string `protobuf:"bytes,1,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveMissionDependenciesRequest) Reset() {
	*x = ResolveMissionDependenciesRequest{}
	mi := &file_daemon_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveMissionDependenciesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveMissionDependenciesRequest) ProtoMessage() {}

func (x *ResolveMissionDependenciesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveMissionDependenciesRequest.ProtoReflect.Descriptor instead.
func (*ResolveMissionDependenciesRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{84}
}

func (x *ResolveMissionDependenciesRequest) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

// ResolveMissionDependenciesResponse returns the complete dependency tree.
type ResolveMissionDependenciesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if resolution was successful
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// tree is the complete resolved dependency tree
	Tree *DependencyTree `protobuf:"bytes,2,opt,name=tree,proto3" json:"tree,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResolveMissionDependenciesResponse) Reset() {
	*x = ResolveMissionDependenciesResponse{}
	mi := &file_daemon_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResolveMissionDependenciesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResolveMissionDependenciesResponse) ProtoMessage() {}

func (x *ResolveMissionDependenciesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResolveMissionDependenciesResponse.ProtoReflect.Descriptor instead.
func (*ResolveMissionDependenciesResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{85}
}

func (x *ResolveMissionDependenciesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ResolveMissionDependenciesResponse) GetTree() *DependencyTree {
	if x != nil {
		return x.Tree
	}
	return nil
}

func (x *ResolveMissionDependenciesResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ValidateMissionDependenciesRequest requests validation of mission dependencies.
type ValidateMissionDependenciesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// workflow_path is the path to the mission workflow YAML file
	WorkflowPath  string `protobuf:"bytes,1,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateMissionDependenciesRequest) Reset() {
	*x = ValidateMissionDependenciesRequest{}
	mi := &file_daemon_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateMissionDependenciesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateMissionDependenciesRequest) ProtoMessage() {}

func (x *ValidateMissionDependenciesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateMissionDependenciesRequest.ProtoReflect.Descriptor instead.
func (*ValidateMissionDependenciesRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{86}
}

func (x *ValidateMissionDependenciesRequest) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

// ValidateMissionDependenciesResponse returns validation results.
type ValidateMissionDependenciesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if validation check was performed (not if dependencies are valid)
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// result contains the detailed validation results
	Result *ValidationResult `protobuf:"bytes,2,opt,name=result,proto3" json:"result,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidateMissionDependenciesResponse) Reset() {
	*x = ValidateMissionDependenciesResponse{}
	mi := &file_daemon_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidateMissionDependenciesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidateMissionDependenciesResponse) ProtoMessage() {}

func (x *ValidateMissionDependenciesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidateMissionDependenciesResponse.ProtoReflect.Descriptor instead.
func (*ValidateMissionDependenciesResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{87}
}

func (x *ValidateMissionDependenciesResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ValidateMissionDependenciesResponse) GetResult() *ValidationResult {
	if x != nil {
		return x.Result
	}
	return nil
}

func (x *ValidateMissionDependenciesResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// EnsureDependenciesRunningRequest requests starting stopped dependencies.
type EnsureDependenciesRunningRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// workflow_path is the path to the mission workflow YAML file
	WorkflowPath string `protobuf:"bytes,1,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	// timeout_ms is the timeout for starting all dependencies in milliseconds (0 = default 5 minutes)
	TimeoutMs     int64 `protobuf:"varint,2,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureDependenciesRunningRequest) Reset() {
	*x = EnsureDependenciesRunningRequest{}
	mi := &file_daemon_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureDependenciesRunningRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureDependenciesRunningRequest) ProtoMessage() {}

func (x *EnsureDependenciesRunningRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureDependenciesRunningRequest.ProtoReflect.Descriptor instead.
func (*EnsureDependenciesRunningRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{88}
}

func (x *EnsureDependenciesRunningRequest) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

func (x *EnsureDependenciesRunningRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// EnsureDependenciesRunningResponse returns the result of starting dependencies.
type EnsureDependenciesRunningResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if all dependencies were started successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// started_count is the number of components that were started
	StartedCount int32 `protobuf:"varint,2,opt,name=started_count,json=startedCount,proto3" json:"started_count,omitempty"`
	// skipped_count is the number of components that were already running
	SkippedCount int32 `protobuf:"varint,3,opt,name=skipped_count,json=skippedCount,proto3" json:"skipped_count,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnsureDependenciesRunningResponse) Reset() {
	*x = EnsureDependenciesRunningResponse{}
	mi := &file_daemon_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnsureDependenciesRunningResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnsureDependenciesRunningResponse) ProtoMessage() {}

func (x *EnsureDependenciesRunningResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnsureDependenciesRunningResponse.ProtoReflect.Descriptor instead.
func (*EnsureDependenciesRunningResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{89}
}

func (x *EnsureDependenciesRunningResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *EnsureDependenciesRunningResponse) GetStartedCount() int32 {
	if x != nil {
		return x.StartedCount
	}
	return 0
}

func (x *EnsureDependenciesRunningResponse) GetSkippedCount() int32 {
	if x != nil {
		return x.SkippedCount
	}
	return 0
}

func (x *EnsureDependenciesRunningResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// DependencyTree represents the complete resolved dependency graph.
type DependencyTree struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// roots are the root nodes (direct mission dependencies)
	Roots []*DependencyNode `protobuf:"bytes,1,rep,name=roots,proto3" json:"roots,omitempty"`
	// nodes maps component keys (kind:name) to dependency nodes
	Nodes map[string]*DependencyNode `protobuf:"bytes,2,rep,name=nodes,proto3" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// agents is a flattened list of all agent dependencies
	Agents []*DependencyNode `protobuf:"bytes,3,rep,name=agents,proto3" json:"agents,omitempty"`
	// tools is a flattened list of all tool dependencies
	Tools []*DependencyNode `protobuf:"bytes,4,rep,name=tools,proto3" json:"tools,omitempty"`
	// plugins is a flattened list of all plugin dependencies
	Plugins []*DependencyNode `protobuf:"bytes,5,rep,name=plugins,proto3" json:"plugins,omitempty"`
	// resolved_at is when the tree was resolved (Unix timestamp)
	ResolvedAt int64 `protobuf:"varint,6,opt,name=resolved_at,json=resolvedAt,proto3" json:"resolved_at,omitempty"`
	// mission_ref is the mission name or path that was resolved
	MissionRef    string `protobuf:"bytes,7,opt,name=mission_ref,json=missionRef,proto3" json:"mission_ref,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DependencyTree) Reset() {
	*x = DependencyTree{}
	mi := &file_daemon_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DependencyTree) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DependencyTree) ProtoMessage() {}

func (x *DependencyTree) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DependencyTree.ProtoReflect.Descriptor instead.
func (*DependencyTree) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{90}
}

func (x *DependencyTree) GetRoots() []*DependencyNode {
	if x != nil {
		return x.Roots
	}
	return nil
}

func (x *DependencyTree) GetNodes() map[string]*DependencyNode {
	if x != nil {
		return x.Nodes
	}
	return nil
}

func (x *DependencyTree) GetAgents() []*DependencyNode {
	if x != nil {
		return x.Agents
	}
	return nil
}

func (x *DependencyTree) GetTools() []*DependencyNode {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *DependencyTree) GetPlugins() []*DependencyNode {
	if x != nil {
		return x.Plugins
	}
	return nil
}

func (x *DependencyTree) GetResolvedAt() int64 {
	if x != nil {
		return x.ResolvedAt
	}
	return 0
}

func (x *DependencyTree) GetMissionRef() string {
	if x != nil {
		return x.MissionRef
	}
	return ""
}

// DependencyNode represents a single component in the dependency tree.
type DependencyNode struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind (agent, tool, plugin)
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the required version (may be a constraint like ">=2.0")
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// required_by lists component keys that depend on this component
	RequiredBy []string `protobuf:"bytes,4,rep,name=required_by,json=requiredBy,proto3" json:"required_by,omitempty"`
	// depends_on lists component keys this component depends on
	DependsOn []string `protobuf:"bytes,5,rep,name=depends_on,json=dependsOn,proto3" json:"depends_on,omitempty"`
	// source indicates where this dependency was discovered
	Source DependencySource `protobuf:"varint,6,opt,name=source,proto3,enum=gibson.daemon.v1.DependencySource" json:"source,omitempty"`
	// source_ref is a reference to the source (node ID, manifest path, etc.)
	SourceRef string `protobuf:"bytes,7,opt,name=source_ref,json=sourceRef,proto3" json:"source_ref,omitempty"`
	// installed indicates if the component is installed
	Installed bool `protobuf:"varint,8,opt,name=installed,proto3" json:"installed,omitempty"`
	// running indicates if the component is currently running
	Running bool `protobuf:"varint,9,opt,name=running,proto3" json:"running,omitempty"`
	// healthy indicates if the component is healthy (if running)
	Healthy bool `protobuf:"varint,10,opt,name=healthy,proto3" json:"healthy,omitempty"`
	// actual_version is the installed version (may differ from required version)
	ActualVersion string `protobuf:"bytes,11,opt,name=actual_version,json=actualVersion,proto3" json:"actual_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DependencyNode) Reset() {
	*x = DependencyNode{}
	mi := &file_daemon_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DependencyNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DependencyNode) ProtoMessage() {}

func (x *DependencyNode) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DependencyNode.ProtoReflect.Descriptor instead.
func (*DependencyNode) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{91}
}

func (x *DependencyNode) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *DependencyNode) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DependencyNode) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *DependencyNode) GetRequiredBy() []string {
	if x != nil {
		return x.RequiredBy
	}
	return nil
}

func (x *DependencyNode) GetDependsOn() []string {
	if x != nil {
		return x.DependsOn
	}
	return nil
}

func (x *DependencyNode) GetSource() DependencySource {
	if x != nil {
		return x.Source
	}
	return DependencySource_SOURCE_UNKNOWN
}

func (x *DependencyNode) GetSourceRef() string {
	if x != nil {
		return x.SourceRef
	}
	return ""
}

func (x *DependencyNode) GetInstalled() bool {
	if x != nil {
		return x.Installed
	}
	return false
}

func (x *DependencyNode) GetRunning() bool {
	if x != nil {
		return x.Running
	}
	return false
}

func (x *DependencyNode) GetHealthy() bool {
	if x != nil {
		return x.Healthy
	}
	return false
}

func (x *DependencyNode) GetActualVersion() string {
	if x != nil {
		return x.ActualVersion
	}
	return ""
}

// ValidationResult contains the outcome of dependency validation.
type ValidationResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// valid indicates if all dependencies are satisfied and running
	Valid bool `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	// summary is a human-readable validation summary
	Summary string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
	// total_components is the total number of components in the tree
	TotalComponents int32 `protobuf:"varint,3,opt,name=total_components,json=totalComponents,proto3" json:"total_components,omitempty"`
	// installed_count is the number of installed components
	InstalledCount int32 `protobuf:"varint,4,opt,name=installed_count,json=installedCount,proto3" json:"installed_count,omitempty"`
	// running_count is the number of running components
	RunningCount int32 `protobuf:"varint,5,opt,name=running_count,json=runningCount,proto3" json:"running_count,omitempty"`
	// healthy_count is the number of healthy components
	HealthyCount int32 `protobuf:"varint,6,opt,name=healthy_count,json=healthyCount,proto3" json:"healthy_count,omitempty"`
	// not_installed lists components that are not installed
	NotInstalled []*DependencyNode `protobuf:"bytes,7,rep,name=not_installed,json=notInstalled,proto3" json:"not_installed,omitempty"`
	// not_running lists components that are installed but not running
	NotRunning []*DependencyNode `protobuf:"bytes,8,rep,name=not_running,json=notRunning,proto3" json:"not_running,omitempty"`
	// unhealthy lists components that are running but unhealthy
	Unhealthy []*DependencyNode `protobuf:"bytes,9,rep,name=unhealthy,proto3" json:"unhealthy,omitempty"`
	// version_mismatches lists components with version constraint violations
	VersionMismatches []*VersionMismatchInfo `protobuf:"bytes,10,rep,name=version_mismatches,json=versionMismatches,proto3" json:"version_mismatches,omitempty"`
	// validated_at is when validation was performed (Unix timestamp)
	ValidatedAt int64 `protobuf:"varint,11,opt,name=validated_at,json=validatedAt,proto3" json:"validated_at,omitempty"`
	// duration_ms is how long validation took in milliseconds
	DurationMs    int64 `protobuf:"varint,12,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ValidationResult) Reset() {
	*x = ValidationResult{}
	mi := &file_daemon_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ValidationResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ValidationResult) ProtoMessage() {}

func (x *ValidationResult) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ValidationResult.ProtoReflect.Descriptor instead.
func (*ValidationResult) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{92}
}

func (x *ValidationResult) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

func (x *ValidationResult) GetSummary() string {
	if x != nil {
		return x.Summary
	}
	return ""
}

func (x *ValidationResult) GetTotalComponents() int32 {
	if x != nil {
		return x.TotalComponents
	}
	return 0
}

func (x *ValidationResult) GetInstalledCount() int32 {
	if x != nil {
		return x.InstalledCount
	}
	return 0
}

func (x *ValidationResult) GetRunningCount() int32 {
	if x != nil {
		return x.RunningCount
	}
	return 0
}

func (x *ValidationResult) GetHealthyCount() int32 {
	if x != nil {
		return x.HealthyCount
	}
	return 0
}

func (x *ValidationResult) GetNotInstalled() []*DependencyNode {
	if x != nil {
		return x.NotInstalled
	}
	return nil
}

func (x *ValidationResult) GetNotRunning() []*DependencyNode {
	if x != nil {
		return x.NotRunning
	}
	return nil
}

func (x *ValidationResult) GetUnhealthy() []*DependencyNode {
	if x != nil {
		return x.Unhealthy
	}
	return nil
}

func (x *ValidationResult) GetVersionMismatches() []*VersionMismatchInfo {
	if x != nil {
		return x.VersionMismatches
	}
	return nil
}

func (x *ValidationResult) GetValidatedAt() int64 {
	if x != nil {
		return x.ValidatedAt
	}
	return 0
}

func (x *ValidationResult) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// VersionMismatchInfo describes a version constraint violation.
type VersionMismatchInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// node is the component with the version mismatch
	Node *DependencyNode `protobuf:"bytes,1,opt,name=node,proto3" json:"node,omitempty"`
	// required_version is the version constraint that was required
	RequiredVersion string `protobuf:"bytes,2,opt,name=required_version,json=requiredVersion,proto3" json:"required_version,omitempty"`
	// actual_version is the version that is actually installed
	ActualVersion string `protobuf:"bytes,3,opt,name=actual_version,json=actualVersion,proto3" json:"actual_version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *VersionMismatchInfo) Reset() {
	*x = VersionMismatchInfo{}
	mi := &file_daemon_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VersionMismatchInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VersionMismatchInfo) ProtoMessage() {}

func (x *VersionMismatchInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VersionMismatchInfo.ProtoReflect.Descriptor instead.
func (*VersionMismatchInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{93}
}

func (x *VersionMismatchInfo) GetNode() *DependencyNode {
	if x != nil {
		return x.Node
	}
	return nil
}

func (x *VersionMismatchInfo) GetRequiredVersion() string {
	if x != nil {
		return x.RequiredVersion
	}
	return ""
}

func (x *VersionMismatchInfo) GetActualVersion() string {
	if x != nil {
		return x.ActualVersion
	}
	return ""
}

// Mission represents a complete mission execution instance with full state.
type Mission struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique mission identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the human-readable mission name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// status is the current mission status
	Status MissionStatus `protobuf:"varint,3,opt,name=status,proto3,enum=gibson.daemon.v1.MissionStatus" json:"status,omitempty"`
	// target_id is the target identifier
	TargetId string `protobuf:"bytes,4,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	// workflow_id is the workflow definition identifier
	WorkflowId string `protobuf:"bytes,5,opt,name=workflow_id,json=workflowId,proto3" json:"workflow_id,omitempty"`
	// constraints defines execution constraints
	Constraints *MissionConstraints `protobuf:"bytes,6,opt,name=constraints,proto3" json:"constraints,omitempty"`
	// metrics contains current execution metrics
	Metrics *MissionMetrics `protobuf:"bytes,7,opt,name=metrics,proto3" json:"metrics,omitempty"`
	// checkpoint is the latest checkpoint (if any)
	Checkpoint *MissionCheckpoint `protobuf:"bytes,8,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// run_number is the sequential run number for this mission name
	RunNumber int32 `protobuf:"varint,9,opt,name=run_number,json=runNumber,proto3" json:"run_number,omitempty"`
	// created_at is when the mission was created (Unix timestamp in milliseconds)
	CreatedAt int64 `protobuf:"varint,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// updated_at is when the mission was last updated (Unix timestamp in milliseconds)
	UpdatedAt int64 `protobuf:"varint,11,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	// started_at is when the mission execution started (Unix timestamp in milliseconds)
	StartedAt int64 `protobuf:"varint,12,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// completed_at is when the mission execution completed (Unix timestamp in milliseconds, 0 if not completed)
	CompletedAt   int64 `protobuf:"varint,13,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Mission) Reset() {
	*x = Mission{}
	mi := &file_daemon_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Mission) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Mission) ProtoMessage() {}

func (x *Mission) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Mission.ProtoReflect.Descriptor instead.
func (*Mission) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{94}
}

func (x *Mission) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *Mission) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Mission) GetStatus() MissionStatus {
	if x != nil {
		return x.Status
	}
	return MissionStatus_MISSION_STATUS_UNSPECIFIED
}

func (x *Mission) GetTargetId() string {
	if x != nil {
		return x.TargetId
	}
	return ""
}

func (x *Mission) GetWorkflowId() string {
	if x != nil {
		return x.WorkflowId
	}
	return ""
}

func (x *Mission) GetConstraints() *MissionConstraints {
	if x != nil {
		return x.Constraints
	}
	return nil
}

func (x *Mission) GetMetrics() *MissionMetrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

func (x *Mission) GetCheckpoint() *MissionCheckpoint {
	if x != nil {
		return x.Checkpoint
	}
	return nil
}

func (x *Mission) GetRunNumber() int32 {
	if x != nil {
		return x.RunNumber
	}
	return 0
}

func (x *Mission) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *Mission) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

func (x *Mission) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *Mission) GetCompletedAt() int64 {
	if x != nil {
		return x.CompletedAt
	}
	return 0
}

// MissionConstraints defines execution constraints for a mission.
type MissionConstraints struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// max_duration_seconds is the maximum mission duration in seconds (0 = no limit)
	MaxDurationSeconds int32 `protobuf:"varint,1,opt,name=max_duration_seconds,json=maxDurationSeconds,proto3" json:"max_duration_seconds,omitempty"`
	// max_findings is the maximum number of findings to collect (0 = no limit)
	MaxFindings int32 `protobuf:"varint,2,opt,name=max_findings,json=maxFindings,proto3" json:"max_findings,omitempty"`
	// max_tokens is the maximum LLM tokens to consume (0 = no limit)
	MaxTokens int32 `protobuf:"varint,3,opt,name=max_tokens,json=maxTokens,proto3" json:"max_tokens,omitempty"`
	// max_turns_per_agent is the maximum turns per agent (0 = no limit)
	MaxTurnsPerAgent int32 `protobuf:"varint,4,opt,name=max_turns_per_agent,json=maxTurnsPerAgent,proto3" json:"max_turns_per_agent,omitempty"`
	// allowed_techniques is the list of allowed MITRE techniques (empty = all allowed)
	AllowedTechniques []string `protobuf:"bytes,5,rep,name=allowed_techniques,json=allowedTechniques,proto3" json:"allowed_techniques,omitempty"`
	// blocked_techniques is the list of blocked MITRE techniques (empty = none blocked)
	BlockedTechniques []string `protobuf:"bytes,6,rep,name=blocked_techniques,json=blockedTechniques,proto3" json:"blocked_techniques,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *MissionConstraints) Reset() {
	*x = MissionConstraints{}
	mi := &file_daemon_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionConstraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionConstraints) ProtoMessage() {}

func (x *MissionConstraints) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionConstraints.ProtoReflect.Descriptor instead.
func (*MissionConstraints) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{95}
}

func (x *MissionConstraints) GetMaxDurationSeconds() int32 {
	if x != nil {
		return x.MaxDurationSeconds
	}
	return 0
}

func (x *MissionConstraints) GetMaxFindings() int32 {
	if x != nil {
		return x.MaxFindings
	}
	return 0
}

func (x *MissionConstraints) GetMaxTokens() int32 {
	if x != nil {
		return x.MaxTokens
	}
	return 0
}

func (x *MissionConstraints) GetMaxTurnsPerAgent() int32 {
	if x != nil {
		return x.MaxTurnsPerAgent
	}
	return 0
}

func (x *MissionConstraints) GetAllowedTechniques() []string {
	if x != nil {
		return x.AllowedTechniques
	}
	return nil
}

func (x *MissionConstraints) GetBlockedTechniques() []string {
	if x != nil {
		return x.BlockedTechniques
	}
	return nil
}

// MissionMetrics contains execution metrics for a mission.
type MissionMetrics struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// turns_used is the number of agent turns/iterations executed
	TurnsUsed int32 `protobuf:"varint,1,opt,name=turns_used,json=turnsUsed,proto3" json:"turns_used,omitempty"`
	// nodes_executed is the number of workflow nodes that ran successfully
	NodesExecuted int32 `protobuf:"varint,2,opt,name=nodes_executed,json=nodesExecuted,proto3" json:"nodes_executed,omitempty"`
	// nodes_failed is the number of workflow nodes that failed
	NodesFailed int32 `protobuf:"varint,3,opt,name=nodes_failed,json=nodesFailed,proto3" json:"nodes_failed,omitempty"`
	// findings_count is the total number of findings discovered
	FindingsCount int32 `protobuf:"varint,4,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// critical_count is the number of critical severity findings
	CriticalCount int32 `protobuf:"varint,5,opt,name=critical_count,json=criticalCount,proto3" json:"critical_count,omitempty"`
	// high_count is the number of high severity findings
	HighCount int32 `protobuf:"varint,6,opt,name=high_count,json=highCount,proto3" json:"high_count,omitempty"`
	// medium_count is the number of medium severity findings
	MediumCount int32 `protobuf:"varint,7,opt,name=medium_count,json=mediumCount,proto3" json:"medium_count,omitempty"`
	// low_count is the number of low severity findings
	LowCount int32 `protobuf:"varint,8,opt,name=low_count,json=lowCount,proto3" json:"low_count,omitempty"`
	// tokens_used is the total LLM tokens consumed
	TokensUsed    int64 `protobuf:"varint,9,opt,name=tokens_used,json=tokensUsed,proto3" json:"tokens_used,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionMetrics) Reset() {
	*x = MissionMetrics{}
	mi := &file_daemon_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionMetrics) ProtoMessage() {}

func (x *MissionMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionMetrics.ProtoReflect.Descriptor instead.
func (*MissionMetrics) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{96}
}

func (x *MissionMetrics) GetTurnsUsed() int32 {
	if x != nil {
		return x.TurnsUsed
	}
	return 0
}

func (x *MissionMetrics) GetNodesExecuted() int32 {
	if x != nil {
		return x.NodesExecuted
	}
	return 0
}

func (x *MissionMetrics) GetNodesFailed() int32 {
	if x != nil {
		return x.NodesFailed
	}
	return 0
}

func (x *MissionMetrics) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *MissionMetrics) GetCriticalCount() int32 {
	if x != nil {
		return x.CriticalCount
	}
	return 0
}

func (x *MissionMetrics) GetHighCount() int32 {
	if x != nil {
		return x.HighCount
	}
	return 0
}

func (x *MissionMetrics) GetMediumCount() int32 {
	if x != nil {
		return x.MediumCount
	}
	return 0
}

func (x *MissionMetrics) GetLowCount() int32 {
	if x != nil {
		return x.LowCount
	}
	return 0
}

func (x *MissionMetrics) GetTokensUsed() int64 {
	if x != nil {
		return x.TokensUsed
	}
	return 0
}

// MissionCheckpoint represents a saved checkpoint state for pause/resume.
type MissionCheckpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique checkpoint identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// version is the checkpoint format version
	Version int32 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	// completed_nodes is the number of nodes that had completed at checkpoint time
	CompletedNodes int32 `protobuf:"varint,3,opt,name=completed_nodes,json=completedNodes,proto3" json:"completed_nodes,omitempty"`
	// total_nodes is the total number of nodes in the workflow
	TotalNodes int32 `protobuf:"varint,4,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
	// created_at is when this checkpoint was created (Unix timestamp in milliseconds)
	CreatedAt int64 `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// state_data is the serialized checkpoint state (opaque blob)
	StateData     []byte `protobuf:"bytes,6,opt,name=state_data,json=stateData,proto3" json:"state_data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionCheckpoint) Reset() {
	*x = MissionCheckpoint{}
	mi := &file_daemon_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionCheckpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionCheckpoint) ProtoMessage() {}

func (x *MissionCheckpoint) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionCheckpoint.ProtoReflect.Descriptor instead.
func (*MissionCheckpoint) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{97}
}

func (x *MissionCheckpoint) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *MissionCheckpoint) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *MissionCheckpoint) GetCompletedNodes() int32 {
	if x != nil {
		return x.CompletedNodes
	}
	return 0
}

func (x *MissionCheckpoint) GetTotalNodes() int32 {
	if x != nil {
		return x.TotalNodes
	}
	return 0
}

func (x *MissionCheckpoint) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *MissionCheckpoint) GetStateData() []byte {
	if x != nil {
		return x.StateData
	}
	return nil
}

// MissionDefinition represents an installed mission workflow definition.
type MissionDefinition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the mission name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version is the mission version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// description is the mission description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// source is the Git repository URL
	Source string `protobuf:"bytes,4,opt,name=source,proto3" json:"source,omitempty"`
	// node_count is the number of nodes in the mission workflow
	NodeCount int32 `protobuf:"varint,5,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// installed_at is when the mission was installed (Unix timestamp in milliseconds)
	InstalledAt int64 `protobuf:"varint,6,opt,name=installed_at,json=installedAt,proto3" json:"installed_at,omitempty"`
	// updated_at is when the mission was last updated (Unix timestamp in milliseconds)
	UpdatedAt     int64 `protobuf:"varint,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionDefinition) Reset() {
	*x = MissionDefinition{}
	mi := &file_daemon_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionDefinition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionDefinition) ProtoMessage() {}

func (x *MissionDefinition) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionDefinition.ProtoReflect.Descriptor instead.
func (*MissionDefinition) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{98}
}

func (x *MissionDefinition) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MissionDefinition) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *MissionDefinition) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *MissionDefinition) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *MissionDefinition) GetNodeCount() int32 {
	if x != nil {
		return x.NodeCount
	}
	return 0
}

func (x *MissionDefinition) GetInstalledAt() int64 {
	if x != nil {
		return x.InstalledAt
	}
	return 0
}

func (x *MissionDefinition) GetUpdatedAt() int64 {
	if x != nil {
		return x.UpdatedAt
	}
	return 0
}

var File_daemon_proto protoreflect.FileDescriptor

const file_daemon_proto_rawDesc = "" +
	"\n" +
	"\fdaemon.proto\x12\x10gibson.daemon.v1\x1a\fcommon.proto\"T\n" +
	"\x0eConnectRequest\x12%\n" +
	"\x0eclient_version\x18\x01 \x01(\tR\rclientVersion\x12\x1b\n" +
	"\tclient_id\x18\x02 \x01(\tR\bclientId\"z\n" +
	"\x0fConnectResponse\x12%\n" +
	"\x0edaemon_version\x18\x01 \x01(\tR\rdaemonVersion\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12!\n" +
	"\fgrpc_address\x18\x03 \x01(\tR\vgrpcAddress\"\r\n" +
	"\vPingRequest\",\n" +
	"\fPingResponse\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\"\x0f\n" +
	"\rStatusRequest\"\xfd\x02\n" +
	"\x0eStatusResponse\x12\x18\n" +
	"\arunning\x18\x01 \x01(\bR\arunning\x12\x10\n" +
	"\x03pid\x18\x02 \x01(\x05R\x03pid\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\x03R\tstartTime\x12\x16\n" +
	"\x06uptime\x18\x04 \x01(\tR\x06uptime\x12!\n" +
	"\fgrpc_address\x18\x05 \x01(\tR\vgrpcAddress\x12#\n" +
	"\rregistry_type\x18\x06 \x01(\tR\fregistryType\x12#\n" +
	"\rregistry_addr\x18\a \x01(\tR\fregistryAddr\x12#\n" +
	"\rcallback_addr\x18\b \x01(\tR\fcallbackAddr\x12\x1f\n" +
	"\vagent_count\x18\t \x01(\x05R\n" +
	"agentCount\x12#\n" +
	"\rmission_count\x18\n" +
	" \x01(\x05R\fmissionCount\x120\n" +
	"\x14active_mission_count\x18\v \x01(\x05R\x12activeMissionCount\"\x94\x02\n" +
	"\x11RunMissionRequest\x12#\n" +
	"\rworkflow_path\x18\x01 \x01(\tR\fworkflowPath\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x02 \x01(\tR\tmissionId\x12P\n" +
	"\tvariables\x18\x03 \x03(\v22.gibson.daemon.v1.RunMissionRequest.VariablesEntryR\tvariables\x12+\n" +
	"\x11memory_continuity\x18\x04 \x01(\tR\x10memoryContinuity\x1a<\n" +
	"\x0eVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9b\x02\n" +
	"\fMissionEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x03 \x01(\tR\tmissionId\x12\x17\n" +
	"\anode_id\x18\x04 \x01(\tR\x06nodeId\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\x12+\n" +
	"\x04data\x18\x06 \x01(\v2\x17.gibson.common.TypedMapR\x04data\x12\x14\n" +
	"\x05error\x18\a \x01(\tR\x05error\x129\n" +
	"\x06result\x18\b \x01(\v2!.gibson.daemon.v1.OperationResultR\x06result\"I\n" +
	"\x12StopMissionRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"I\n" +
	"\x13StopMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"\xac\x01\n" +
	"\x13ListMissionsRequest\x12\x1f\n" +
	"\vactive_only\x18\x01 \x01(\bR\n" +
	"activeOnly\x12\x14\n" +
	"\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x03 \x01(\x05R\x06offset\x12#\n" +
	"\rstatus_filter\x18\x04 \x01(\tR\fstatusFilter\x12!\n" +
	"\fname_pattern\x18\x05 \x01(\tR\vnamePattern\"g\n" +
	"\x14ListMissionsResponse\x129\n" +
	"\bmissions\x18\x01 \x03(\v2\x1d.gibson.daemon.v1.MissionInfoR\bmissions\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xcd\x01\n" +
	"\vMissionInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12#\n" +
	"\rworkflow_path\x18\x02 \x01(\tR\fworkflowPath\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"start_time\x18\x04 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x05 \x01(\x03R\aendTime\x12#\n" +
	"\rfinding_count\x18\x06 \x01(\x05R\ffindingCount\x12\x12\n" +
	"\x04name\x18\a \x01(\tR\x04name\"'\n" +
	"\x11ListAgentsRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\"I\n" +
	"\x12ListAgentsResponse\x123\n" +
	"\x06agents\x18\x01 \x03(\v2\x1b.gibson.daemon.v1.AgentInfoR\x06agents\"\xd2\x01\n" +
	"\tAgentInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04kind\x18\x03 \x01(\tR\x04kind\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x05 \x01(\tR\bendpoint\x12\"\n" +
	"\fcapabilities\x18\x06 \x03(\tR\fcapabilities\x12\x16\n" +
	"\x06health\x18\a \x01(\tR\x06health\x12\x1b\n" +
	"\tlast_seen\x18\b \x01(\x03R\blastSeen\"2\n" +
	"\x15GetAgentStatusRequest\x12\x19\n" +
	"\bagent_id\x18\x01 \x01(\tR\aagentId\"\xab\x01\n" +
	"\x13AgentStatusResponse\x121\n" +
	"\x05agent\x18\x01 \x01(\v2\x1b.gibson.daemon.v1.AgentInfoR\x05agent\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12!\n" +
	"\fcurrent_task\x18\x03 \x01(\tR\vcurrentTask\x12&\n" +
	"\x0ftask_start_time\x18\x04 \x01(\x03R\rtaskStartTime\"\x12\n" +
	"\x10ListToolsRequest\"E\n" +
	"\x11ListToolsResponse\x120\n" +
	"\x05tools\x18\x01 \x03(\v2\x1a.gibson.daemon.v1.ToolInfoR\x05tools\"\xbb\x01\n" +
	"\bToolInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x04 \x01(\tR\bendpoint\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x16\n" +
	"\x06health\x18\x06 \x01(\tR\x06health\x12\x1b\n" +
	"\tlast_seen\x18\a \x01(\x03R\blastSeen\"\x14\n" +
	"\x12ListPluginsRequest\"M\n" +
	"\x13ListPluginsResponse\x126\n" +
	"\aplugins\x18\x01 \x03(\v2\x1c.gibson.daemon.v1.PluginInfoR\aplugins\"\xbd\x01\n" +
	"\n" +
	"PluginInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x04 \x01(\tR\bendpoint\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x16\n" +
	"\x06health\x18\x06 \x01(\tR\x06health\x12\x1b\n" +
	"\tlast_seen\x18\a \x01(\x03R\blastSeen\"\xa3\x01\n" +
	"\x12QueryPluginRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12/\n" +
	"\x06params\x18\x03 \x01(\v2\x17.gibson.common.TypedMapR\x06params\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x04 \x01(\x03R\ttimeoutMsJ\x04\b\x05\x10\x06R\vparams_json\"\x92\x01\n" +
	"\x13QueryPluginResponse\x121\n" +
	"\x06result\x18\x01 \x01(\v2\x19.gibson.common.TypedValueR\x06result\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x1f\n" +
	"\vduration_ms\x18\x03 \x01(\x03R\n" +
	"durationMsJ\x04\b\x04\x10\x05R\vresult_json\"\xb5\x02\n" +
	"\x10RunAttackRequest\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target\x12\x1f\n" +
	"\vattack_type\x18\x02 \x01(\tR\n" +
	"attackType\x12\x19\n" +
	"\bagent_id\x18\x03 \x01(\tR\aagentId\x12%\n" +
	"\x0epayload_filter\x18\x04 \x01(\tR\rpayloadFilter\x12I\n" +
	"\aoptions\x18\x05 \x03(\v2/.gibson.daemon.v1.RunAttackRequest.OptionsEntryR\aoptions\x12\x1f\n" +
	"\vtarget_name\x18\x06 \x01(\tR\n" +
	"targetName\x1a:\n" +
	"\fOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xb8\x02\n" +
	"\vAttackEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x1b\n" +
	"\tattack_id\x18\x03 \x01(\tR\battackId\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\x12+\n" +
	"\x04data\x18\x05 \x01(\v2\x17.gibson.common.TypedMapR\x04data\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\x127\n" +
	"\afinding\x18\a \x01(\v2\x1d.gibson.daemon.v1.FindingInfoR\afinding\x129\n" +
	"\x06result\x18\b \x01(\v2!.gibson.daemon.v1.OperationResultR\x06result\"\xe5\x01\n" +
	"\vFindingInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12\x1a\n" +
	"\bseverity\x18\x03 \x01(\tR\bseverity\x12\x1a\n" +
	"\bcategory\x18\x04 \x01(\tR\bcategory\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x1c\n" +
	"\ttechnique\x18\x06 \x01(\tR\ttechnique\x12\x1a\n" +
	"\bevidence\x18\a \x01(\tR\bevidence\x12\x1c\n" +
	"\ttimestamp\x18\b \x01(\x03R\ttimestamp\"R\n" +
	"\x10SubscribeRequest\x12\x1f\n" +
	"\vevent_types\x18\x01 \x03(\tR\n" +
	"eventTypes\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x02 \x01(\tR\tmissionId\"\xa5\x03\n" +
	"\x05Event\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x16\n" +
	"\x06source\x18\x03 \x01(\tR\x06source\x12+\n" +
	"\x04data\x18\x04 \x01(\v2\x17.gibson.common.TypedMapR\x04data\x12E\n" +
	"\rmission_event\x18\x05 \x01(\v2\x1e.gibson.daemon.v1.MissionEventH\x00R\fmissionEvent\x12B\n" +
	"\fattack_event\x18\x06 \x01(\v2\x1d.gibson.daemon.v1.AttackEventH\x00R\vattackEvent\x12?\n" +
	"\vagent_event\x18\a \x01(\v2\x1c.gibson.daemon.v1.AgentEventH\x00R\n" +
	"agentEvent\x12E\n" +
	"\rfinding_event\x18\b \x01(\v2\x1e.gibson.daemon.v1.FindingEventH\x00R\ffindingEventB\a\n" +
	"\x05event\"\xca\x01\n" +
	"\n" +
	"AgentEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x19\n" +
	"\bagent_id\x18\x03 \x01(\tR\aagentId\x12\x1d\n" +
	"\n" +
	"agent_name\x18\x04 \x01(\tR\tagentName\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\x12+\n" +
	"\x04data\x18\x06 \x01(\v2\x17.gibson.common.TypedMapR\x04data\"\xa3\x01\n" +
	"\fFindingEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x127\n" +
	"\afinding\x18\x03 \x01(\v2\x1d.gibson.daemon.v1.FindingInfoR\afinding\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x04 \x01(\tR\tmissionId\"?\n" +
	"\x15StartComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\x8d\x01\n" +
	"\x16StartComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x10\n" +
	"\x03pid\x18\x02 \x01(\x05R\x03pid\x12\x12\n" +
	"\x04port\x18\x03 \x01(\x05R\x04port\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\x12\x19\n" +
	"\blog_path\x18\x05 \x01(\tR\alogPath\"T\n" +
	"\x14StopComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05force\x18\x03 \x01(\bR\x05force\"\x91\x01\n" +
	"\x15StopComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rstopped_count\x18\x02 \x01(\x05R\fstoppedCount\x12\x1f\n" +
	"\vtotal_count\x18\x03 \x01(\x05R\n" +
	"totalCount\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"\x87\x04\n" +
	"\x0fOperationResult\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\x12\x1f\n" +
	"\vduration_ms\x18\x02 \x01(\x03R\n" +
	"durationMs\x12\x1d\n" +
	"\n" +
	"started_at\x18\x03 \x01(\x03R\tstartedAt\x12!\n" +
	"\fcompleted_at\x18\x04 \x01(\x03R\vcompletedAt\x12\x1d\n" +
	"\n" +
	"turns_used\x18\x05 \x01(\x05R\tturnsUsed\x12\x1f\n" +
	"\vtokens_used\x18\x06 \x01(\x03R\n" +
	"tokensUsed\x12%\n" +
	"\x0enodes_executed\x18\a \x01(\x05R\rnodesExecuted\x12!\n" +
	"\fnodes_failed\x18\b \x01(\x05R\vnodesFailed\x12%\n" +
	"\x0efindings_count\x18\t \x01(\x05R\rfindingsCount\x12%\n" +
	"\x0ecritical_count\x18\n" +
	" \x01(\x05R\rcriticalCount\x12\x1d\n" +
	"\n" +
	"high_count\x18\v \x01(\x05R\thighCount\x12!\n" +
	"\fmedium_count\x18\f \x01(\x05R\vmediumCount\x12\x1b\n" +
	"\tlow_count\x18\r \x01(\x05R\blowCount\x12#\n" +
	"\rerror_message\x18\x0e \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"error_code\x18\x0f \x01(\tR\terrorCode\"J\n" +
	"\x13PauseMissionRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"o\n" +
	"\x14PauseMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rcheckpoint_id\x18\x02 \x01(\tR\fcheckpointId\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"Z\n" +
	"\x14ResumeMissionRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12#\n" +
	"\rcheckpoint_id\x18\x02 \x01(\tR\fcheckpointId\"\\\n" +
	"\x18GetMissionHistoryRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x03 \x01(\x05R\x06offset\"c\n" +
	"\x19GetMissionHistoryResponse\x120\n" +
	"\x04runs\x18\x01 \x03(\v2\x1c.gibson.daemon.v1.MissionRunR\x04runs\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xf3\x01\n" +
	"\n" +
	"MissionRun\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12\x1d\n" +
	"\n" +
	"run_number\x18\x02 \x01(\x05R\trunNumber\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"created_at\x18\x04 \x01(\x03R\tcreatedAt\x12!\n" +
	"\fcompleted_at\x18\x05 \x01(\x03R\vcompletedAt\x12%\n" +
	"\x0efindings_count\x18\x06 \x01(\x05R\rfindingsCount\x12&\n" +
	"\x0fprevious_run_id\x18\a \x01(\tR\rpreviousRunId\"=\n" +
	"\x1cGetMissionCheckpointsRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\"c\n" +
	"\x1dGetMissionCheckpointsResponse\x12B\n" +
	"\vcheckpoints\x18\x01 \x03(\v2 .gibson.daemon.v1.CheckpointInfoR\vcheckpoints\"\xdf\x01\n" +
	"\x0eCheckpointInfo\x12#\n" +
	"\rcheckpoint_id\x18\x01 \x01(\tR\fcheckpointId\x12\x1d\n" +
	"\n" +
	"created_at\x18\x02 \x01(\x03R\tcreatedAt\x12'\n" +
	"\x0fcompleted_nodes\x18\x03 \x01(\x05R\x0ecompletedNodes\x12\x1f\n" +
	"\vtotal_nodes\x18\x04 \x01(\x05R\n" +
	"totalNodes\x12%\n" +
	"\x0efindings_count\x18\x05 \x01(\x05R\rfindingsCount\x12\x18\n" +
	"\aversion\x18\x06 \x01(\x05R\aversion\"\x88\x01\n" +
	"\x12ExecuteToolRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12-\n" +
	"\x05input\x18\x02 \x01(\v2\x17.gibson.common.TypedMapR\x05input\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x03R\ttimeoutMsJ\x04\b\x04\x10\x05R\n" +
	"input_json\"\xac\x01\n" +
	"\x13ExecuteToolResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x121\n" +
	"\x06output\x18\x02 \x01(\v2\x19.gibson.common.TypedValueR\x06output\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\x12\x1f\n" +
	"\vduration_ms\x18\x04 \x01(\x03R\n" +
	"durationMsJ\x04\b\x05\x10\x06R\voutput_json\"\x1a\n" +
	"\x18GetAvailableToolsRequest\"V\n" +
	"\x19GetAvailableToolsResponse\x129\n" +
	"\x05tools\x18\x01 \x03(\v2#.gibson.daemon.v1.AvailableToolInfoR\x05tools\"\xdc\x03\n" +
	"\x11AvailableToolInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x12\n" +
	"\x04tags\x18\x04 \x03(\tR\x04tags\x12*\n" +
	"\x11input_schema_json\x18\x05 \x01(\tR\x0finputSchemaJson\x12,\n" +
	"\x12output_schema_json\x18\x06 \x01(\tR\x10outputSchemaJson\x12\x16\n" +
	"\x06status\x18\a \x01(\tR\x06status\x12#\n" +
	"\rerror_message\x18\b \x01(\tR\ferrorMessage\x12@\n" +
	"\ametrics\x18\t \x01(\v2&.gibson.daemon.v1.ToolExecutionMetricsR\ametrics\x12C\n" +
	"\finput_schema\x18\n" +
	" \x01(\v2 .gibson.daemon.v1.JSONSchemaNodeR\vinputSchema\x12E\n" +
	"\routput_schema\x18\v \x01(\v2 .gibson.daemon.v1.JSONSchemaNodeR\foutputSchema\"\xd1\x01\n" +
	"\x14ToolExecutionMetrics\x12\x1f\n" +
	"\vtotal_calls\x18\x01 \x01(\x03R\n" +
	"totalCalls\x12#\n" +
	"\rsuccess_calls\x18\x02 \x01(\x03R\fsuccessCalls\x12!\n" +
	"\ffailed_calls\x18\x03 \x01(\x03R\vfailedCalls\x12&\n" +
	"\x0favg_duration_ms\x18\x04 \x01(\x03R\ravgDurationMs\x12(\n" +
	"\x10last_executed_at\x18\x05 \x01(\x03R\x0elastExecutedAt\"\x88\x05\n" +
	"\x0eJSONSchemaNode\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12P\n" +
	"\n" +
	"properties\x18\x03 \x03(\v20.gibson.daemon.v1.JSONSchemaNode.PropertiesEntryR\n" +
	"properties\x12\x1a\n" +
	"\brequired\x18\x04 \x03(\tR\brequired\x126\n" +
	"\x05items\x18\x05 \x01(\v2 .gibson.daemon.v1.JSONSchemaNodeR\x05items\x12\x1f\n" +
	"\venum_values\x18\x06 \x03(\tR\n" +
	"enumValues\x12#\n" +
	"\rdefault_value\x18\a \x01(\tR\fdefaultValue\x12\x18\n" +
	"\aminimum\x18\b \x01(\x01R\aminimum\x12\x18\n" +
	"\amaximum\x18\t \x01(\x01R\amaximum\x12\x1d\n" +
	"\n" +
	"min_length\x18\n" +
	" \x01(\x05R\tminLength\x12\x1d\n" +
	"\n" +
	"max_length\x18\v \x01(\x05R\tmaxLength\x12\x18\n" +
	"\apattern\x18\f \x01(\tR\apattern\x12\x16\n" +
	"\x06format\x18\r \x01(\tR\x06format\x12\x10\n" +
	"\x03ref\x18\x0e \x01(\tR\x03ref\x12=\n" +
	"\btaxonomy\x18\x0f \x01(\v2!.gibson.daemon.v1.TaxonomyMappingR\btaxonomy\x1a_\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .gibson.daemon.v1.JSONSchemaNodeR\x05value:\x028\x01\"\xfd\x02\n" +
	"\x0fTaxonomyMapping\x12\x1b\n" +
	"\tnode_type\x18\x01 \x01(\tR\bnodeType\x12s\n" +
	"\x16identifying_properties\x18\x02 \x03(\v2<.gibson.daemon.v1.TaxonomyMapping.IdentifyingPropertiesEntryR\x15identifyingProperties\x12A\n" +
	"\n" +
	"properties\x18\x03 \x03(\v2!.gibson.daemon.v1.PropertyMappingR\n" +
	"properties\x12K\n" +
	"\rrelationships\x18\x04 \x03(\v2%.gibson.daemon.v1.RelationshipMappingR\rrelationships\x1aH\n" +
	"\x1aIdentifyingPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x84\x01\n" +
	"\x0fPropertyMapping\x12\x16\n" +
	"\x06source\x18\x01 \x01(\tR\x06source\x12\x16\n" +
	"\x06target\x18\x02 \x01(\tR\x06target\x12#\n" +
	"\rdefault_value\x18\x03 \x01(\tR\fdefaultValue\x12\x1c\n" +
	"\ttransform\x18\x04 \x01(\tR\ttransform\"\xb3\x01\n" +
	"\rNodeReference\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12O\n" +
	"\n" +
	"properties\x18\x02 \x03(\v2/.gibson.daemon.v1.NodeReference.PropertiesEntryR\n" +
	"properties\x1a=\n" +
	"\x0fPropertiesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\xf7\x01\n" +
	"\x13RelationshipMapping\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x123\n" +
	"\x04from\x18\x02 \x01(\v2\x1f.gibson.daemon.v1.NodeReferenceR\x04from\x12/\n" +
	"\x02to\x18\x03 \x01(\v2\x1f.gibson.daemon.v1.NodeReferenceR\x02to\x12\x1c\n" +
	"\tcondition\x18\x04 \x01(\tR\tcondition\x12H\n" +
	"\x0erel_properties\x18\x05 \x03(\v2!.gibson.daemon.v1.PropertyMappingR\rrelProperties\"\xb8\x01\n" +
	"\x17InstallComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x10\n" +
	"\x03url\x18\x02 \x01(\tR\x03url\x12\x16\n" +
	"\x06branch\x18\x03 \x01(\tR\x06branch\x12\x10\n" +
	"\x03tag\x18\x04 \x01(\tR\x03tag\x12\x14\n" +
	"\x05force\x18\x05 \x01(\bR\x05force\x12\x1d\n" +
	"\n" +
	"skip_build\x18\x06 \x01(\bR\tskipBuild\x12\x18\n" +
	"\averbose\x18\a \x01(\bR\averbose\"\xf8\x01\n" +
	"\x18InstallComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1b\n" +
	"\trepo_path\x18\x04 \x01(\tR\brepoPath\x12\x19\n" +
	"\bbin_path\x18\x05 \x01(\tR\abinPath\x12!\n" +
	"\fbuild_output\x18\x06 \x01(\tR\vbuildOutput\x12\x1f\n" +
	"\vduration_ms\x18\a \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\amessage\x18\b \x01(\tR\amessage\"\xbb\x01\n" +
	"\x1aInstallAllComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x10\n" +
	"\x03url\x18\x02 \x01(\tR\x03url\x12\x16\n" +
	"\x06branch\x18\x03 \x01(\tR\x06branch\x12\x10\n" +
	"\x03tag\x18\x04 \x01(\tR\x03tag\x12\x14\n" +
	"\x05force\x18\x05 \x01(\bR\x05force\x12\x1d\n" +
	"\n" +
	"skip_build\x18\x06 \x01(\bR\tskipBuild\x12\x18\n" +
	"\averbose\x18\a \x01(\bR\averbose\"\xda\x03\n" +
	"\x1bInstallAllComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12)\n" +
	"\x10components_found\x18\x02 \x01(\x05R\x0fcomponentsFound\x12)\n" +
	"\x10successful_count\x18\x03 \x01(\x05R\x0fsuccessfulCount\x12#\n" +
	"\rskipped_count\x18\x04 \x01(\x05R\fskippedCount\x12!\n" +
	"\ffailed_count\x18\x05 \x01(\x05R\vfailedCount\x12F\n" +
	"\n" +
	"successful\x18\x06 \x03(\v2&.gibson.daemon.v1.InstallAllResultItemR\n" +
	"successful\x12@\n" +
	"\askipped\x18\a \x03(\v2&.gibson.daemon.v1.InstallAllResultItemR\askipped\x12>\n" +
	"\x06failed\x18\b \x03(\v2&.gibson.daemon.v1.InstallAllFailedItemR\x06failed\x12\x1f\n" +
	"\vduration_ms\x18\t \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\amessage\x18\n" +
	" \x01(\tR\amessage\"X\n" +
	"\x14InstallAllResultItem\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12\x12\n" +
	"\x04path\x18\x03 \x01(\tR\x04path\"T\n" +
	"\x14InstallAllFailedItem\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04path\x18\x02 \x01(\tR\x04path\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\"Y\n" +
	"\x19UninstallComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05force\x18\x03 \x01(\bR\x05force\"P\n" +
	"\x1aUninstallComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"\x93\x01\n" +
	"\x16UpdateComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\arestart\x18\x03 \x01(\bR\arestart\x12\x1d\n" +
	"\n" +
	"skip_build\x18\x04 \x01(\bR\tskipBuild\x12\x18\n" +
	"\averbose\x18\x05 \x01(\bR\averbose\"\xed\x01\n" +
	"\x17UpdateComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\aupdated\x18\x02 \x01(\bR\aupdated\x12\x1f\n" +
	"\vold_version\x18\x03 \x01(\tR\n" +
	"oldVersion\x12\x1f\n" +
	"\vnew_version\x18\x04 \x01(\tR\n" +
	"newVersion\x12!\n" +
	"\fbuild_output\x18\x05 \x01(\tR\vbuildOutput\x12\x1f\n" +
	"\vduration_ms\x18\x06 \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\amessage\x18\a \x01(\tR\amessage\"?\n" +
	"\x15BuildComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\x9d\x01\n" +
	"\x16BuildComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x16\n" +
	"\x06stdout\x18\x02 \x01(\tR\x06stdout\x12\x16\n" +
	"\x06stderr\x18\x03 \x01(\tR\x06stderr\x12\x1f\n" +
	"\vduration_ms\x18\x04 \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\">\n" +
	"\x14ShowComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\xbc\x03\n" +
	"\x15ShowComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x12\n" +
	"\x04kind\x18\x04 \x01(\tR\x04kind\x12\x16\n" +
	"\x06status\x18\x05 \x01(\tR\x06status\x12\x16\n" +
	"\x06source\x18\x06 \x01(\tR\x06source\x12\x1b\n" +
	"\trepo_path\x18\a \x01(\tR\brepoPath\x12\x19\n" +
	"\bbin_path\x18\b \x01(\tR\abinPath\x12\x12\n" +
	"\x04port\x18\t \x01(\x05R\x04port\x12\x10\n" +
	"\x03pid\x18\n" +
	" \x01(\x05R\x03pid\x12\x1d\n" +
	"\n" +
	"created_at\x18\v \x01(\x03R\tcreatedAt\x12\x1d\n" +
	"\n" +
	"updated_at\x18\f \x01(\x03R\tupdatedAt\x12\x1d\n" +
	"\n" +
	"started_at\x18\r \x01(\x03R\tstartedAt\x12\x1d\n" +
	"\n" +
	"stopped_at\x18\x0e \x01(\x03R\tstoppedAt\x12#\n" +
	"\rmanifest_info\x18\x0f \x01(\tR\fmanifestInfo\x12\x18\n" +
	"\amessage\x18\x10 \x01(\tR\amessage\"o\n" +
	"\x17GetComponentLogsRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x16\n" +
	"\x06follow\x18\x03 \x01(\bR\x06follow\x12\x14\n" +
	"\x05lines\x18\x04 \x01(\x05R\x05lines\"\x89\x01\n" +
	"\bLogEntry\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\x12\x14\n" +
	"\x05level\x18\x02 \x01(\tR\x05level\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\x12/\n" +
	"\x06fields\x18\x04 \x01(\v2\x17.gibson.common.TypedMapR\x06fields\"\x9a\x01\n" +
	"\x15InstallMissionRequest\x12\x10\n" +
	"\x03url\x18\x01 \x01(\tR\x03url\x12\x16\n" +
	"\x06branch\x18\x02 \x01(\tR\x06branch\x12\x10\n" +
	"\x03tag\x18\x03 \x01(\tR\x03tag\x12\x14\n" +
	"\x05force\x18\x04 \x01(\bR\x05force\x12\x10\n" +
	"\x03yes\x18\x05 \x01(\bR\x03yes\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x06 \x01(\x03R\ttimeoutMs\"\xfa\x01\n" +
	"\x16InstallMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x12\n" +
	"\x04path\x18\x04 \x01(\tR\x04path\x12I\n" +
	"\fdependencies\x18\x05 \x03(\v2%.gibson.daemon.v1.InstalledDependencyR\fdependencies\x12\x1f\n" +
	"\vduration_ms\x18\x06 \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\amessage\x18\a \x01(\tR\amessage\"j\n" +
	"\x13InstalledDependency\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12+\n" +
	"\x11already_installed\x18\x03 \x01(\bR\x10alreadyInstalled\"C\n" +
	"\x17UninstallMissionRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"N\n" +
	"\x18UninstallMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"M\n" +
	"\x1dListMissionDefinitionsRequest\x12\x14\n" +
	"\x05limit\x18\x01 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x02 \x01(\x05R\x06offset\"{\n" +
	"\x1eListMissionDefinitionsResponse\x12C\n" +
	"\bmissions\x18\x01 \x03(\v2'.gibson.daemon.v1.MissionDefinitionInfoR\bmissions\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xe0\x01\n" +
	"\x15MissionDefinitionInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x16\n" +
	"\x06source\x18\x04 \x01(\tR\x06source\x12!\n" +
	"\finstalled_at\x18\x05 \x01(\x03R\vinstalledAt\x12\x1d\n" +
	"\n" +
	"updated_at\x18\x06 \x01(\x03R\tupdatedAt\x12\x1d\n" +
	"\n" +
	"node_count\x18\a \x01(\x05R\tnodeCount\"I\n" +
	"\x14UpdateMissionRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x02 \x01(\x03R\ttimeoutMs\"\xc8\x01\n" +
	"\x15UpdateMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\aupdated\x18\x02 \x01(\bR\aupdated\x12\x1f\n" +
	"\vold_version\x18\x03 \x01(\tR\n" +
	"oldVersion\x12\x1f\n" +
	"\vnew_version\x18\x04 \x01(\tR\n" +
	"newVersion\x12\x1f\n" +
	"\vduration_ms\x18\x05 \x01(\x03R\n" +
	"durationMs\x12\x18\n" +
	"\amessage\x18\x06 \x01(\tR\amessage\"H\n" +
	"!ResolveMissionDependenciesRequest\x12#\n" +
	"\rworkflow_path\x18\x01 \x01(\tR\fworkflowPath\"\x8e\x01\n" +
	"\"ResolveMissionDependenciesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x124\n" +
	"\x04tree\x18\x02 \x01(\v2 .gibson.daemon.v1.DependencyTreeR\x04tree\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"I\n" +
	"\"ValidateMissionDependenciesRequest\x12#\n" +
	"\rworkflow_path\x18\x01 \x01(\tR\fworkflowPath\"\x95\x01\n" +
	"#ValidateMissionDependenciesResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12:\n" +
	"\x06result\x18\x02 \x01(\v2\".gibson.daemon.v1.ValidationResultR\x06result\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"f\n" +
	" EnsureDependenciesRunningRequest\x12#\n" +
	"\rworkflow_path\x18\x01 \x01(\tR\fworkflowPath\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x02 \x01(\x03R\ttimeoutMs\"\xa1\x01\n" +
	"!EnsureDependenciesRunningResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rstarted_count\x18\x02 \x01(\x05R\fstartedCount\x12#\n" +
	"\rskipped_count\x18\x03 \x01(\x05R\fskippedCount\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"\xd7\x03\n" +
	"\x0eDependencyTree\x126\n" +
	"\x05roots\x18\x01 \x03(\v2 .gibson.daemon.v1.DependencyNodeR\x05roots\x12A\n" +
	"\x05nodes\x18\x02 \x03(\v2+.gibson.daemon.v1.DependencyTree.NodesEntryR\x05nodes\x128\n" +
	"\x06agents\x18\x03 \x03(\v2 .gibson.daemon.v1.DependencyNodeR\x06agents\x126\n" +
	"\x05tools\x18\x04 \x03(\v2 .gibson.daemon.v1.DependencyNodeR\x05tools\x12:\n" +
	"\aplugins\x18\x05 \x03(\v2 .gibson.daemon.v1.DependencyNodeR\aplugins\x12\x1f\n" +
	"\vresolved_at\x18\x06 \x01(\x03R\n" +
	"resolvedAt\x12\x1f\n" +
	"\vmission_ref\x18\a \x01(\tR\n" +
	"missionRef\x1aZ\n" +
	"\n" +
	"NodesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x126\n" +
	"\x05value\x18\x02 \x01(\v2 .gibson.daemon.v1.DependencyNodeR\x05value:\x028\x01\"\xe6\x02\n" +
	"\x0eDependencyNode\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1f\n" +
	"\vrequired_by\x18\x04 \x03(\tR\n" +
	"requiredBy\x12\x1d\n" +
	"\n" +
	"depends_on\x18\x05 \x03(\tR\tdependsOn\x12:\n" +
	"\x06source\x18\x06 \x01(\x0e2\".gibson.daemon.v1.DependencySourceR\x06source\x12\x1d\n" +
	"\n" +
	"source_ref\x18\a \x01(\tR\tsourceRef\x12\x1c\n" +
	"\tinstalled\x18\b \x01(\bR\tinstalled\x12\x18\n" +
	"\arunning\x18\t \x01(\bR\arunning\x12\x18\n" +
	"\ahealthy\x18\n" +
	" \x01(\bR\ahealthy\x12%\n" +
	"\x0eactual_version\x18\v \x01(\tR\ractualVersion\"\xc4\x04\n" +
	"\x10ValidationResult\x12\x14\n" +
	"\x05valid\x18\x01 \x01(\bR\x05valid\x12\x18\n" +
	"\asummary\x18\x02 \x01(\tR\asummary\x12)\n" +
	"\x10total_components\x18\x03 \x01(\x05R\x0ftotalComponents\x12'\n" +
	"\x0finstalled_count\x18\x04 \x01(\x05R\x0einstalledCount\x12#\n" +
	"\rrunning_count\x18\x05 \x01(\x05R\frunningCount\x12#\n" +
	"\rhealthy_count\x18\x06 \x01(\x05R\fhealthyCount\x12E\n" +
	"\rnot_installed\x18\a \x03(\v2 .gibson.daemon.v1.DependencyNodeR\fnotInstalled\x12A\n" +
	"\vnot_running\x18\b \x03(\v2 .gibson.daemon.v1.DependencyNodeR\n" +
	"notRunning\x12>\n" +
	"\tunhealthy\x18\t \x03(\v2 .gibson.daemon.v1.DependencyNodeR\tunhealthy\x12T\n" +
	"\x12version_mismatches\x18\n" +
	" \x03(\v2%.gibson.daemon.v1.VersionMismatchInfoR\x11versionMismatches\x12!\n" +
	"\fvalidated_at\x18\v \x01(\x03R\vvalidatedAt\x12\x1f\n" +
	"\vduration_ms\x18\f \x01(\x03R\n" +
	"durationMs\"\x9d\x01\n" +
	"\x13VersionMismatchInfo\x124\n" +
	"\x04node\x18\x01 \x01(\v2 .gibson.daemon.v1.DependencyNodeR\x04node\x12)\n" +
	"\x10required_version\x18\x02 \x01(\tR\x0frequiredVersion\x12%\n" +
	"\x0eactual_version\x18\x03 \x01(\tR\ractualVersion\"\x8c\x04\n" +
	"\aMission\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x127\n" +
	"\x06status\x18\x03 \x01(\x0e2\x1f.gibson.daemon.v1.MissionStatusR\x06status\x12\x1b\n" +
	"\ttarget_id\x18\x04 \x01(\tR\btargetId\x12\x1f\n" +
	"\vworkflow_id\x18\x05 \x01(\tR\n" +
	"workflowId\x12F\n" +
	"\vconstraints\x18\x06 \x01(\v2$.gibson.daemon.v1.MissionConstraintsR\vconstraints\x12:\n" +
	"\ametrics\x18\a \x01(\v2 .gibson.daemon.v1.MissionMetricsR\ametrics\x12C\n" +
	"\n" +
	"checkpoint\x18\b \x01(\v2#.gibson.daemon.v1.MissionCheckpointR\n" +
	"checkpoint\x12\x1d\n" +
	"\n" +
	"run_number\x18\t \x01(\x05R\trunNumber\x12\x1d\n" +
	"\n" +
	"created_at\x18\n" +
	" \x01(\x03R\tcreatedAt\x12\x1d\n" +
	"\n" +
	"updated_at\x18\v \x01(\x03R\tupdatedAt\x12\x1d\n" +
	"\n" +
	"started_at\x18\f \x01(\x03R\tstartedAt\x12!\n" +
	"\fcompleted_at\x18\r \x01(\x03R\vcompletedAt\"\x95\x02\n" +
	"\x12MissionConstraints\x120\n" +
	"\x14max_duration_seconds\x18\x01 \x01(\x05R\x12maxDurationSeconds\x12!\n" +
	"\fmax_findings\x18\x02 \x01(\x05R\vmaxFindings\x12\x1d\n" +
	"\n" +
	"max_tokens\x18\x03 \x01(\x05R\tmaxTokens\x12-\n" +
	"\x13max_turns_per_agent\x18\x04 \x01(\x05R\x10maxTurnsPerAgent\x12-\n" +
	"\x12allowed_techniques\x18\x05 \x03(\tR\x11allowedTechniques\x12-\n" +
	"\x12blocked_techniques\x18\x06 \x03(\tR\x11blockedTechniques\"\xc7\x02\n" +
	"\x0eMissionMetrics\x12\x1d\n" +
	"\n" +
	"turns_used\x18\x01 \x01(\x05R\tturnsUsed\x12%\n" +
	"\x0enodes_executed\x18\x02 \x01(\x05R\rnodesExecuted\x12!\n" +
	"\fnodes_failed\x18\x03 \x01(\x05R\vnodesFailed\x12%\n" +
	"\x0efindings_count\x18\x04 \x01(\x05R\rfindingsCount\x12%\n" +
	"\x0ecritical_count\x18\x05 \x01(\x05R\rcriticalCount\x12\x1d\n" +
	"\n" +
	"high_count\x18\x06 \x01(\x05R\thighCount\x12!\n" +
	"\fmedium_count\x18\a \x01(\x05R\vmediumCount\x12\x1b\n" +
	"\tlow_count\x18\b \x01(\x05R\blowCount\x12\x1f\n" +
	"\vtokens_used\x18\t \x01(\x03R\n" +
	"tokensUsed\"\xc5\x01\n" +
	"\x11MissionCheckpoint\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x18\n" +
	"\aversion\x18\x02 \x01(\x05R\aversion\x12'\n" +
	"\x0fcompleted_nodes\x18\x03 \x01(\x05R\x0ecompletedNodes\x12\x1f\n" +
	"\vtotal_nodes\x18\x04 \x01(\x05R\n" +
	"totalNodes\x12\x1d\n" +
	"\n" +
	"created_at\x18\x05 \x01(\x03R\tcreatedAt\x12\x1d\n" +
	"\n" +
	"state_data\x18\x06 \x01(\fR\tstateData\"\xdc\x01\n" +
	"\x11MissionDefinition\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x16\n" +
	"\x06source\x18\x04 \x01(\tR\x06source\x12\x1d\n" +
	"\n" +
	"node_count\x18\x05 \x01(\x05R\tnodeCount\x12!\n" +
	"\finstalled_at\x18\x06 \x01(\x03R\vinstalledAt\x12\x1d\n" +
	"\n" +
	"updated_at\x18\a \x01(\x03R\tupdatedAt*\xd9\x01\n" +
	"\rMissionStatus\x12\x1e\n" +
	"\x1aMISSION_STATUS_UNSPECIFIED\x10\x00\x12\x1a\n" +
	"\x16MISSION_STATUS_PENDING\x10\x01\x12\x1a\n" +
	"\x16MISSION_STATUS_RUNNING\x10\x02\x12\x19\n" +
	"\x15MISSION_STATUS_PAUSED\x10\x03\x12\x1c\n" +
	"\x18MISSION_STATUS_COMPLETED\x10\x04\x12\x19\n" +
	"\x15MISSION_STATUS_FAILED\x10\x05\x12\x1c\n" +
	"\x18MISSION_STATUS_CANCELLED\x10\x06*q\n" +
	"\x10DependencySource\x12\x12\n" +
	"\x0eSOURCE_UNKNOWN\x10\x00\x12\x1b\n" +
	"\x17SOURCE_MISSION_EXPLICIT\x10\x01\x12\x17\n" +
	"\x13SOURCE_MISSION_NODE\x10\x02\x12\x13\n" +
	"\x0fSOURCE_MANIFEST\x10\x032\xc6\x1b\n" +
	"\rDaemonService\x12N\n" +
	"\aConnect\x12 .gibson.daemon.v1.ConnectRequest\x1a!.gibson.daemon.v1.ConnectResponse\x12E\n" +
	"\x04Ping\x12\x1d.gibson.daemon.v1.PingRequest\x1a\x1e.gibson.daemon.v1.PingResponse\x12K\n" +
	"\x06Status\x12\x1f.gibson.daemon.v1.StatusRequest\x1a .gibson.daemon.v1.StatusResponse\x12S\n" +
	"\n" +
	"RunMission\x12#.gibson.daemon.v1.RunMissionRequest\x1a\x1e.gibson.daemon.v1.MissionEvent0\x01\x12Z\n" +
	"\vStopMission\x12$.gibson.daemon.v1.StopMissionRequest\x1a%.gibson.daemon.v1.StopMissionResponse\x12]\n" +
	"\fListMissions\x12%.gibson.daemon.v1.ListMissionsRequest\x1a&.gibson.daemon.v1.ListMissionsResponse\x12W\n" +
	"\n" +
	"ListAgents\x12#.gibson.daemon.v1.ListAgentsRequest\x1a$.gibson.daemon.v1.ListAgentsResponse\x12`\n" +
	"\x0eGetAgentStatus\x12'.gibson.daemon.v1.GetAgentStatusRequest\x1a%.gibson.daemon.v1.AgentStatusResponse\x12T\n" +
	"\tListTools\x12\".gibson.daemon.v1.ListToolsRequest\x1a#.gibson.daemon.v1.ListToolsResponse\x12Z\n" +
	"\vListPlugins\x12$.gibson.daemon.v1.ListPluginsRequest\x1a%.gibson.daemon.v1.ListPluginsResponse\x12Z\n" +
	"\vQueryPlugin\x12$.gibson.daemon.v1.QueryPluginRequest\x1a%.gibson.daemon.v1.QueryPluginResponse\x12P\n" +
	"\tRunAttack\x12\".gibson.daemon.v1.RunAttackRequest\x1a\x1d.gibson.daemon.v1.AttackEvent0\x01\x12J\n" +
	"\tSubscribe\x12\".gibson.daemon.v1.SubscribeRequest\x1a\x17.gibson.daemon.v1.Event0\x01\x12c\n" +
	"\x0eStartComponent\x12'.gibson.daemon.v1.StartComponentRequest\x1a(.gibson.daemon.v1.StartComponentResponse\x12`\n" +
	"\rStopComponent\x12&.gibson.daemon.v1.StopComponentRequest\x1a'.gibson.daemon.v1.StopComponentResponse\x12]\n" +
	"\fPauseMission\x12%.gibson.daemon.v1.PauseMissionRequest\x1a&.gibson.daemon.v1.PauseMissionResponse\x12Y\n" +
	"\rResumeMission\x12&.gibson.daemon.v1.ResumeMissionRequest\x1a\x1e.gibson.daemon.v1.MissionEvent0\x01\x12l\n" +
	"\x11GetMissionHistory\x12*.gibson.daemon.v1.GetMissionHistoryRequest\x1a+.gibson.daemon.v1.GetMissionHistoryResponse\x12x\n" +
	"\x15GetMissionCheckpoints\x12..gibson.daemon.v1.GetMissionCheckpointsRequest\x1a/.gibson.daemon.v1.GetMissionCheckpointsResponse\x12Z\n" +
	"\vExecuteTool\x12$.gibson.daemon.v1.ExecuteToolRequest\x1a%.gibson.daemon.v1.ExecuteToolResponse\x12l\n" +
	"\x11GetAvailableTools\x12*.gibson.daemon.v1.GetAvailableToolsRequest\x1a+.gibson.daemon.v1.GetAvailableToolsResponse\x12i\n" +
	"\x10InstallComponent\x12).gibson.daemon.v1.InstallComponentRequest\x1a*.gibson.daemon.v1.InstallComponentResponse\x12r\n" +
	"\x13InstallAllComponent\x12,.gibson.daemon.v1.InstallAllComponentRequest\x1a-.gibson.daemon.v1.InstallAllComponentResponse\x12o\n" +
	"\x12UninstallComponent\x12+.gibson.daemon.v1.UninstallComponentRequest\x1a,.gibson.daemon.v1.UninstallComponentResponse\x12f\n" +
	"\x0fUpdateComponent\x12(.gibson.daemon.v1.UpdateComponentRequest\x1a).gibson.daemon.v1.UpdateComponentResponse\x12c\n" +
	"\x0eBuildComponent\x12'.gibson.daemon.v1.BuildComponentRequest\x1a(.gibson.daemon.v1.BuildComponentResponse\x12`\n" +
	"\rShowComponent\x12&.gibson.daemon.v1.ShowComponentRequest\x1a'.gibson.daemon.v1.ShowComponentResponse\x12[\n" +
	"\x10GetComponentLogs\x12).gibson.daemon.v1.GetComponentLogsRequest\x1a\x1a.gibson.daemon.v1.LogEntry0\x01\x12c\n" +
	"\x0eInstallMission\x12'.gibson.daemon.v1.InstallMissionRequest\x1a(.gibson.daemon.v1.InstallMissionResponse\x12i\n" +
	"\x10UninstallMission\x12).gibson.daemon.v1.UninstallMissionRequest\x1a*.gibson.daemon.v1.UninstallMissionResponse\x12{\n" +
	"\x16ListMissionDefinitions\x12/.gibson.daemon.v1.ListMissionDefinitionsRequest\x1a0.gibson.daemon.v1.ListMissionDefinitionsResponse\x12`\n" +
	"\rUpdateMission\x12&.gibson.daemon.v1.UpdateMissionRequest\x1a'.gibson.daemon.v1.UpdateMissionResponse\x12\x87\x01\n" +
	"\x1aResolveMissionDependencies\x123.gibson.daemon.v1.ResolveMissionDependenciesRequest\x1a4.gibson.daemon.v1.ResolveMissionDependenciesResponse\x12\x8a\x01\n" +
	"\x1bValidateMissionDependencies\x124.gibson.daemon.v1.ValidateMissionDependenciesRequest\x1a5.gibson.daemon.v1.ValidateMissionDependenciesResponse\x12\x84\x01\n" +
	"\x19EnsureDependenciesRunning\x122.gibson.daemon.v1.EnsureDependenciesRunningRequest\x1a3.gibson.daemon.v1.EnsureDependenciesRunningResponseB7Z5github.com/zero-day-ai/gibson/internal/daemon/api;apib\x06proto3"

var (
	file_daemon_proto_rawDescOnce sync.Once
	file_daemon_proto_rawDescData []byte
)

func file_daemon_proto_rawDescGZIP() []byte {
	file_daemon_proto_rawDescOnce.Do(func() {
		file_daemon_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_daemon_proto_rawDesc), len(file_daemon_proto_rawDesc)))
	})
	return file_daemon_proto_rawDescData
}

var file_daemon_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 105)
var file_daemon_proto_goTypes = []any{
	(MissionStatus)(0),                          // 0: gibson.daemon.v1.MissionStatus
	(DependencySource)(0),                       // 1: gibson.daemon.v1.DependencySource
	(*ConnectRequest)(nil),                      // 2: gibson.daemon.v1.ConnectRequest
	(*ConnectResponse)(nil),                     // 3: gibson.daemon.v1.ConnectResponse
	(*PingRequest)(nil),                         // 4: gibson.daemon.v1.PingRequest
	(*PingResponse)(nil),                        // 5: gibson.daemon.v1.PingResponse
	(*StatusRequest)(nil),                       // 6: gibson.daemon.v1.StatusRequest
	(*StatusResponse)(nil),                      // 7: gibson.daemon.v1.StatusResponse
	(*RunMissionRequest)(nil),                   // 8: gibson.daemon.v1.RunMissionRequest
	(*MissionEvent)(nil),                        // 9: gibson.daemon.v1.MissionEvent
	(*StopMissionRequest)(nil),                  // 10: gibson.daemon.v1.StopMissionRequest
	(*StopMissionResponse)(nil),                 // 11: gibson.daemon.v1.StopMissionResponse
	(*ListMissionsRequest)(nil),                 // 12: gibson.daemon.v1.ListMissionsRequest
	(*ListMissionsResponse)(nil),                // 13: gibson.daemon.v1.ListMissionsResponse
	(*MissionInfo)(nil),                         // 14: gibson.daemon.v1.MissionInfo
	(*ListAgentsRequest)(nil),                   // 15: gibson.daemon.v1.ListAgentsRequest
	(*ListAgentsResponse)(nil),                  // 16: gibson.daemon.v1.ListAgentsResponse
	(*AgentInfo)(nil),                           // 17: gibson.daemon.v1.AgentInfo
	(*GetAgentStatusRequest)(nil),               // 18: gibson.daemon.v1.GetAgentStatusRequest
	(*AgentStatusResponse)(nil),                 // 19: gibson.daemon.v1.AgentStatusResponse
	(*ListToolsRequest)(nil),                    // 20: gibson.daemon.v1.ListToolsRequest
	(*ListToolsResponse)(nil),                   // 21: gibson.daemon.v1.ListToolsResponse
	(*ToolInfo)(nil),                            // 22: gibson.daemon.v1.ToolInfo
	(*ListPluginsRequest)(nil),                  // 23: gibson.daemon.v1.ListPluginsRequest
	(*ListPluginsResponse)(nil),                 // 24: gibson.daemon.v1.ListPluginsResponse
	(*PluginInfo)(nil),                          // 25: gibson.daemon.v1.PluginInfo
	(*QueryPluginRequest)(nil),                  // 26: gibson.daemon.v1.QueryPluginRequest
	(*QueryPluginResponse)(nil),                 // 27: gibson.daemon.v1.QueryPluginResponse
	(*RunAttackRequest)(nil),                    // 28: gibson.daemon.v1.RunAttackRequest
	(*AttackEvent)(nil),                         // 29: gibson.daemon.v1.AttackEvent
	(*FindingInfo)(nil),                         // 30: gibson.daemon.v1.FindingInfo
	(*SubscribeRequest)(nil),                    // 31: gibson.daemon.v1.SubscribeRequest
	(*Event)(nil),                               // 32: gibson.daemon.v1.Event
	(*AgentEvent)(nil),                          // 33: gibson.daemon.v1.AgentEvent
	(*FindingEvent)(nil),                        // 34: gibson.daemon.v1.FindingEvent
	(*StartComponentRequest)(nil),               // 35: gibson.daemon.v1.StartComponentRequest
	(*StartComponentResponse)(nil),              // 36: gibson.daemon.v1.StartComponentResponse
	(*StopComponentRequest)(nil),                // 37: gibson.daemon.v1.StopComponentRequest
	(*StopComponentResponse)(nil),               // 38: gibson.daemon.v1.StopComponentResponse
	(*OperationResult)(nil),                     // 39: gibson.daemon.v1.OperationResult
	(*PauseMissionRequest)(nil),                 // 40: gibson.daemon.v1.PauseMissionRequest
	(*PauseMissionResponse)(nil),                // 41: gibson.daemon.v1.PauseMissionResponse
	(*ResumeMissionRequest)(nil),                // 42: gibson.daemon.v1.ResumeMissionRequest
	(*GetMissionHistoryRequest)(nil),            // 43: gibson.daemon.v1.GetMissionHistoryRequest
	(*GetMissionHistoryResponse)(nil),           // 44: gibson.daemon.v1.GetMissionHistoryResponse
	(*MissionRun)(nil),                          // 45: gibson.daemon.v1.MissionRun
	(*GetMissionCheckpointsRequest)(nil),        // 46: gibson.daemon.v1.GetMissionCheckpointsRequest
	(*GetMissionCheckpointsResponse)(nil),       // 47: gibson.daemon.v1.GetMissionCheckpointsResponse
	(*CheckpointInfo)(nil),                      // 48: gibson.daemon.v1.CheckpointInfo
	(*ExecuteToolRequest)(nil),                  // 49: gibson.daemon.v1.ExecuteToolRequest
	(*ExecuteToolResponse)(nil),                 // 50: gibson.daemon.v1.ExecuteToolResponse
	(*GetAvailableToolsRequest)(nil),            // 51: gibson.daemon.v1.GetAvailableToolsRequest
	(*GetAvailableToolsResponse)(nil),           // 52: gibson.daemon.v1.GetAvailableToolsResponse
	(*AvailableToolInfo)(nil),                   // 53: gibson.daemon.v1.AvailableToolInfo
	(*ToolExecutionMetrics)(nil),                // 54: gibson.daemon.v1.ToolExecutionMetrics
	(*JSONSchemaNode)(nil),                      // 55: gibson.daemon.v1.JSONSchemaNode
	(*TaxonomyMapping)(nil),                     // 56: gibson.daemon.v1.TaxonomyMapping
	(*PropertyMapping)(nil),                     // 57: gibson.daemon.v1.PropertyMapping
	(*NodeReference)(nil),                       // 58: gibson.daemon.v1.NodeReference
	(*RelationshipMapping)(nil),                 // 59: gibson.daemon.v1.RelationshipMapping
	(*InstallComponentRequest)(nil),             // 60: gibson.daemon.v1.InstallComponentRequest
	(*InstallComponentResponse)(nil),            // 61: gibson.daemon.v1.InstallComponentResponse
	(*InstallAllComponentRequest)(nil),          // 62: gibson.daemon.v1.InstallAllComponentRequest
	(*InstallAllComponentResponse)(nil),         // 63: gibson.daemon.v1.InstallAllComponentResponse
	(*InstallAllResultItem)(nil),                // 64: gibson.daemon.v1.InstallAllResultItem
	(*InstallAllFailedItem)(nil),                // 65: gibson.daemon.v1.InstallAllFailedItem
	(*UninstallComponentRequest)(nil),           // 66: gibson.daemon.v1.UninstallComponentRequest
	(*UninstallComponentResponse)(nil),          // 67: gibson.daemon.v1.UninstallComponentResponse
	(*UpdateComponentRequest)(nil),              // 68: gibson.daemon.v1.UpdateComponentRequest
	(*UpdateComponentResponse)(nil),             // 69: gibson.daemon.v1.UpdateComponentResponse
	(*BuildComponentRequest)(nil),               // 70: gibson.daemon.v1.BuildComponentRequest
	(*BuildComponentResponse)(nil),              // 71: gibson.daemon.v1.BuildComponentResponse
	(*ShowComponentRequest)(nil),                // 72: gibson.daemon.v1.ShowComponentRequest
	(*ShowComponentResponse)(nil),               // 73: gibson.daemon.v1.ShowComponentResponse
	(*GetComponentLogsRequest)(nil),             // 74: gibson.daemon.v1.GetComponentLogsRequest
	(*LogEntry)(nil),                            // 75: gibson.daemon.v1.LogEntry
	(*InstallMissionRequest)(nil),               // 76: gibson.daemon.v1.InstallMissionRequest
	(*InstallMissionResponse)(nil),              // 77: gibson.daemon.v1.InstallMissionResponse
	(*InstalledDependency)(nil),                 // 78: gibson.daemon.v1.InstalledDependency
	(*UninstallMissionRequest)(nil),             // 79: gibson.daemon.v1.UninstallMissionRequest
	(*UninstallMissionResponse)(nil),            // 80: gibson.daemon.v1.UninstallMissionResponse
	(*ListMissionDefinitionsRequest)(nil),       // 81: gibson.daemon.v1.ListMissionDefinitionsRequest
	(*ListMissionDefinitionsResponse)(nil),      // 82: gibson.daemon.v1.ListMissionDefinitionsResponse
	(*MissionDefinitionInfo)(nil),               // 83: gibson.daemon.v1.MissionDefinitionInfo
	(*UpdateMissionRequest)(nil),                // 84: gibson.daemon.v1.UpdateMissionRequest
	(*UpdateMissionResponse)(nil),               // 85: gibson.daemon.v1.UpdateMissionResponse
	(*ResolveMissionDependenciesRequest)(nil),   // 86: gibson.daemon.v1.ResolveMissionDependenciesRequest
	(*ResolveMissionDependenciesResponse)(nil),  // 87: gibson.daemon.v1.ResolveMissionDependenciesResponse
	(*ValidateMissionDependenciesRequest)(nil),  // 88: gibson.daemon.v1.ValidateMissionDependenciesRequest
	(*ValidateMissionDependenciesResponse)(nil), // 89: gibson.daemon.v1.ValidateMissionDependenciesResponse
	(*EnsureDependenciesRunningRequest)(nil),    // 90: gibson.daemon.v1.EnsureDependenciesRunningRequest
	(*EnsureDependenciesRunningResponse)(nil),   // 91: gibson.daemon.v1.EnsureDependenciesRunningResponse
	(*DependencyTree)(nil),                      // 92: gibson.daemon.v1.DependencyTree
	(*DependencyNode)(nil),                      // 93: gibson.daemon.v1.DependencyNode
	(*ValidationResult)(nil),                    // 94: gibson.daemon.v1.ValidationResult
	(*VersionMismatchInfo)(nil),                 // 95: gibson.daemon.v1.VersionMismatchInfo
	(*Mission)(nil),                             // 96: gibson.daemon.v1.Mission
	(*MissionConstraints)(nil),                  // 97: gibson.daemon.v1.MissionConstraints
	(*MissionMetrics)(nil),                      // 98: gibson.daemon.v1.MissionMetrics
	(*MissionCheckpoint)(nil),                   // 99: gibson.daemon.v1.MissionCheckpoint
	(*MissionDefinition)(nil),                   // 100: gibson.daemon.v1.MissionDefinition
	nil,                                         // 101: gibson.daemon.v1.RunMissionRequest.VariablesEntry
	nil,                                         // 102: gibson.daemon.v1.RunAttackRequest.OptionsEntry
	nil,                                         // 103: gibson.daemon.v1.JSONSchemaNode.PropertiesEntry
	nil,                                         // 104: gibson.daemon.v1.TaxonomyMapping.IdentifyingPropertiesEntry
	nil,                                         // 105: gibson.daemon.v1.NodeReference.PropertiesEntry
	nil,                                         // 106: gibson.daemon.v1.DependencyTree.NodesEntry
	(*proto.TypedMap)(nil),                      // 107: gibson.common.TypedMap
	(*proto.TypedValue)(nil),                    // 108: gibson.common.TypedValue
}
var file_daemon_proto_depIdxs = []int32{
	101, // 0: gibson.daemon.v1.RunMissionRequest.variables:type_name -> gibson.daemon.v1.RunMissionRequest.VariablesEntry
	107, // 1: gibson.daemon.v1.MissionEvent.data:type_name -> gibson.common.TypedMap
	39,  // 2: gibson.daemon.v1.MissionEvent.result:type_name -> gibson.daemon.v1.OperationResult
	14,  // 3: gibson.daemon.v1.ListMissionsResponse.missions:type_name -> gibson.daemon.v1.MissionInfo
	17,  // 4: gibson.daemon.v1.ListAgentsResponse.agents:type_name -> gibson.daemon.v1.AgentInfo
	17,  // 5: gibson.daemon.v1.AgentStatusResponse.agent:type_name -> gibson.daemon.v1.AgentInfo
	22,  // 6: gibson.daemon.v1.ListToolsResponse.tools:type_name -> gibson.daemon.v1.ToolInfo
	25,  // 7: gibson.daemon.v1.ListPluginsResponse.plugins:type_name -> gibson.daemon.v1.PluginInfo
	107, // 8: gibson.daemon.v1.QueryPluginRequest.params:type_name -> gibson.common.TypedMap
	108, // 9: gibson.daemon.v1.QueryPluginResponse.result:type_name -> gibson.common.TypedValue
	102, // 10: gibson.daemon.v1.RunAttackRequest.options:type_name -> gibson.daemon.v1.RunAttackRequest.OptionsEntry
	107, // 11: gibson.daemon.v1.AttackEvent.data:type_name -> gibson.common.TypedMap
	30,  // 12: gibson.daemon.v1.AttackEvent.finding:type_name -> gibson.daemon.v1.FindingInfo
	39,  // 13: gibson.daemon.v1.AttackEvent.result:type_name -> gibson.daemon.v1.OperationResult
	107, // 14: gibson.daemon.v1.Event.data:type_name -> gibson.common.TypedMap
	9,   // 15: gibson.daemon.v1.Event.mission_event:type_name -> gibson.daemon.v1.MissionEvent
	29,  // 16: gibson.daemon.v1.Event.attack_event:type_name -> gibson.daemon.v1.AttackEvent
	33,  // 17: gibson.daemon.v1.Event.agent_event:type_name -> gibson.daemon.v1.AgentEvent
	34,  // 18: gibson.daemon.v1.Event.finding_event:type_name -> gibson.daemon.v1.FindingEvent
	107, // 19: gibson.daemon.v1.AgentEvent.data:type_name -> gibson.common.TypedMap
	30,  // 20: gibson.daemon.v1.FindingEvent.finding:type_name -> gibson.daemon.v1.FindingInfo
	45,  // 21: gibson.daemon.v1.GetMissionHistoryResponse.runs:type_name -> gibson.daemon.v1.MissionRun
	48,  // 22: gibson.daemon.v1.GetMissionCheckpointsResponse.checkpoints:type_name -> gibson.daemon.v1.CheckpointInfo
	107, // 23: gibson.daemon.v1.ExecuteToolRequest.input:type_name -> gibson.common.TypedMap
	108, // 24: gibson.daemon.v1.ExecuteToolResponse.output:type_name -> gibson.common.TypedValue
	53,  // 25: gibson.daemon.v1.GetAvailableToolsResponse.tools:type_name -> gibson.daemon.v1.AvailableToolInfo
	54,  // 26: gibson.daemon.v1.AvailableToolInfo.metrics:type_name -> gibson.daemon.v1.ToolExecutionMetrics
	55,  // 27: gibson.daemon.v1.AvailableToolInfo.input_schema:type_name -> gibson.daemon.v1.JSONSchemaNode
	55,  // 28: gibson.daemon.v1.AvailableToolInfo.output_schema:type_name -> gibson.daemon.v1.JSONSchemaNode
	103, // 29: gibson.daemon.v1.JSONSchemaNode.properties:type_name -> gibson.daemon.v1.JSONSchemaNode.PropertiesEntry
	55,  // 30: gibson.daemon.v1.JSONSchemaNode.items:type_name -> gibson.daemon.v1.JSONSchemaNode
	56,  // 31: gibson.daemon.v1.JSONSchemaNode.taxonomy:type_name -> gibson.daemon.v1.TaxonomyMapping
	104, // 32: gibson.daemon.v1.TaxonomyMapping.identifying_properties:type_name -> gibson.daemon.v1.TaxonomyMapping.IdentifyingPropertiesEntry
	57,  // 33: gibson.daemon.v1.TaxonomyMapping.properties:type_name -> gibson.daemon.v1.PropertyMapping
	59,  // 34: gibson.daemon.v1.TaxonomyMapping.relationships:type_name -> gibson.daemon.v1.RelationshipMapping
	105, // 35: gibson.daemon.v1.NodeReference.properties:type_name -> gibson.daemon.v1.NodeReference.PropertiesEntry
	58,  // 36: gibson.daemon.v1.RelationshipMapping.from:type_name -> gibson.daemon.v1.NodeReference
	58,  // 37: gibson.daemon.v1.RelationshipMapping.to:type_name -> gibson.daemon.v1.NodeReference
	57,  // 38: gibson.daemon.v1.RelationshipMapping.rel_properties:type_name -> gibson.daemon.v1.PropertyMapping
	64,  // 39: gibson.daemon.v1.InstallAllComponentResponse.successful:type_name -> gibson.daemon.v1.InstallAllResultItem
	64,  // 40: gibson.daemon.v1.InstallAllComponentResponse.skipped:type_name -> gibson.daemon.v1.InstallAllResultItem
	65,  // 41: gibson.daemon.v1.InstallAllComponentResponse.failed:type_name -> gibson.daemon.v1.InstallAllFailedItem
	107, // 42: gibson.daemon.v1.LogEntry.fields:type_name -> gibson.common.TypedMap
	78,  // 43: gibson.daemon.v1.InstallMissionResponse.dependencies:type_name -> gibson.daemon.v1.InstalledDependency
	83,  // 44: gibson.daemon.v1.ListMissionDefinitionsResponse.missions:type_name -> gibson.daemon.v1.MissionDefinitionInfo
	92,  // 45: gibson.daemon.v1.ResolveMissionDependenciesResponse.tree:type_name -> gibson.daemon.v1.DependencyTree
	94,  // 46: gibson.daemon.v1.ValidateMissionDependenciesResponse.result:type_name -> gibson.daemon.v1.ValidationResult
	93,  // 47: gibson.daemon.v1.DependencyTree.roots:type_name -> gibson.daemon.v1.DependencyNode
	106, // 48: gibson.daemon.v1.DependencyTree.nodes:type_name -> gibson.daemon.v1.DependencyTree.NodesEntry
	93,  // 49: gibson.daemon.v1.DependencyTree.agents:type_name -> gibson.daemon.v1.DependencyNode
	93,  // 50: gibson.daemon.v1.DependencyTree.tools:type_name -> gibson.daemon.v1.DependencyNode
	93,  // 51: gibson.daemon.v1.DependencyTree.plugins:type_name -> gibson.daemon.v1.DependencyNode
	1,   // 52: gibson.daemon.v1.DependencyNode.source:type_name -> gibson.daemon.v1.DependencySource
	93,  // 53: gibson.daemon.v1.ValidationResult.not_installed:type_name -> gibson.daemon.v1.DependencyNode
	93,  // 54: gibson.daemon.v1.ValidationResult.not_running:type_name -> gibson.daemon.v1.DependencyNode
	93,  // 55: gibson.daemon.v1.ValidationResult.unhealthy:type_name -> gibson.daemon.v1.DependencyNode
	95,  // 56: gibson.daemon.v1.ValidationResult.version_mismatches:type_name -> gibson.daemon.v1.VersionMismatchInfo
	93,  // 57: gibson.daemon.v1.VersionMismatchInfo.node:type_name -> gibson.daemon.v1.DependencyNode
	0,   // 58: gibson.daemon.v1.Mission.status:type_name -> gibson.daemon.v1.MissionStatus
	97,  // 59: gibson.daemon.v1.Mission.constraints:type_name -> gibson.daemon.v1.MissionConstraints
	98,  // 60: gibson.daemon.v1.Mission.metrics:type_name -> gibson.daemon.v1.MissionMetrics
	99,  // 61: gibson.daemon.v1.Mission.checkpoint:type_name -> gibson.daemon.v1.MissionCheckpoint
	55,  // 62: gibson.daemon.v1.JSONSchemaNode.PropertiesEntry.value:type_name -> gibson.daemon.v1.JSONSchemaNode
	93,  // 63: gibson.daemon.v1.DependencyTree.NodesEntry.value:type_name -> gibson.daemon.v1.DependencyNode
	2,   // 64: gibson.daemon.v1.DaemonService.Connect:input_type -> gibson.daemon.v1.ConnectRequest
	4,   // 65: gibson.daemon.v1.DaemonService.Ping:input_type -> gibson.daemon.v1.PingRequest
	6,   // 66: gibson.daemon.v1.DaemonService.Status:input_type -> gibson.daemon.v1.StatusRequest
	8,   // 67: gibson.daemon.v1.DaemonService.RunMission:input_type -> gibson.daemon.v1.RunMissionRequest
	10,  // 68: gibson.daemon.v1.DaemonService.StopMission:input_type -> gibson.daemon.v1.StopMissionRequest
	12,  // 69: gibson.daemon.v1.DaemonService.ListMissions:input_type -> gibson.daemon.v1.ListMissionsRequest
	15,  // 70: gibson.daemon.v1.DaemonService.ListAgents:input_type -> gibson.daemon.v1.ListAgentsRequest
	18,  // 71: gibson.daemon.v1.DaemonService.GetAgentStatus:input_type -> gibson.daemon.v1.GetAgentStatusRequest
	20,  // 72: gibson.daemon.v1.DaemonService.ListTools:input_type -> gibson.daemon.v1.ListToolsRequest
	23,  // 73: gibson.daemon.v1.DaemonService.ListPlugins:input_type -> gibson.daemon.v1.ListPluginsRequest
	26,  // 74: gibson.daemon.v1.DaemonService.QueryPlugin:input_type -> gibson.daemon.v1.QueryPluginRequest
	28,  // 75: gibson.daemon.v1.DaemonService.RunAttack:input_type -> gibson.daemon.v1.RunAttackRequest
	31,  // 76: gibson.daemon.v1.DaemonService.Subscribe:input_type -> gibson.daemon.v1.SubscribeRequest
	35,  // 77: gibson.daemon.v1.DaemonService.StartComponent:input_type -> gibson.daemon.v1.StartComponentRequest
	37,  // 78: gibson.daemon.v1.DaemonService.StopComponent:input_type -> gibson.daemon.v1.StopComponentRequest
	40,  // 79: gibson.daemon.v1.DaemonService.PauseMission:input_type -> gibson.daemon.v1.PauseMissionRequest
	42,  // 80: gibson.daemon.v1.DaemonService.ResumeMission:input_type -> gibson.daemon.v1.ResumeMissionRequest
	43,  // 81: gibson.daemon.v1.DaemonService.GetMissionHistory:input_type -> gibson.daemon.v1.GetMissionHistoryRequest
	46,  // 82: gibson.daemon.v1.DaemonService.GetMissionCheckpoints:input_type -> gibson.daemon.v1.GetMissionCheckpointsRequest
	49,  // 83: gibson.daemon.v1.DaemonService.ExecuteTool:input_type -> gibson.daemon.v1.ExecuteToolRequest
	51,  // 84: gibson.daemon.v1.DaemonService.GetAvailableTools:input_type -> gibson.daemon.v1.GetAvailableToolsRequest
	60,  // 85: gibson.daemon.v1.DaemonService.InstallComponent:input_type -> gibson.daemon.v1.InstallComponentRequest
	62,  // 86: gibson.daemon.v1.DaemonService.InstallAllComponent:input_type -> gibson.daemon.v1.InstallAllComponentRequest
	66,  // 87: gibson.daemon.v1.DaemonService.UninstallComponent:input_type -> gibson.daemon.v1.UninstallComponentRequest
	68,  // 88: gibson.daemon.v1.DaemonService.UpdateComponent:input_type -> gibson.daemon.v1.UpdateComponentRequest
	70,  // 89: gibson.daemon.v1.DaemonService.BuildComponent:input_type -> gibson.daemon.v1.BuildComponentRequest
	72,  // 90: gibson.daemon.v1.DaemonService.ShowComponent:input_type -> gibson.daemon.v1.ShowComponentRequest
	74,  // 91: gibson.daemon.v1.DaemonService.GetComponentLogs:input_type -> gibson.daemon.v1.GetComponentLogsRequest
	76,  // 92: gibson.daemon.v1.DaemonService.InstallMission:input_type -> gibson.daemon.v1.InstallMissionRequest
	79,  // 93: gibson.daemon.v1.DaemonService.UninstallMission:input_type -> gibson.daemon.v1.UninstallMissionRequest
	81,  // 94: gibson.daemon.v1.DaemonService.ListMissionDefinitions:input_type -> gibson.daemon.v1.ListMissionDefinitionsRequest
	84,  // 95: gibson.daemon.v1.DaemonService.UpdateMission:input_type -> gibson.daemon.v1.UpdateMissionRequest
	86,  // 96: gibson.daemon.v1.DaemonService.ResolveMissionDependencies:input_type -> gibson.daemon.v1.ResolveMissionDependenciesRequest
	88,  // 97: gibson.daemon.v1.DaemonService.ValidateMissionDependencies:input_type -> gibson.daemon.v1.ValidateMissionDependenciesRequest
	90,  // 98: gibson.daemon.v1.DaemonService.EnsureDependenciesRunning:input_type -> gibson.daemon.v1.EnsureDependenciesRunningRequest
	3,   // 99: gibson.daemon.v1.DaemonService.Connect:output_type -> gibson.daemon.v1.ConnectResponse
	5,   // 100: gibson.daemon.v1.DaemonService.Ping:output_type -> gibson.daemon.v1.PingResponse
	7,   // 101: gibson.daemon.v1.DaemonService.Status:output_type -> gibson.daemon.v1.StatusResponse
	9,   // 102: gibson.daemon.v1.DaemonService.RunMission:output_type -> gibson.daemon.v1.MissionEvent
	11,  // 103: gibson.daemon.v1.DaemonService.StopMission:output_type -> gibson.daemon.v1.StopMissionResponse
	13,  // 104: gibson.daemon.v1.DaemonService.ListMissions:output_type -> gibson.daemon.v1.ListMissionsResponse
	16,  // 105: gibson.daemon.v1.DaemonService.ListAgents:output_type -> gibson.daemon.v1.ListAgentsResponse
	19,  // 106: gibson.daemon.v1.DaemonService.GetAgentStatus:output_type -> gibson.daemon.v1.AgentStatusResponse
	21,  // 107: gibson.daemon.v1.DaemonService.ListTools:output_type -> gibson.daemon.v1.ListToolsResponse
	24,  // 108: gibson.daemon.v1.DaemonService.ListPlugins:output_type -> gibson.daemon.v1.ListPluginsResponse
	27,  // 109: gibson.daemon.v1.DaemonService.QueryPlugin:output_type -> gibson.daemon.v1.QueryPluginResponse
	29,  // 110: gibson.daemon.v1.DaemonService.RunAttack:output_type -> gibson.daemon.v1.AttackEvent
	32,  // 111: gibson.daemon.v1.DaemonService.Subscribe:output_type -> gibson.daemon.v1.Event
	36,  // 112: gibson.daemon.v1.DaemonService.StartComponent:output_type -> gibson.daemon.v1.StartComponentResponse
	38,  // 113: gibson.daemon.v1.DaemonService.StopComponent:output_type -> gibson.daemon.v1.StopComponentResponse
	41,  // 114: gibson.daemon.v1.DaemonService.PauseMission:output_type -> gibson.daemon.v1.PauseMissionResponse
	9,   // 115: gibson.daemon.v1.DaemonService.ResumeMission:output_type -> gibson.daemon.v1.MissionEvent
	44,  // 116: gibson.daemon.v1.DaemonService.GetMissionHistory:output_type -> gibson.daemon.v1.GetMissionHistoryResponse
	47,  // 117: gibson.daemon.v1.DaemonService.GetMissionCheckpoints:output_type -> gibson.daemon.v1.GetMissionCheckpointsResponse
	50,  // 118: gibson.daemon.v1.DaemonService.ExecuteTool:output_type -> gibson.daemon.v1.ExecuteToolResponse
	52,  // 119: gibson.daemon.v1.DaemonService.GetAvailableTools:output_type -> gibson.daemon.v1.GetAvailableToolsResponse
	61,  // 120: gibson.daemon.v1.DaemonService.InstallComponent:output_type -> gibson.daemon.v1.InstallComponentResponse
	63,  // 121: gibson.daemon.v1.DaemonService.InstallAllComponent:output_type -> gibson.daemon.v1.InstallAllComponentResponse
	67,  // 122: gibson.daemon.v1.DaemonService.UninstallComponent:output_type -> gibson.daemon.v1.UninstallComponentResponse
	69,  // 123: gibson.daemon.v1.DaemonService.UpdateComponent:output_type -> gibson.daemon.v1.UpdateComponentResponse
	71,  // 124: gibson.daemon.v1.DaemonService.BuildComponent:output_type -> gibson.daemon.v1.BuildComponentResponse
	73,  // 125: gibson.daemon.v1.DaemonService.ShowComponent:output_type -> gibson.daemon.v1.ShowComponentResponse
	75,  // 126: gibson.daemon.v1.DaemonService.GetComponentLogs:output_type -> gibson.daemon.v1.LogEntry
	77,  // 127: gibson.daemon.v1.DaemonService.InstallMission:output_type -> gibson.daemon.v1.InstallMissionResponse
	80,  // 128: gibson.daemon.v1.DaemonService.UninstallMission:output_type -> gibson.daemon.v1.UninstallMissionResponse
	82,  // 129: gibson.daemon.v1.DaemonService.ListMissionDefinitions:output_type -> gibson.daemon.v1.ListMissionDefinitionsResponse
	85,  // 130: gibson.daemon.v1.DaemonService.UpdateMission:output_type -> gibson.daemon.v1.UpdateMissionResponse
	87,  // 131: gibson.daemon.v1.DaemonService.ResolveMissionDependencies:output_type -> gibson.daemon.v1.ResolveMissionDependenciesResponse
	89,  // 132: gibson.daemon.v1.DaemonService.ValidateMissionDependencies:output_type -> gibson.daemon.v1.ValidateMissionDependenciesResponse
	91,  // 133: gibson.daemon.v1.DaemonService.EnsureDependenciesRunning:output_type -> gibson.daemon.v1.EnsureDependenciesRunningResponse
	99,  // [99:134] is the sub-list for method output_type
	64,  // [64:99] is the sub-list for method input_type
	64,  // [64:64] is the sub-list for extension type_name
	64,  // [64:64] is the sub-list for extension extendee
	0,   // [0:64] is the sub-list for field type_name
}

func init() { file_daemon_proto_init() }
func file_daemon_proto_init() {
	if File_daemon_proto != nil {
		return
	}
	file_daemon_proto_msgTypes[30].OneofWrappers = []any{
		(*Event_MissionEvent)(nil),
		(*Event_AttackEvent)(nil),
		(*Event_AgentEvent)(nil),
		(*Event_FindingEvent)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_daemon_proto_rawDesc), len(file_daemon_proto_rawDesc)),
			NumEnums:      2,
			NumMessages:   105,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_daemon_proto_goTypes,
		DependencyIndexes: file_daemon_proto_depIdxs,
		EnumInfos:         file_daemon_proto_enumTypes,
		MessageInfos:      file_daemon_proto_msgTypes,
	}.Build()
	File_daemon_proto = out.File
	file_daemon_proto_goTypes = nil
	file_daemon_proto_depIdxs = nil
}
