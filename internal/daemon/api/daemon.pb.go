// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v4.25.1
// source: daemon.proto

package api

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// ConnectRequest initiates a client connection to the daemon.
type ConnectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// client_version is the version of the Gibson CLI client
	ClientVersion string `protobuf:"bytes,1,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
	// client_id is an optional unique identifier for this client
	ClientId      string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectRequest) Reset() {
	*x = ConnectRequest{}
	mi := &file_daemon_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectRequest) ProtoMessage() {}

func (x *ConnectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectRequest.ProtoReflect.Descriptor instead.
func (*ConnectRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{0}
}

func (x *ConnectRequest) GetClientVersion() string {
	if x != nil {
		return x.ClientVersion
	}
	return ""
}

func (x *ConnectRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

// ConnectResponse returns connection metadata.
type ConnectResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// daemon_version is the version of the running daemon
	DaemonVersion string `protobuf:"bytes,1,opt,name=daemon_version,json=daemonVersion,proto3" json:"daemon_version,omitempty"`
	// session_id is a unique identifier for this client session
	SessionId string `protobuf:"bytes,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	// grpc_address is the address the daemon is listening on
	GrpcAddress   string `protobuf:"bytes,3,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectResponse) Reset() {
	*x = ConnectResponse{}
	mi := &file_daemon_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectResponse) ProtoMessage() {}

func (x *ConnectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectResponse.ProtoReflect.Descriptor instead.
func (*ConnectResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{1}
}

func (x *ConnectResponse) GetDaemonVersion() string {
	if x != nil {
		return x.DaemonVersion
	}
	return ""
}

func (x *ConnectResponse) GetSessionId() string {
	if x != nil {
		return x.SessionId
	}
	return ""
}

func (x *ConnectResponse) GetGrpcAddress() string {
	if x != nil {
		return x.GrpcAddress
	}
	return ""
}

// PingRequest is an empty health check request.
type PingRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PingRequest) Reset() {
	*x = PingRequest{}
	mi := &file_daemon_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PingRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PingRequest) ProtoMessage() {}

func (x *PingRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PingRequest.ProtoReflect.Descriptor instead.
func (*PingRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{2}
}

// PingResponse confirms the daemon is responsive.
type PingResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// timestamp is the server time when the ping was received
	Timestamp     int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PingResponse) Reset() {
	*x = PingResponse{}
	mi := &file_daemon_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PingResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PingResponse) ProtoMessage() {}

func (x *PingResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PingResponse.ProtoReflect.Descriptor instead.
func (*PingResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{3}
}

func (x *PingResponse) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// StatusRequest queries daemon status.
type StatusRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StatusRequest) Reset() {
	*x = StatusRequest{}
	mi := &file_daemon_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusRequest) ProtoMessage() {}

func (x *StatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusRequest.ProtoReflect.Descriptor instead.
func (*StatusRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{4}
}

// StatusResponse returns complete daemon status information.
type StatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// running indicates if the daemon is running (always true if responding)
	Running bool `protobuf:"varint,1,opt,name=running,proto3" json:"running,omitempty"`
	// pid is the process ID of the daemon
	Pid int32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	// start_time is when the daemon started (Unix timestamp)
	StartTime int64 `protobuf:"varint,3,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// uptime is the human-readable uptime string
	Uptime string `protobuf:"bytes,4,opt,name=uptime,proto3" json:"uptime,omitempty"`
	// grpc_address is the gRPC server address
	GrpcAddress string `protobuf:"bytes,5,opt,name=grpc_address,json=grpcAddress,proto3" json:"grpc_address,omitempty"`
	// registry_type is the type of registry (embedded, external)
	RegistryType string `protobuf:"bytes,6,opt,name=registry_type,json=registryType,proto3" json:"registry_type,omitempty"`
	// registry_addr is the registry endpoint address
	RegistryAddr string `protobuf:"bytes,7,opt,name=registry_addr,json=registryAddr,proto3" json:"registry_addr,omitempty"`
	// callback_addr is the callback server address
	CallbackAddr string `protobuf:"bytes,8,opt,name=callback_addr,json=callbackAddr,proto3" json:"callback_addr,omitempty"`
	// agent_count is the number of registered agents
	AgentCount int32 `protobuf:"varint,9,opt,name=agent_count,json=agentCount,proto3" json:"agent_count,omitempty"`
	// mission_count is the total number of missions
	MissionCount int32 `protobuf:"varint,10,opt,name=mission_count,json=missionCount,proto3" json:"mission_count,omitempty"`
	// active_mission_count is the number of currently running missions
	ActiveMissionCount int32 `protobuf:"varint,11,opt,name=active_mission_count,json=activeMissionCount,proto3" json:"active_mission_count,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *StatusResponse) Reset() {
	*x = StatusResponse{}
	mi := &file_daemon_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StatusResponse) ProtoMessage() {}

func (x *StatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StatusResponse.ProtoReflect.Descriptor instead.
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{5}
}

func (x *StatusResponse) GetRunning() bool {
	if x != nil {
		return x.Running
	}
	return false
}

func (x *StatusResponse) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *StatusResponse) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *StatusResponse) GetUptime() string {
	if x != nil {
		return x.Uptime
	}
	return ""
}

func (x *StatusResponse) GetGrpcAddress() string {
	if x != nil {
		return x.GrpcAddress
	}
	return ""
}

func (x *StatusResponse) GetRegistryType() string {
	if x != nil {
		return x.RegistryType
	}
	return ""
}

func (x *StatusResponse) GetRegistryAddr() string {
	if x != nil {
		return x.RegistryAddr
	}
	return ""
}

func (x *StatusResponse) GetCallbackAddr() string {
	if x != nil {
		return x.CallbackAddr
	}
	return ""
}

func (x *StatusResponse) GetAgentCount() int32 {
	if x != nil {
		return x.AgentCount
	}
	return 0
}

func (x *StatusResponse) GetMissionCount() int32 {
	if x != nil {
		return x.MissionCount
	}
	return 0
}

func (x *StatusResponse) GetActiveMissionCount() int32 {
	if x != nil {
		return x.ActiveMissionCount
	}
	return 0
}

// RunMissionRequest starts a mission execution.
type RunMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// workflow_path is the path to the mission workflow YAML file
	WorkflowPath string `protobuf:"bytes,1,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	// mission_id is an optional custom mission identifier
	MissionId string `protobuf:"bytes,2,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// variables contains workflow variables to override
	Variables map[string]string `protobuf:"bytes,3,rep,name=variables,proto3" json:"variables,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// memory_continuity defines how agent memory is shared across mission runs
	// Valid values: "isolated" (default), "inherit", "shared"
	MemoryContinuity string `protobuf:"bytes,4,opt,name=memory_continuity,json=memoryContinuity,proto3" json:"memory_continuity,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *RunMissionRequest) Reset() {
	*x = RunMissionRequest{}
	mi := &file_daemon_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RunMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RunMissionRequest) ProtoMessage() {}

func (x *RunMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RunMissionRequest.ProtoReflect.Descriptor instead.
func (*RunMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{6}
}

func (x *RunMissionRequest) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

func (x *RunMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *RunMissionRequest) GetVariables() map[string]string {
	if x != nil {
		return x.Variables
	}
	return nil
}

func (x *RunMissionRequest) GetMemoryContinuity() string {
	if x != nil {
		return x.MemoryContinuity
	}
	return ""
}

// MissionEvent represents a mission execution event.
type MissionEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the type of event
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// mission_id is the unique mission identifier
	MissionId string `protobuf:"bytes,3,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// node_id is the workflow node ID (if applicable)
	NodeId string `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	// message is a human-readable event message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// data contains event-specific data (JSON-encoded)
	Data string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	// error contains error information if the event represents an error
	Error string `protobuf:"bytes,7,opt,name=error,proto3" json:"error,omitempty"`
	// result contains typed operation metrics (for mission.completed events)
	Result        *OperationResult `protobuf:"bytes,8,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionEvent) Reset() {
	*x = MissionEvent{}
	mi := &file_daemon_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionEvent) ProtoMessage() {}

func (x *MissionEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionEvent.ProtoReflect.Descriptor instead.
func (*MissionEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{7}
}

func (x *MissionEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *MissionEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *MissionEvent) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *MissionEvent) GetNodeId() string {
	if x != nil {
		return x.NodeId
	}
	return ""
}

func (x *MissionEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *MissionEvent) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

func (x *MissionEvent) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *MissionEvent) GetResult() *OperationResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// StopMissionRequest requests mission termination.
type StopMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the identifier of the mission to stop
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// force indicates whether to force-kill the mission (default: graceful)
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopMissionRequest) Reset() {
	*x = StopMissionRequest{}
	mi := &file_daemon_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopMissionRequest) ProtoMessage() {}

func (x *StopMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopMissionRequest.ProtoReflect.Descriptor instead.
func (*StopMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{8}
}

func (x *StopMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *StopMissionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// StopMissionResponse confirms mission stop request.
type StopMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the stop request was accepted
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// message provides additional context
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopMissionResponse) Reset() {
	*x = StopMissionResponse{}
	mi := &file_daemon_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopMissionResponse) ProtoMessage() {}

func (x *StopMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopMissionResponse.ProtoReflect.Descriptor instead.
func (*StopMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{9}
}

func (x *StopMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StopMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ListMissionsRequest queries mission list.
type ListMissionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// active_only filters to only running missions
	ActiveOnly bool `protobuf:"varint,1,opt,name=active_only,json=activeOnly,proto3" json:"active_only,omitempty"`
	// limit restricts the number of results
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// offset is the pagination offset
	Offset int32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	// status_filter filters missions by status (running, completed, failed, cancelled)
	StatusFilter string `protobuf:"bytes,4,opt,name=status_filter,json=statusFilter,proto3" json:"status_filter,omitempty"`
	// name_pattern filters missions by name using glob pattern matching
	NamePattern   string `protobuf:"bytes,5,opt,name=name_pattern,json=namePattern,proto3" json:"name_pattern,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMissionsRequest) Reset() {
	*x = ListMissionsRequest{}
	mi := &file_daemon_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMissionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMissionsRequest) ProtoMessage() {}

func (x *ListMissionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMissionsRequest.ProtoReflect.Descriptor instead.
func (*ListMissionsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{10}
}

func (x *ListMissionsRequest) GetActiveOnly() bool {
	if x != nil {
		return x.ActiveOnly
	}
	return false
}

func (x *ListMissionsRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListMissionsRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

func (x *ListMissionsRequest) GetStatusFilter() string {
	if x != nil {
		return x.StatusFilter
	}
	return ""
}

func (x *ListMissionsRequest) GetNamePattern() string {
	if x != nil {
		return x.NamePattern
	}
	return ""
}

// ListMissionsResponse returns mission list.
type ListMissionsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// missions is the list of missions
	Missions []*MissionInfo `protobuf:"bytes,1,rep,name=missions,proto3" json:"missions,omitempty"`
	// total is the total count of missions (for pagination)
	Total         int32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListMissionsResponse) Reset() {
	*x = ListMissionsResponse{}
	mi := &file_daemon_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListMissionsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListMissionsResponse) ProtoMessage() {}

func (x *ListMissionsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListMissionsResponse.ProtoReflect.Descriptor instead.
func (*ListMissionsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{11}
}

func (x *ListMissionsResponse) GetMissions() []*MissionInfo {
	if x != nil {
		return x.Missions
	}
	return nil
}

func (x *ListMissionsResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// MissionInfo describes a mission.
type MissionInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique mission identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// workflow_path is the path to the workflow file
	WorkflowPath string `protobuf:"bytes,2,opt,name=workflow_path,json=workflowPath,proto3" json:"workflow_path,omitempty"`
	// status is the mission status (running, completed, failed)
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// start_time is when the mission started (Unix timestamp)
	StartTime int64 `protobuf:"varint,4,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	// end_time is when the mission ended (Unix timestamp, 0 if running)
	EndTime int64 `protobuf:"varint,5,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
	// finding_count is the number of findings discovered
	FindingCount  int32 `protobuf:"varint,6,opt,name=finding_count,json=findingCount,proto3" json:"finding_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionInfo) Reset() {
	*x = MissionInfo{}
	mi := &file_daemon_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionInfo) ProtoMessage() {}

func (x *MissionInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionInfo.ProtoReflect.Descriptor instead.
func (*MissionInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{12}
}

func (x *MissionInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *MissionInfo) GetWorkflowPath() string {
	if x != nil {
		return x.WorkflowPath
	}
	return ""
}

func (x *MissionInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *MissionInfo) GetStartTime() int64 {
	if x != nil {
		return x.StartTime
	}
	return 0
}

func (x *MissionInfo) GetEndTime() int64 {
	if x != nil {
		return x.EndTime
	}
	return 0
}

func (x *MissionInfo) GetFindingCount() int32 {
	if x != nil {
		return x.FindingCount
	}
	return 0
}

// ListAgentsRequest queries agent registry.
type ListAgentsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind filters by component kind (empty = all agents)
	Kind          string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAgentsRequest) Reset() {
	*x = ListAgentsRequest{}
	mi := &file_daemon_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAgentsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAgentsRequest) ProtoMessage() {}

func (x *ListAgentsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAgentsRequest.ProtoReflect.Descriptor instead.
func (*ListAgentsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{13}
}

func (x *ListAgentsRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

// ListAgentsResponse returns registered agents.
type ListAgentsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// agents is the list of registered agents
	Agents        []*AgentInfo `protobuf:"bytes,1,rep,name=agents,proto3" json:"agents,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAgentsResponse) Reset() {
	*x = ListAgentsResponse{}
	mi := &file_daemon_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAgentsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAgentsResponse) ProtoMessage() {}

func (x *ListAgentsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAgentsResponse.ProtoReflect.Descriptor instead.
func (*ListAgentsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{14}
}

func (x *ListAgentsResponse) GetAgents() []*AgentInfo {
	if x != nil {
		return x.Agents
	}
	return nil
}

// AgentInfo describes a registered agent.
type AgentInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique agent identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the agent name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// kind is the component kind (always "agent")
	Kind string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// version is the agent version
	Version string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	// endpoint is the gRPC endpoint for the agent
	Endpoint string `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// capabilities lists agent capabilities
	Capabilities []string `protobuf:"bytes,6,rep,name=capabilities,proto3" json:"capabilities,omitempty"`
	// health is the agent health status (healthy, unhealthy)
	Health string `protobuf:"bytes,7,opt,name=health,proto3" json:"health,omitempty"`
	// last_seen is when the agent was last seen (Unix timestamp)
	LastSeen      int64 `protobuf:"varint,8,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentInfo) Reset() {
	*x = AgentInfo{}
	mi := &file_daemon_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentInfo) ProtoMessage() {}

func (x *AgentInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentInfo.ProtoReflect.Descriptor instead.
func (*AgentInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{15}
}

func (x *AgentInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *AgentInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AgentInfo) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *AgentInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AgentInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *AgentInfo) GetCapabilities() []string {
	if x != nil {
		return x.Capabilities
	}
	return nil
}

func (x *AgentInfo) GetHealth() string {
	if x != nil {
		return x.Health
	}
	return ""
}

func (x *AgentInfo) GetLastSeen() int64 {
	if x != nil {
		return x.LastSeen
	}
	return 0
}

// GetAgentStatusRequest queries a specific agent.
type GetAgentStatusRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// agent_id is the unique agent identifier
	AgentId       string `protobuf:"bytes,1,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAgentStatusRequest) Reset() {
	*x = GetAgentStatusRequest{}
	mi := &file_daemon_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAgentStatusRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAgentStatusRequest) ProtoMessage() {}

func (x *GetAgentStatusRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAgentStatusRequest.ProtoReflect.Descriptor instead.
func (*GetAgentStatusRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{16}
}

func (x *GetAgentStatusRequest) GetAgentId() string {
	if x != nil {
		return x.AgentId
	}
	return ""
}

// AgentStatusResponse returns agent status.
type AgentStatusResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// agent is the agent information
	Agent *AgentInfo `protobuf:"bytes,1,opt,name=agent,proto3" json:"agent,omitempty"`
	// active indicates if the agent is currently executing a task
	Active bool `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty"`
	// current_task describes the active task (if any)
	CurrentTask string `protobuf:"bytes,3,opt,name=current_task,json=currentTask,proto3" json:"current_task,omitempty"`
	// task_start_time is when the current task started (Unix timestamp)
	TaskStartTime int64 `protobuf:"varint,4,opt,name=task_start_time,json=taskStartTime,proto3" json:"task_start_time,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentStatusResponse) Reset() {
	*x = AgentStatusResponse{}
	mi := &file_daemon_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentStatusResponse) ProtoMessage() {}

func (x *AgentStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentStatusResponse.ProtoReflect.Descriptor instead.
func (*AgentStatusResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{17}
}

func (x *AgentStatusResponse) GetAgent() *AgentInfo {
	if x != nil {
		return x.Agent
	}
	return nil
}

func (x *AgentStatusResponse) GetActive() bool {
	if x != nil {
		return x.Active
	}
	return false
}

func (x *AgentStatusResponse) GetCurrentTask() string {
	if x != nil {
		return x.CurrentTask
	}
	return ""
}

func (x *AgentStatusResponse) GetTaskStartTime() int64 {
	if x != nil {
		return x.TaskStartTime
	}
	return 0
}

// ListToolsRequest queries tool registry.
type ListToolsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListToolsRequest) Reset() {
	*x = ListToolsRequest{}
	mi := &file_daemon_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListToolsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListToolsRequest) ProtoMessage() {}

func (x *ListToolsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListToolsRequest.ProtoReflect.Descriptor instead.
func (*ListToolsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{18}
}

// ListToolsResponse returns registered tools.
type ListToolsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tools is the list of registered tools
	Tools         []*ToolInfo `protobuf:"bytes,1,rep,name=tools,proto3" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListToolsResponse) Reset() {
	*x = ListToolsResponse{}
	mi := &file_daemon_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListToolsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListToolsResponse) ProtoMessage() {}

func (x *ListToolsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListToolsResponse.ProtoReflect.Descriptor instead.
func (*ListToolsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{19}
}

func (x *ListToolsResponse) GetTools() []*ToolInfo {
	if x != nil {
		return x.Tools
	}
	return nil
}

// ToolInfo describes a registered tool.
type ToolInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique tool identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the tool name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the tool version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// endpoint is the gRPC endpoint for the tool
	Endpoint string `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// description is the tool description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// health is the tool health status (healthy, unhealthy)
	Health string `protobuf:"bytes,6,opt,name=health,proto3" json:"health,omitempty"`
	// last_seen is when the tool was last seen (Unix timestamp)
	LastSeen      int64 `protobuf:"varint,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolInfo) Reset() {
	*x = ToolInfo{}
	mi := &file_daemon_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolInfo) ProtoMessage() {}

func (x *ToolInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolInfo.ProtoReflect.Descriptor instead.
func (*ToolInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{20}
}

func (x *ToolInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ToolInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ToolInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *ToolInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *ToolInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ToolInfo) GetHealth() string {
	if x != nil {
		return x.Health
	}
	return ""
}

func (x *ToolInfo) GetLastSeen() int64 {
	if x != nil {
		return x.LastSeen
	}
	return 0
}

// ListPluginsRequest queries plugin registry.
type ListPluginsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPluginsRequest) Reset() {
	*x = ListPluginsRequest{}
	mi := &file_daemon_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPluginsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPluginsRequest) ProtoMessage() {}

func (x *ListPluginsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPluginsRequest.ProtoReflect.Descriptor instead.
func (*ListPluginsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{21}
}

// ListPluginsResponse returns registered plugins.
type ListPluginsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// plugins is the list of registered plugins
	Plugins       []*PluginInfo `protobuf:"bytes,1,rep,name=plugins,proto3" json:"plugins,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPluginsResponse) Reset() {
	*x = ListPluginsResponse{}
	mi := &file_daemon_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPluginsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPluginsResponse) ProtoMessage() {}

func (x *ListPluginsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPluginsResponse.ProtoReflect.Descriptor instead.
func (*ListPluginsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{22}
}

func (x *ListPluginsResponse) GetPlugins() []*PluginInfo {
	if x != nil {
		return x.Plugins
	}
	return nil
}

// PluginInfo describes a registered plugin.
type PluginInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique plugin identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// name is the plugin name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// version is the plugin version
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	// endpoint is the gRPC endpoint for the plugin
	Endpoint string `protobuf:"bytes,4,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	// description is the plugin description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// health is the plugin health status (healthy, unhealthy)
	Health string `protobuf:"bytes,6,opt,name=health,proto3" json:"health,omitempty"`
	// last_seen is when the plugin was last seen (Unix timestamp)
	LastSeen      int64 `protobuf:"varint,7,opt,name=last_seen,json=lastSeen,proto3" json:"last_seen,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PluginInfo) Reset() {
	*x = PluginInfo{}
	mi := &file_daemon_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PluginInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PluginInfo) ProtoMessage() {}

func (x *PluginInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PluginInfo.ProtoReflect.Descriptor instead.
func (*PluginInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{23}
}

func (x *PluginInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *PluginInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PluginInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *PluginInfo) GetEndpoint() string {
	if x != nil {
		return x.Endpoint
	}
	return ""
}

func (x *PluginInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *PluginInfo) GetHealth() string {
	if x != nil {
		return x.Health
	}
	return ""
}

func (x *PluginInfo) GetLastSeen() int64 {
	if x != nil {
		return x.LastSeen
	}
	return 0
}

// QueryPluginRequest executes a method on a plugin.
type QueryPluginRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the plugin name to query
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// method is the method name to execute
	Method string `protobuf:"bytes,2,opt,name=method,proto3" json:"method,omitempty"`
	// params_json is the JSON-encoded parameters for the method
	ParamsJson string `protobuf:"bytes,3,opt,name=params_json,json=paramsJson,proto3" json:"params_json,omitempty"`
	// timeout_ms is the optional timeout in milliseconds (0 = default)
	TimeoutMs     int64 `protobuf:"varint,4,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryPluginRequest) Reset() {
	*x = QueryPluginRequest{}
	mi := &file_daemon_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryPluginRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryPluginRequest) ProtoMessage() {}

func (x *QueryPluginRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryPluginRequest.ProtoReflect.Descriptor instead.
func (*QueryPluginRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{24}
}

func (x *QueryPluginRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *QueryPluginRequest) GetMethod() string {
	if x != nil {
		return x.Method
	}
	return ""
}

func (x *QueryPluginRequest) GetParamsJson() string {
	if x != nil {
		return x.ParamsJson
	}
	return ""
}

func (x *QueryPluginRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// QueryPluginResponse returns the result of a plugin query.
type QueryPluginResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// result_json is the JSON-encoded result from the plugin method
	ResultJson string `protobuf:"bytes,1,opt,name=result_json,json=resultJson,proto3" json:"result_json,omitempty"`
	// error is set if the query failed
	Error string `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	// duration_ms is how long the query took in milliseconds
	DurationMs    int64 `protobuf:"varint,3,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QueryPluginResponse) Reset() {
	*x = QueryPluginResponse{}
	mi := &file_daemon_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QueryPluginResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QueryPluginResponse) ProtoMessage() {}

func (x *QueryPluginResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QueryPluginResponse.ProtoReflect.Descriptor instead.
func (*QueryPluginResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{25}
}

func (x *QueryPluginResponse) GetResultJson() string {
	if x != nil {
		return x.ResultJson
	}
	return ""
}

func (x *QueryPluginResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *QueryPluginResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// RunAttackRequest executes an attack.
type RunAttackRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// target is the target URL or identifier
	Target string `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	// attack_type is the type of attack to execute
	AttackType string `protobuf:"bytes,2,opt,name=attack_type,json=attackType,proto3" json:"attack_type,omitempty"`
	// agent_id is the agent to use (optional, auto-select if empty)
	AgentId string `protobuf:"bytes,3,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	// payload_filter filters which payloads to use
	PayloadFilter string `protobuf:"bytes,4,opt,name=payload_filter,json=payloadFilter,proto3" json:"payload_filter,omitempty"`
	// options contains attack-specific options
	Options map[string]string `protobuf:"bytes,5,rep,name=options,proto3" json:"options,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// target_name is the name of a stored target to look up from the database
	TargetName string `protobuf:"bytes,6,opt,name=target_name,json=targetName,proto3" json:"target_name,omitempty"`
	// goal is the attack objective or what the agent should try to accomplish
	Goal          string `protobuf:"bytes,7,opt,name=goal,proto3" json:"goal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RunAttackRequest) Reset() {
	*x = RunAttackRequest{}
	mi := &file_daemon_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RunAttackRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RunAttackRequest) ProtoMessage() {}

func (x *RunAttackRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RunAttackRequest.ProtoReflect.Descriptor instead.
func (*RunAttackRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{26}
}

func (x *RunAttackRequest) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

func (x *RunAttackRequest) GetAttackType() string {
	if x != nil {
		return x.AttackType
	}
	return ""
}

func (x *RunAttackRequest) GetAgentId() string {
	if x != nil {
		return x.AgentId
	}
	return ""
}

func (x *RunAttackRequest) GetPayloadFilter() string {
	if x != nil {
		return x.PayloadFilter
	}
	return ""
}

func (x *RunAttackRequest) GetOptions() map[string]string {
	if x != nil {
		return x.Options
	}
	return nil
}

func (x *RunAttackRequest) GetTargetName() string {
	if x != nil {
		return x.TargetName
	}
	return ""
}

func (x *RunAttackRequest) GetGoal() string {
	if x != nil {
		return x.Goal
	}
	return ""
}

// AttackEvent represents an attack execution event.
type AttackEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the type of event
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// attack_id is the unique attack identifier
	AttackId string `protobuf:"bytes,3,opt,name=attack_id,json=attackId,proto3" json:"attack_id,omitempty"`
	// message is a human-readable event message
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// data contains event-specific data (JSON-encoded)
	Data string `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	// error contains error information if the event represents an error
	Error string `protobuf:"bytes,6,opt,name=error,proto3" json:"error,omitempty"`
	// finding describes a discovered finding (if applicable)
	Finding *FindingInfo `protobuf:"bytes,7,opt,name=finding,proto3" json:"finding,omitempty"`
	// result contains typed operation metrics (for attack.completed events)
	Result        *OperationResult `protobuf:"bytes,8,opt,name=result,proto3" json:"result,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttackEvent) Reset() {
	*x = AttackEvent{}
	mi := &file_daemon_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttackEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttackEvent) ProtoMessage() {}

func (x *AttackEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttackEvent.ProtoReflect.Descriptor instead.
func (*AttackEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{27}
}

func (x *AttackEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *AttackEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *AttackEvent) GetAttackId() string {
	if x != nil {
		return x.AttackId
	}
	return ""
}

func (x *AttackEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *AttackEvent) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

func (x *AttackEvent) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *AttackEvent) GetFinding() *FindingInfo {
	if x != nil {
		return x.Finding
	}
	return nil
}

func (x *AttackEvent) GetResult() *OperationResult {
	if x != nil {
		return x.Result
	}
	return nil
}

// FindingInfo describes a discovered vulnerability.
type FindingInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id is the unique finding identifier
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// title is the finding title
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// severity is the severity level (info, low, medium, high, critical)
	Severity string `protobuf:"bytes,3,opt,name=severity,proto3" json:"severity,omitempty"`
	// category is the finding category
	Category string `protobuf:"bytes,4,opt,name=category,proto3" json:"category,omitempty"`
	// description is the detailed finding description
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// technique is the MITRE ATT&CK or ATLAS technique ID
	Technique string `protobuf:"bytes,6,opt,name=technique,proto3" json:"technique,omitempty"`
	// evidence contains supporting evidence
	Evidence string `protobuf:"bytes,7,opt,name=evidence,proto3" json:"evidence,omitempty"`
	// timestamp is when the finding was discovered (Unix timestamp)
	Timestamp     int64 `protobuf:"varint,8,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FindingInfo) Reset() {
	*x = FindingInfo{}
	mi := &file_daemon_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FindingInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindingInfo) ProtoMessage() {}

func (x *FindingInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindingInfo.ProtoReflect.Descriptor instead.
func (*FindingInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{28}
}

func (x *FindingInfo) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *FindingInfo) GetTitle() string {
	if x != nil {
		return x.Title
	}
	return ""
}

func (x *FindingInfo) GetSeverity() string {
	if x != nil {
		return x.Severity
	}
	return ""
}

func (x *FindingInfo) GetCategory() string {
	if x != nil {
		return x.Category
	}
	return ""
}

func (x *FindingInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *FindingInfo) GetTechnique() string {
	if x != nil {
		return x.Technique
	}
	return ""
}

func (x *FindingInfo) GetEvidence() string {
	if x != nil {
		return x.Evidence
	}
	return ""
}

func (x *FindingInfo) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

// SubscribeRequest establishes an event stream.
type SubscribeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_types filters which event types to receive (empty = all)
	EventTypes []string `protobuf:"bytes,1,rep,name=event_types,json=eventTypes,proto3" json:"event_types,omitempty"`
	// mission_id filters to a specific mission (empty = all)
	MissionId     string `protobuf:"bytes,2,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeRequest) Reset() {
	*x = SubscribeRequest{}
	mi := &file_daemon_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeRequest) ProtoMessage() {}

func (x *SubscribeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeRequest.ProtoReflect.Descriptor instead.
func (*SubscribeRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{29}
}

func (x *SubscribeRequest) GetEventTypes() []string {
	if x != nil {
		return x.EventTypes
	}
	return nil
}

func (x *SubscribeRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

// Event represents a generic daemon event.
type Event struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the type of event
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// source is the event source (mission, agent, daemon, etc.)
	Source string `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	// data contains event-specific data (JSON-encoded)
	Data string `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	// Specific event types (only one will be set)
	//
	// Types that are valid to be assigned to Event:
	//
	//	*Event_MissionEvent
	//	*Event_AttackEvent
	//	*Event_AgentEvent
	//	*Event_FindingEvent
	Event         isEvent_Event `protobuf_oneof:"event"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Event) Reset() {
	*x = Event{}
	mi := &file_daemon_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Event) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Event) ProtoMessage() {}

func (x *Event) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Event.ProtoReflect.Descriptor instead.
func (*Event) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{30}
}

func (x *Event) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *Event) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Event) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *Event) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

func (x *Event) GetEvent() isEvent_Event {
	if x != nil {
		return x.Event
	}
	return nil
}

func (x *Event) GetMissionEvent() *MissionEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_MissionEvent); ok {
			return x.MissionEvent
		}
	}
	return nil
}

func (x *Event) GetAttackEvent() *AttackEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_AttackEvent); ok {
			return x.AttackEvent
		}
	}
	return nil
}

func (x *Event) GetAgentEvent() *AgentEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_AgentEvent); ok {
			return x.AgentEvent
		}
	}
	return nil
}

func (x *Event) GetFindingEvent() *FindingEvent {
	if x != nil {
		if x, ok := x.Event.(*Event_FindingEvent); ok {
			return x.FindingEvent
		}
	}
	return nil
}

type isEvent_Event interface {
	isEvent_Event()
}

type Event_MissionEvent struct {
	MissionEvent *MissionEvent `protobuf:"bytes,5,opt,name=mission_event,json=missionEvent,proto3,oneof"`
}

type Event_AttackEvent struct {
	AttackEvent *AttackEvent `protobuf:"bytes,6,opt,name=attack_event,json=attackEvent,proto3,oneof"`
}

type Event_AgentEvent struct {
	AgentEvent *AgentEvent `protobuf:"bytes,7,opt,name=agent_event,json=agentEvent,proto3,oneof"`
}

type Event_FindingEvent struct {
	FindingEvent *FindingEvent `protobuf:"bytes,8,opt,name=finding_event,json=findingEvent,proto3,oneof"`
}

func (*Event_MissionEvent) isEvent_Event() {}

func (*Event_AttackEvent) isEvent_Event() {}

func (*Event_AgentEvent) isEvent_Event() {}

func (*Event_FindingEvent) isEvent_Event() {}

// AgentEvent represents an agent lifecycle event.
type AgentEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the agent event type (registered, unregistered, health_change)
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// agent_id is the agent identifier
	AgentId string `protobuf:"bytes,3,opt,name=agent_id,json=agentId,proto3" json:"agent_id,omitempty"`
	// agent_name is the agent name
	AgentName string `protobuf:"bytes,4,opt,name=agent_name,json=agentName,proto3" json:"agent_name,omitempty"`
	// message is a human-readable message
	Message string `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	// data contains event-specific data (JSON-encoded)
	Data          string `protobuf:"bytes,6,opt,name=data,proto3" json:"data,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AgentEvent) Reset() {
	*x = AgentEvent{}
	mi := &file_daemon_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AgentEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AgentEvent) ProtoMessage() {}

func (x *AgentEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AgentEvent.ProtoReflect.Descriptor instead.
func (*AgentEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{31}
}

func (x *AgentEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *AgentEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *AgentEvent) GetAgentId() string {
	if x != nil {
		return x.AgentId
	}
	return ""
}

func (x *AgentEvent) GetAgentName() string {
	if x != nil {
		return x.AgentName
	}
	return ""
}

func (x *AgentEvent) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *AgentEvent) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

// FindingEvent represents a finding discovery event.
type FindingEvent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// event_type identifies the finding event type (discovered, updated)
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
	// timestamp is when the event occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// finding is the finding information
	Finding *FindingInfo `protobuf:"bytes,3,opt,name=finding,proto3" json:"finding,omitempty"`
	// mission_id is the mission that discovered the finding
	MissionId     string `protobuf:"bytes,4,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FindingEvent) Reset() {
	*x = FindingEvent{}
	mi := &file_daemon_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FindingEvent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindingEvent) ProtoMessage() {}

func (x *FindingEvent) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindingEvent.ProtoReflect.Descriptor instead.
func (*FindingEvent) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{32}
}

func (x *FindingEvent) GetEventType() string {
	if x != nil {
		return x.EventType
	}
	return ""
}

func (x *FindingEvent) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *FindingEvent) GetFinding() *FindingInfo {
	if x != nil {
		return x.Finding
	}
	return nil
}

func (x *FindingEvent) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

// StartComponentRequest requests starting a component.
type StartComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartComponentRequest) Reset() {
	*x = StartComponentRequest{}
	mi := &file_daemon_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartComponentRequest) ProtoMessage() {}

func (x *StartComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartComponentRequest.ProtoReflect.Descriptor instead.
func (*StartComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{33}
}

func (x *StartComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *StartComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// StartComponentResponse returns the result of starting a component.
type StartComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was started successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// pid is the process ID of the started component
	Pid int32 `protobuf:"varint,2,opt,name=pid,proto3" json:"pid,omitempty"`
	// port is the port the component is listening on
	Port int32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
	// message provides additional context or error information
	Message string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	// log_path is the path to the component's log file
	LogPath       string `protobuf:"bytes,5,opt,name=log_path,json=logPath,proto3" json:"log_path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartComponentResponse) Reset() {
	*x = StartComponentResponse{}
	mi := &file_daemon_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartComponentResponse) ProtoMessage() {}

func (x *StartComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartComponentResponse.ProtoReflect.Descriptor instead.
func (*StartComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{34}
}

func (x *StartComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StartComponentResponse) GetPid() int32 {
	if x != nil {
		return x.Pid
	}
	return 0
}

func (x *StartComponentResponse) GetPort() int32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *StartComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

func (x *StartComponentResponse) GetLogPath() string {
	if x != nil {
		return x.LogPath
	}
	return ""
}

// StopComponentRequest requests stopping a component.
type StopComponentRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// kind is the component kind ("agent", "tool", "plugin")
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// name is the component name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// force indicates whether to skip graceful shutdown (SIGKILL instead of SIGTERM)
	Force         bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopComponentRequest) Reset() {
	*x = StopComponentRequest{}
	mi := &file_daemon_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopComponentRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopComponentRequest) ProtoMessage() {}

func (x *StopComponentRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopComponentRequest.ProtoReflect.Descriptor instead.
func (*StopComponentRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{35}
}

func (x *StopComponentRequest) GetKind() string {
	if x != nil {
		return x.Kind
	}
	return ""
}

func (x *StopComponentRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *StopComponentRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// StopComponentResponse returns the result of stopping a component.
type StopComponentResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the component was stopped successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// stopped_count is the number of instances successfully stopped
	StoppedCount int32 `protobuf:"varint,2,opt,name=stopped_count,json=stoppedCount,proto3" json:"stopped_count,omitempty"`
	// total_count is the total number of instances that were running
	TotalCount int32 `protobuf:"varint,3,opt,name=total_count,json=totalCount,proto3" json:"total_count,omitempty"`
	// message provides additional context or error information
	Message       string `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopComponentResponse) Reset() {
	*x = StopComponentResponse{}
	mi := &file_daemon_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopComponentResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopComponentResponse) ProtoMessage() {}

func (x *StopComponentResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopComponentResponse.ProtoReflect.Descriptor instead.
func (*StopComponentResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{36}
}

func (x *StopComponentResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *StopComponentResponse) GetStoppedCount() int32 {
	if x != nil {
		return x.StoppedCount
	}
	return 0
}

func (x *StopComponentResponse) GetTotalCount() int32 {
	if x != nil {
		return x.TotalCount
	}
	return 0
}

func (x *StopComponentResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// OperationResult represents the unified result of a long-running operation (attack or mission).
// This provides typed metrics instead of JSON-encoded strings.
type OperationResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status of the operation ("success", "failed", "timeout", "cancelled")
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// duration_ms is the total duration in milliseconds
	DurationMs int64 `protobuf:"varint,2,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	// started_at is the Unix timestamp (milliseconds) when the operation started
	StartedAt int64 `protobuf:"varint,3,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	// completed_at is the Unix timestamp (milliseconds) when the operation completed
	CompletedAt int64 `protobuf:"varint,4,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	// turns_used is the number of agent turns/iterations executed
	TurnsUsed int32 `protobuf:"varint,5,opt,name=turns_used,json=turnsUsed,proto3" json:"turns_used,omitempty"`
	// tokens_used is the total LLM tokens consumed
	TokensUsed int64 `protobuf:"varint,6,opt,name=tokens_used,json=tokensUsed,proto3" json:"tokens_used,omitempty"`
	// nodes_executed is the number of workflow nodes that ran successfully
	NodesExecuted int32 `protobuf:"varint,7,opt,name=nodes_executed,json=nodesExecuted,proto3" json:"nodes_executed,omitempty"`
	// nodes_failed is the number of workflow nodes that failed
	NodesFailed int32 `protobuf:"varint,8,opt,name=nodes_failed,json=nodesFailed,proto3" json:"nodes_failed,omitempty"`
	// findings_count is the total number of findings discovered
	FindingsCount int32 `protobuf:"varint,9,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// critical_count is the number of critical severity findings
	CriticalCount int32 `protobuf:"varint,10,opt,name=critical_count,json=criticalCount,proto3" json:"critical_count,omitempty"`
	// high_count is the number of high severity findings
	HighCount int32 `protobuf:"varint,11,opt,name=high_count,json=highCount,proto3" json:"high_count,omitempty"`
	// medium_count is the number of medium severity findings
	MediumCount int32 `protobuf:"varint,12,opt,name=medium_count,json=mediumCount,proto3" json:"medium_count,omitempty"`
	// low_count is the number of low severity findings
	LowCount int32 `protobuf:"varint,13,opt,name=low_count,json=lowCount,proto3" json:"low_count,omitempty"`
	// error_message contains the error message if status == "failed"
	ErrorMessage string `protobuf:"bytes,14,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// error_code contains a machine-readable error code if status == "failed"
	ErrorCode     string `protobuf:"bytes,15,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OperationResult) Reset() {
	*x = OperationResult{}
	mi := &file_daemon_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OperationResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OperationResult) ProtoMessage() {}

func (x *OperationResult) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OperationResult.ProtoReflect.Descriptor instead.
func (*OperationResult) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{37}
}

func (x *OperationResult) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *OperationResult) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

func (x *OperationResult) GetStartedAt() int64 {
	if x != nil {
		return x.StartedAt
	}
	return 0
}

func (x *OperationResult) GetCompletedAt() int64 {
	if x != nil {
		return x.CompletedAt
	}
	return 0
}

func (x *OperationResult) GetTurnsUsed() int32 {
	if x != nil {
		return x.TurnsUsed
	}
	return 0
}

func (x *OperationResult) GetTokensUsed() int64 {
	if x != nil {
		return x.TokensUsed
	}
	return 0
}

func (x *OperationResult) GetNodesExecuted() int32 {
	if x != nil {
		return x.NodesExecuted
	}
	return 0
}

func (x *OperationResult) GetNodesFailed() int32 {
	if x != nil {
		return x.NodesFailed
	}
	return 0
}

func (x *OperationResult) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *OperationResult) GetCriticalCount() int32 {
	if x != nil {
		return x.CriticalCount
	}
	return 0
}

func (x *OperationResult) GetHighCount() int32 {
	if x != nil {
		return x.HighCount
	}
	return 0
}

func (x *OperationResult) GetMediumCount() int32 {
	if x != nil {
		return x.MediumCount
	}
	return 0
}

func (x *OperationResult) GetLowCount() int32 {
	if x != nil {
		return x.LowCount
	}
	return 0
}

func (x *OperationResult) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *OperationResult) GetErrorCode() string {
	if x != nil {
		return x.ErrorCode
	}
	return ""
}

// PauseMissionRequest requests pausing a running mission.
type PauseMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier of the mission to pause
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// force indicates whether to pause immediately without waiting for a clean checkpoint boundary
	// If false (default), waits for the current node to complete before pausing
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PauseMissionRequest) Reset() {
	*x = PauseMissionRequest{}
	mi := &file_daemon_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PauseMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PauseMissionRequest) ProtoMessage() {}

func (x *PauseMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PauseMissionRequest.ProtoReflect.Descriptor instead.
func (*PauseMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{38}
}

func (x *PauseMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *PauseMissionRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

// PauseMissionResponse confirms the mission pause request.
type PauseMissionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the pause request was accepted
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// checkpoint_id is the ID of the checkpoint created during pause
	CheckpointId string `protobuf:"bytes,2,opt,name=checkpoint_id,json=checkpointId,proto3" json:"checkpoint_id,omitempty"`
	// message provides additional context about the pause operation
	Message       string `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PauseMissionResponse) Reset() {
	*x = PauseMissionResponse{}
	mi := &file_daemon_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PauseMissionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PauseMissionResponse) ProtoMessage() {}

func (x *PauseMissionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PauseMissionResponse.ProtoReflect.Descriptor instead.
func (*PauseMissionResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{39}
}

func (x *PauseMissionResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *PauseMissionResponse) GetCheckpointId() string {
	if x != nil {
		return x.CheckpointId
	}
	return ""
}

func (x *PauseMissionResponse) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// ResumeMissionRequest requests resuming a paused mission.
type ResumeMissionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier of the mission to resume
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// checkpoint_id optionally specifies a specific checkpoint to resume from
	// If empty, resumes from the latest checkpoint
	CheckpointId  string `protobuf:"bytes,2,opt,name=checkpoint_id,json=checkpointId,proto3" json:"checkpoint_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResumeMissionRequest) Reset() {
	*x = ResumeMissionRequest{}
	mi := &file_daemon_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResumeMissionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResumeMissionRequest) ProtoMessage() {}

func (x *ResumeMissionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResumeMissionRequest.ProtoReflect.Descriptor instead.
func (*ResumeMissionRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{40}
}

func (x *ResumeMissionRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *ResumeMissionRequest) GetCheckpointId() string {
	if x != nil {
		return x.CheckpointId
	}
	return ""
}

// GetMissionHistoryRequest queries mission execution history by name.
type GetMissionHistoryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the mission name to query history for
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// limit restricts the number of results (default: 100)
	Limit int32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	// offset is the pagination offset (default: 0)
	Offset        int32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionHistoryRequest) Reset() {
	*x = GetMissionHistoryRequest{}
	mi := &file_daemon_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionHistoryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionHistoryRequest) ProtoMessage() {}

func (x *GetMissionHistoryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionHistoryRequest.ProtoReflect.Descriptor instead.
func (*GetMissionHistoryRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{41}
}

func (x *GetMissionHistoryRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetMissionHistoryRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *GetMissionHistoryRequest) GetOffset() int32 {
	if x != nil {
		return x.Offset
	}
	return 0
}

// GetMissionHistoryResponse returns mission execution history.
type GetMissionHistoryResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// runs contains all mission runs for the requested name
	Runs []*MissionRun `protobuf:"bytes,1,rep,name=runs,proto3" json:"runs,omitempty"`
	// total is the total count of runs (for pagination)
	Total         int32 `protobuf:"varint,2,opt,name=total,proto3" json:"total,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionHistoryResponse) Reset() {
	*x = GetMissionHistoryResponse{}
	mi := &file_daemon_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionHistoryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionHistoryResponse) ProtoMessage() {}

func (x *GetMissionHistoryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionHistoryResponse.ProtoReflect.Descriptor instead.
func (*GetMissionHistoryResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{42}
}

func (x *GetMissionHistoryResponse) GetRuns() []*MissionRun {
	if x != nil {
		return x.Runs
	}
	return nil
}

func (x *GetMissionHistoryResponse) GetTotal() int32 {
	if x != nil {
		return x.Total
	}
	return 0
}

// MissionRun represents a single execution instance of a mission.
type MissionRun struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier for this run
	MissionId string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	// run_number is the sequential run number for this mission name
	RunNumber int32 `protobuf:"varint,2,opt,name=run_number,json=runNumber,proto3" json:"run_number,omitempty"`
	// status is the final status of this run (running, completed, failed, cancelled, paused)
	Status string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	// created_at is when this run was created (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// completed_at is when this run completed (Unix timestamp, 0 if not completed)
	CompletedAt int64 `protobuf:"varint,5,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	// findings_count is the number of findings discovered in this run
	FindingsCount int32 `protobuf:"varint,6,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// previous_run_id is the ID of the previous run (if any)
	PreviousRunId string `protobuf:"bytes,7,opt,name=previous_run_id,json=previousRunId,proto3" json:"previous_run_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MissionRun) Reset() {
	*x = MissionRun{}
	mi := &file_daemon_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MissionRun) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MissionRun) ProtoMessage() {}

func (x *MissionRun) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MissionRun.ProtoReflect.Descriptor instead.
func (*MissionRun) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{43}
}

func (x *MissionRun) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

func (x *MissionRun) GetRunNumber() int32 {
	if x != nil {
		return x.RunNumber
	}
	return 0
}

func (x *MissionRun) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *MissionRun) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *MissionRun) GetCompletedAt() int64 {
	if x != nil {
		return x.CompletedAt
	}
	return 0
}

func (x *MissionRun) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *MissionRun) GetPreviousRunId() string {
	if x != nil {
		return x.PreviousRunId
	}
	return ""
}

// GetMissionCheckpointsRequest queries checkpoints for a mission.
type GetMissionCheckpointsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// mission_id is the unique identifier of the mission to query checkpoints for
	MissionId     string `protobuf:"bytes,1,opt,name=mission_id,json=missionId,proto3" json:"mission_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionCheckpointsRequest) Reset() {
	*x = GetMissionCheckpointsRequest{}
	mi := &file_daemon_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionCheckpointsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionCheckpointsRequest) ProtoMessage() {}

func (x *GetMissionCheckpointsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionCheckpointsRequest.ProtoReflect.Descriptor instead.
func (*GetMissionCheckpointsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{44}
}

func (x *GetMissionCheckpointsRequest) GetMissionId() string {
	if x != nil {
		return x.MissionId
	}
	return ""
}

// GetMissionCheckpointsResponse returns all checkpoints for a mission.
type GetMissionCheckpointsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// checkpoints contains all checkpoints for the requested mission
	Checkpoints   []*CheckpointInfo `protobuf:"bytes,1,rep,name=checkpoints,proto3" json:"checkpoints,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetMissionCheckpointsResponse) Reset() {
	*x = GetMissionCheckpointsResponse{}
	mi := &file_daemon_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetMissionCheckpointsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetMissionCheckpointsResponse) ProtoMessage() {}

func (x *GetMissionCheckpointsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetMissionCheckpointsResponse.ProtoReflect.Descriptor instead.
func (*GetMissionCheckpointsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{45}
}

func (x *GetMissionCheckpointsResponse) GetCheckpoints() []*CheckpointInfo {
	if x != nil {
		return x.Checkpoints
	}
	return nil
}

// CheckpointInfo provides metadata about a mission checkpoint.
type CheckpointInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// checkpoint_id is the unique identifier for this checkpoint
	CheckpointId string `protobuf:"bytes,1,opt,name=checkpoint_id,json=checkpointId,proto3" json:"checkpoint_id,omitempty"`
	// created_at is when this checkpoint was created (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	// completed_nodes is the number of nodes that had completed at checkpoint time
	CompletedNodes int32 `protobuf:"varint,3,opt,name=completed_nodes,json=completedNodes,proto3" json:"completed_nodes,omitempty"`
	// total_nodes is the total number of nodes in the workflow
	TotalNodes int32 `protobuf:"varint,4,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
	// findings_count is the number of findings at checkpoint time
	FindingsCount int32 `protobuf:"varint,5,opt,name=findings_count,json=findingsCount,proto3" json:"findings_count,omitempty"`
	// version is the checkpoint format version
	Version       int32 `protobuf:"varint,6,opt,name=version,proto3" json:"version,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CheckpointInfo) Reset() {
	*x = CheckpointInfo{}
	mi := &file_daemon_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CheckpointInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CheckpointInfo) ProtoMessage() {}

func (x *CheckpointInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CheckpointInfo.ProtoReflect.Descriptor instead.
func (*CheckpointInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{46}
}

func (x *CheckpointInfo) GetCheckpointId() string {
	if x != nil {
		return x.CheckpointId
	}
	return ""
}

func (x *CheckpointInfo) GetCreatedAt() int64 {
	if x != nil {
		return x.CreatedAt
	}
	return 0
}

func (x *CheckpointInfo) GetCompletedNodes() int32 {
	if x != nil {
		return x.CompletedNodes
	}
	return 0
}

func (x *CheckpointInfo) GetTotalNodes() int32 {
	if x != nil {
		return x.TotalNodes
	}
	return 0
}

func (x *CheckpointInfo) GetFindingsCount() int32 {
	if x != nil {
		return x.FindingsCount
	}
	return 0
}

func (x *CheckpointInfo) GetVersion() int32 {
	if x != nil {
		return x.Version
	}
	return 0
}

// ExecuteToolRequest executes a tool via the Tool Executor Service.
type ExecuteToolRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the tool name to execute
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// input_json is the JSON-encoded input parameters for the tool
	InputJson string `protobuf:"bytes,2,opt,name=input_json,json=inputJson,proto3" json:"input_json,omitempty"`
	// timeout_ms is the execution timeout in milliseconds (0 = default 5 minutes)
	TimeoutMs     int64 `protobuf:"varint,3,opt,name=timeout_ms,json=timeoutMs,proto3" json:"timeout_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteToolRequest) Reset() {
	*x = ExecuteToolRequest{}
	mi := &file_daemon_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteToolRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteToolRequest) ProtoMessage() {}

func (x *ExecuteToolRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteToolRequest.ProtoReflect.Descriptor instead.
func (*ExecuteToolRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{47}
}

func (x *ExecuteToolRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ExecuteToolRequest) GetInputJson() string {
	if x != nil {
		return x.InputJson
	}
	return ""
}

func (x *ExecuteToolRequest) GetTimeoutMs() int64 {
	if x != nil {
		return x.TimeoutMs
	}
	return 0
}

// ExecuteToolResponse returns the result of tool execution.
type ExecuteToolResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// success indicates if the tool executed successfully
	Success bool `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	// output_json is the JSON-encoded output from the tool (if success)
	OutputJson string `protobuf:"bytes,2,opt,name=output_json,json=outputJson,proto3" json:"output_json,omitempty"`
	// error is the error message (if !success)
	Error string `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	// duration_ms is the actual execution duration in milliseconds
	DurationMs    int64 `protobuf:"varint,4,opt,name=duration_ms,json=durationMs,proto3" json:"duration_ms,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExecuteToolResponse) Reset() {
	*x = ExecuteToolResponse{}
	mi := &file_daemon_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExecuteToolResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExecuteToolResponse) ProtoMessage() {}

func (x *ExecuteToolResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExecuteToolResponse.ProtoReflect.Descriptor instead.
func (*ExecuteToolResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{48}
}

func (x *ExecuteToolResponse) GetSuccess() bool {
	if x != nil {
		return x.Success
	}
	return false
}

func (x *ExecuteToolResponse) GetOutputJson() string {
	if x != nil {
		return x.OutputJson
	}
	return ""
}

func (x *ExecuteToolResponse) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

func (x *ExecuteToolResponse) GetDurationMs() int64 {
	if x != nil {
		return x.DurationMs
	}
	return 0
}

// GetAvailableToolsRequest queries available tools from the Tool Executor Service.
type GetAvailableToolsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAvailableToolsRequest) Reset() {
	*x = GetAvailableToolsRequest{}
	mi := &file_daemon_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAvailableToolsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAvailableToolsRequest) ProtoMessage() {}

func (x *GetAvailableToolsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAvailableToolsRequest.ProtoReflect.Descriptor instead.
func (*GetAvailableToolsRequest) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{49}
}

// GetAvailableToolsResponse returns all available tools with their capabilities.
type GetAvailableToolsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// tools is the list of available tools with detailed information
	Tools         []*AvailableToolInfo `protobuf:"bytes,1,rep,name=tools,proto3" json:"tools,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAvailableToolsResponse) Reset() {
	*x = GetAvailableToolsResponse{}
	mi := &file_daemon_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAvailableToolsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAvailableToolsResponse) ProtoMessage() {}

func (x *GetAvailableToolsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAvailableToolsResponse.ProtoReflect.Descriptor instead.
func (*GetAvailableToolsResponse) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{50}
}

func (x *GetAvailableToolsResponse) GetTools() []*AvailableToolInfo {
	if x != nil {
		return x.Tools
	}
	return nil
}

// AvailableToolInfo describes a tool's capabilities and execution metrics.
// This is distinct from ToolInfo which represents registry information.
type AvailableToolInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name is the tool name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// version is the tool version
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// description is the tool description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// tags are tool categorization tags
	Tags []string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty"`
	// input_schema_json is the JSON-encoded JSON Schema for tool input
	InputSchemaJson string `protobuf:"bytes,5,opt,name=input_schema_json,json=inputSchemaJson,proto3" json:"input_schema_json,omitempty"`
	// output_schema_json is the JSON-encoded JSON Schema for tool output
	OutputSchemaJson string `protobuf:"bytes,6,opt,name=output_schema_json,json=outputSchemaJson,proto3" json:"output_schema_json,omitempty"`
	// status is the tool readiness status ("ready", "schema-unknown", "error")
	Status string `protobuf:"bytes,7,opt,name=status,proto3" json:"status,omitempty"`
	// error_message is non-empty if status is "error"
	ErrorMessage string `protobuf:"bytes,8,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// metrics contains execution statistics for this tool
	Metrics       *ToolExecutionMetrics `protobuf:"bytes,9,opt,name=metrics,proto3" json:"metrics,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AvailableToolInfo) Reset() {
	*x = AvailableToolInfo{}
	mi := &file_daemon_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AvailableToolInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AvailableToolInfo) ProtoMessage() {}

func (x *AvailableToolInfo) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AvailableToolInfo.ProtoReflect.Descriptor instead.
func (*AvailableToolInfo) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{51}
}

func (x *AvailableToolInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AvailableToolInfo) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *AvailableToolInfo) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *AvailableToolInfo) GetTags() []string {
	if x != nil {
		return x.Tags
	}
	return nil
}

func (x *AvailableToolInfo) GetInputSchemaJson() string {
	if x != nil {
		return x.InputSchemaJson
	}
	return ""
}

func (x *AvailableToolInfo) GetOutputSchemaJson() string {
	if x != nil {
		return x.OutputSchemaJson
	}
	return ""
}

func (x *AvailableToolInfo) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *AvailableToolInfo) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *AvailableToolInfo) GetMetrics() *ToolExecutionMetrics {
	if x != nil {
		return x.Metrics
	}
	return nil
}

// ToolExecutionMetrics tracks execution statistics for a tool.
type ToolExecutionMetrics struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// total_calls is the total number of executions
	TotalCalls int64 `protobuf:"varint,1,opt,name=total_calls,json=totalCalls,proto3" json:"total_calls,omitempty"`
	// success_calls is the number of successful executions
	SuccessCalls int64 `protobuf:"varint,2,opt,name=success_calls,json=successCalls,proto3" json:"success_calls,omitempty"`
	// failed_calls is the number of failed executions
	FailedCalls int64 `protobuf:"varint,3,opt,name=failed_calls,json=failedCalls,proto3" json:"failed_calls,omitempty"`
	// avg_duration_ms is the average execution duration in milliseconds
	AvgDurationMs int64 `protobuf:"varint,4,opt,name=avg_duration_ms,json=avgDurationMs,proto3" json:"avg_duration_ms,omitempty"`
	// last_executed_at is the Unix timestamp in milliseconds of the last execution
	LastExecutedAt int64 `protobuf:"varint,5,opt,name=last_executed_at,json=lastExecutedAt,proto3" json:"last_executed_at,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ToolExecutionMetrics) Reset() {
	*x = ToolExecutionMetrics{}
	mi := &file_daemon_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolExecutionMetrics) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolExecutionMetrics) ProtoMessage() {}

func (x *ToolExecutionMetrics) ProtoReflect() protoreflect.Message {
	mi := &file_daemon_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolExecutionMetrics.ProtoReflect.Descriptor instead.
func (*ToolExecutionMetrics) Descriptor() ([]byte, []int) {
	return file_daemon_proto_rawDescGZIP(), []int{52}
}

func (x *ToolExecutionMetrics) GetTotalCalls() int64 {
	if x != nil {
		return x.TotalCalls
	}
	return 0
}

func (x *ToolExecutionMetrics) GetSuccessCalls() int64 {
	if x != nil {
		return x.SuccessCalls
	}
	return 0
}

func (x *ToolExecutionMetrics) GetFailedCalls() int64 {
	if x != nil {
		return x.FailedCalls
	}
	return 0
}

func (x *ToolExecutionMetrics) GetAvgDurationMs() int64 {
	if x != nil {
		return x.AvgDurationMs
	}
	return 0
}

func (x *ToolExecutionMetrics) GetLastExecutedAt() int64 {
	if x != nil {
		return x.LastExecutedAt
	}
	return 0
}

var File_daemon_proto protoreflect.FileDescriptor

const file_daemon_proto_rawDesc = "" +
	"\n" +
	"\fdaemon.proto\x12\x10gibson.daemon.v1\"T\n" +
	"\x0eConnectRequest\x12%\n" +
	"\x0eclient_version\x18\x01 \x01(\tR\rclientVersion\x12\x1b\n" +
	"\tclient_id\x18\x02 \x01(\tR\bclientId\"z\n" +
	"\x0fConnectResponse\x12%\n" +
	"\x0edaemon_version\x18\x01 \x01(\tR\rdaemonVersion\x12\x1d\n" +
	"\n" +
	"session_id\x18\x02 \x01(\tR\tsessionId\x12!\n" +
	"\fgrpc_address\x18\x03 \x01(\tR\vgrpcAddress\"\r\n" +
	"\vPingRequest\",\n" +
	"\fPingResponse\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\"\x0f\n" +
	"\rStatusRequest\"\xfd\x02\n" +
	"\x0eStatusResponse\x12\x18\n" +
	"\arunning\x18\x01 \x01(\bR\arunning\x12\x10\n" +
	"\x03pid\x18\x02 \x01(\x05R\x03pid\x12\x1d\n" +
	"\n" +
	"start_time\x18\x03 \x01(\x03R\tstartTime\x12\x16\n" +
	"\x06uptime\x18\x04 \x01(\tR\x06uptime\x12!\n" +
	"\fgrpc_address\x18\x05 \x01(\tR\vgrpcAddress\x12#\n" +
	"\rregistry_type\x18\x06 \x01(\tR\fregistryType\x12#\n" +
	"\rregistry_addr\x18\a \x01(\tR\fregistryAddr\x12#\n" +
	"\rcallback_addr\x18\b \x01(\tR\fcallbackAddr\x12\x1f\n" +
	"\vagent_count\x18\t \x01(\x05R\n" +
	"agentCount\x12#\n" +
	"\rmission_count\x18\n" +
	" \x01(\x05R\fmissionCount\x120\n" +
	"\x14active_mission_count\x18\v \x01(\x05R\x12activeMissionCount\"\x94\x02\n" +
	"\x11RunMissionRequest\x12#\n" +
	"\rworkflow_path\x18\x01 \x01(\tR\fworkflowPath\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x02 \x01(\tR\tmissionId\x12P\n" +
	"\tvariables\x18\x03 \x03(\v22.gibson.daemon.v1.RunMissionRequest.VariablesEntryR\tvariables\x12+\n" +
	"\x11memory_continuity\x18\x04 \x01(\tR\x10memoryContinuity\x1a<\n" +
	"\x0eVariablesEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x82\x02\n" +
	"\fMissionEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x03 \x01(\tR\tmissionId\x12\x17\n" +
	"\anode_id\x18\x04 \x01(\tR\x06nodeId\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\x12\x12\n" +
	"\x04data\x18\x06 \x01(\tR\x04data\x12\x14\n" +
	"\x05error\x18\a \x01(\tR\x05error\x129\n" +
	"\x06result\x18\b \x01(\v2!.gibson.daemon.v1.OperationResultR\x06result\"I\n" +
	"\x12StopMissionRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"I\n" +
	"\x13StopMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"\xac\x01\n" +
	"\x13ListMissionsRequest\x12\x1f\n" +
	"\vactive_only\x18\x01 \x01(\bR\n" +
	"activeOnly\x12\x14\n" +
	"\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x03 \x01(\x05R\x06offset\x12#\n" +
	"\rstatus_filter\x18\x04 \x01(\tR\fstatusFilter\x12!\n" +
	"\fname_pattern\x18\x05 \x01(\tR\vnamePattern\"g\n" +
	"\x14ListMissionsResponse\x129\n" +
	"\bmissions\x18\x01 \x03(\v2\x1d.gibson.daemon.v1.MissionInfoR\bmissions\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xb9\x01\n" +
	"\vMissionInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12#\n" +
	"\rworkflow_path\x18\x02 \x01(\tR\fworkflowPath\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"start_time\x18\x04 \x01(\x03R\tstartTime\x12\x19\n" +
	"\bend_time\x18\x05 \x01(\x03R\aendTime\x12#\n" +
	"\rfinding_count\x18\x06 \x01(\x05R\ffindingCount\"'\n" +
	"\x11ListAgentsRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\"I\n" +
	"\x12ListAgentsResponse\x123\n" +
	"\x06agents\x18\x01 \x03(\v2\x1b.gibson.daemon.v1.AgentInfoR\x06agents\"\xd2\x01\n" +
	"\tAgentInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x12\n" +
	"\x04kind\x18\x03 \x01(\tR\x04kind\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x05 \x01(\tR\bendpoint\x12\"\n" +
	"\fcapabilities\x18\x06 \x03(\tR\fcapabilities\x12\x16\n" +
	"\x06health\x18\a \x01(\tR\x06health\x12\x1b\n" +
	"\tlast_seen\x18\b \x01(\x03R\blastSeen\"2\n" +
	"\x15GetAgentStatusRequest\x12\x19\n" +
	"\bagent_id\x18\x01 \x01(\tR\aagentId\"\xab\x01\n" +
	"\x13AgentStatusResponse\x121\n" +
	"\x05agent\x18\x01 \x01(\v2\x1b.gibson.daemon.v1.AgentInfoR\x05agent\x12\x16\n" +
	"\x06active\x18\x02 \x01(\bR\x06active\x12!\n" +
	"\fcurrent_task\x18\x03 \x01(\tR\vcurrentTask\x12&\n" +
	"\x0ftask_start_time\x18\x04 \x01(\x03R\rtaskStartTime\"\x12\n" +
	"\x10ListToolsRequest\"E\n" +
	"\x11ListToolsResponse\x120\n" +
	"\x05tools\x18\x01 \x03(\v2\x1a.gibson.daemon.v1.ToolInfoR\x05tools\"\xbb\x01\n" +
	"\bToolInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x04 \x01(\tR\bendpoint\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x16\n" +
	"\x06health\x18\x06 \x01(\tR\x06health\x12\x1b\n" +
	"\tlast_seen\x18\a \x01(\x03R\blastSeen\"\x14\n" +
	"\x12ListPluginsRequest\"M\n" +
	"\x13ListPluginsResponse\x126\n" +
	"\aplugins\x18\x01 \x03(\v2\x1c.gibson.daemon.v1.PluginInfoR\aplugins\"\xbd\x01\n" +
	"\n" +
	"PluginInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x03 \x01(\tR\aversion\x12\x1a\n" +
	"\bendpoint\x18\x04 \x01(\tR\bendpoint\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x16\n" +
	"\x06health\x18\x06 \x01(\tR\x06health\x12\x1b\n" +
	"\tlast_seen\x18\a \x01(\x03R\blastSeen\"\x80\x01\n" +
	"\x12QueryPluginRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x16\n" +
	"\x06method\x18\x02 \x01(\tR\x06method\x12\x1f\n" +
	"\vparams_json\x18\x03 \x01(\tR\n" +
	"paramsJson\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x04 \x01(\x03R\ttimeoutMs\"m\n" +
	"\x13QueryPluginResponse\x12\x1f\n" +
	"\vresult_json\x18\x01 \x01(\tR\n" +
	"resultJson\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\x12\x1f\n" +
	"\vduration_ms\x18\x03 \x01(\x03R\n" +
	"durationMs\"\xc9\x02\n" +
	"\x10RunAttackRequest\x12\x16\n" +
	"\x06target\x18\x01 \x01(\tR\x06target\x12\x1f\n" +
	"\vattack_type\x18\x02 \x01(\tR\n" +
	"attackType\x12\x19\n" +
	"\bagent_id\x18\x03 \x01(\tR\aagentId\x12%\n" +
	"\x0epayload_filter\x18\x04 \x01(\tR\rpayloadFilter\x12I\n" +
	"\aoptions\x18\x05 \x03(\v2/.gibson.daemon.v1.RunAttackRequest.OptionsEntryR\aoptions\x12\x1f\n" +
	"\vtarget_name\x18\x06 \x01(\tR\n" +
	"targetName\x12\x12\n" +
	"\x04goal\x18\a \x01(\tR\x04goal\x1a:\n" +
	"\fOptionsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\x9f\x02\n" +
	"\vAttackEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x1b\n" +
	"\tattack_id\x18\x03 \x01(\tR\battackId\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\x12\x12\n" +
	"\x04data\x18\x05 \x01(\tR\x04data\x12\x14\n" +
	"\x05error\x18\x06 \x01(\tR\x05error\x127\n" +
	"\afinding\x18\a \x01(\v2\x1d.gibson.daemon.v1.FindingInfoR\afinding\x129\n" +
	"\x06result\x18\b \x01(\v2!.gibson.daemon.v1.OperationResultR\x06result\"\xe5\x01\n" +
	"\vFindingInfo\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x14\n" +
	"\x05title\x18\x02 \x01(\tR\x05title\x12\x1a\n" +
	"\bseverity\x18\x03 \x01(\tR\bseverity\x12\x1a\n" +
	"\bcategory\x18\x04 \x01(\tR\bcategory\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12\x1c\n" +
	"\ttechnique\x18\x06 \x01(\tR\ttechnique\x12\x1a\n" +
	"\bevidence\x18\a \x01(\tR\bevidence\x12\x1c\n" +
	"\ttimestamp\x18\b \x01(\x03R\ttimestamp\"R\n" +
	"\x10SubscribeRequest\x12\x1f\n" +
	"\vevent_types\x18\x01 \x03(\tR\n" +
	"eventTypes\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x02 \x01(\tR\tmissionId\"\x8c\x03\n" +
	"\x05Event\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x16\n" +
	"\x06source\x18\x03 \x01(\tR\x06source\x12\x12\n" +
	"\x04data\x18\x04 \x01(\tR\x04data\x12E\n" +
	"\rmission_event\x18\x05 \x01(\v2\x1e.gibson.daemon.v1.MissionEventH\x00R\fmissionEvent\x12B\n" +
	"\fattack_event\x18\x06 \x01(\v2\x1d.gibson.daemon.v1.AttackEventH\x00R\vattackEvent\x12?\n" +
	"\vagent_event\x18\a \x01(\v2\x1c.gibson.daemon.v1.AgentEventH\x00R\n" +
	"agentEvent\x12E\n" +
	"\rfinding_event\x18\b \x01(\v2\x1e.gibson.daemon.v1.FindingEventH\x00R\ffindingEventB\a\n" +
	"\x05event\"\xb1\x01\n" +
	"\n" +
	"AgentEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x12\x19\n" +
	"\bagent_id\x18\x03 \x01(\tR\aagentId\x12\x1d\n" +
	"\n" +
	"agent_name\x18\x04 \x01(\tR\tagentName\x12\x18\n" +
	"\amessage\x18\x05 \x01(\tR\amessage\x12\x12\n" +
	"\x04data\x18\x06 \x01(\tR\x04data\"\xa3\x01\n" +
	"\fFindingEvent\x12\x1d\n" +
	"\n" +
	"event_type\x18\x01 \x01(\tR\teventType\x12\x1c\n" +
	"\ttimestamp\x18\x02 \x01(\x03R\ttimestamp\x127\n" +
	"\afinding\x18\x03 \x01(\v2\x1d.gibson.daemon.v1.FindingInfoR\afinding\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x04 \x01(\tR\tmissionId\"?\n" +
	"\x15StartComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\x8d\x01\n" +
	"\x16StartComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x10\n" +
	"\x03pid\x18\x02 \x01(\x05R\x03pid\x12\x12\n" +
	"\x04port\x18\x03 \x01(\x05R\x04port\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\x12\x19\n" +
	"\blog_path\x18\x05 \x01(\tR\alogPath\"T\n" +
	"\x14StopComponentRequest\x12\x12\n" +
	"\x04kind\x18\x01 \x01(\tR\x04kind\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x14\n" +
	"\x05force\x18\x03 \x01(\bR\x05force\"\x91\x01\n" +
	"\x15StopComponentResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rstopped_count\x18\x02 \x01(\x05R\fstoppedCount\x12\x1f\n" +
	"\vtotal_count\x18\x03 \x01(\x05R\n" +
	"totalCount\x12\x18\n" +
	"\amessage\x18\x04 \x01(\tR\amessage\"\x87\x04\n" +
	"\x0fOperationResult\x12\x16\n" +
	"\x06status\x18\x01 \x01(\tR\x06status\x12\x1f\n" +
	"\vduration_ms\x18\x02 \x01(\x03R\n" +
	"durationMs\x12\x1d\n" +
	"\n" +
	"started_at\x18\x03 \x01(\x03R\tstartedAt\x12!\n" +
	"\fcompleted_at\x18\x04 \x01(\x03R\vcompletedAt\x12\x1d\n" +
	"\n" +
	"turns_used\x18\x05 \x01(\x05R\tturnsUsed\x12\x1f\n" +
	"\vtokens_used\x18\x06 \x01(\x03R\n" +
	"tokensUsed\x12%\n" +
	"\x0enodes_executed\x18\a \x01(\x05R\rnodesExecuted\x12!\n" +
	"\fnodes_failed\x18\b \x01(\x05R\vnodesFailed\x12%\n" +
	"\x0efindings_count\x18\t \x01(\x05R\rfindingsCount\x12%\n" +
	"\x0ecritical_count\x18\n" +
	" \x01(\x05R\rcriticalCount\x12\x1d\n" +
	"\n" +
	"high_count\x18\v \x01(\x05R\thighCount\x12!\n" +
	"\fmedium_count\x18\f \x01(\x05R\vmediumCount\x12\x1b\n" +
	"\tlow_count\x18\r \x01(\x05R\blowCount\x12#\n" +
	"\rerror_message\x18\x0e \x01(\tR\ferrorMessage\x12\x1d\n" +
	"\n" +
	"error_code\x18\x0f \x01(\tR\terrorCode\"J\n" +
	"\x13PauseMissionRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"o\n" +
	"\x14PauseMissionResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12#\n" +
	"\rcheckpoint_id\x18\x02 \x01(\tR\fcheckpointId\x12\x18\n" +
	"\amessage\x18\x03 \x01(\tR\amessage\"Z\n" +
	"\x14ResumeMissionRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12#\n" +
	"\rcheckpoint_id\x18\x02 \x01(\tR\fcheckpointId\"\\\n" +
	"\x18GetMissionHistoryRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05limit\x18\x02 \x01(\x05R\x05limit\x12\x16\n" +
	"\x06offset\x18\x03 \x01(\x05R\x06offset\"c\n" +
	"\x19GetMissionHistoryResponse\x120\n" +
	"\x04runs\x18\x01 \x03(\v2\x1c.gibson.daemon.v1.MissionRunR\x04runs\x12\x14\n" +
	"\x05total\x18\x02 \x01(\x05R\x05total\"\xf3\x01\n" +
	"\n" +
	"MissionRun\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\x12\x1d\n" +
	"\n" +
	"run_number\x18\x02 \x01(\x05R\trunNumber\x12\x16\n" +
	"\x06status\x18\x03 \x01(\tR\x06status\x12\x1d\n" +
	"\n" +
	"created_at\x18\x04 \x01(\x03R\tcreatedAt\x12!\n" +
	"\fcompleted_at\x18\x05 \x01(\x03R\vcompletedAt\x12%\n" +
	"\x0efindings_count\x18\x06 \x01(\x05R\rfindingsCount\x12&\n" +
	"\x0fprevious_run_id\x18\a \x01(\tR\rpreviousRunId\"=\n" +
	"\x1cGetMissionCheckpointsRequest\x12\x1d\n" +
	"\n" +
	"mission_id\x18\x01 \x01(\tR\tmissionId\"c\n" +
	"\x1dGetMissionCheckpointsResponse\x12B\n" +
	"\vcheckpoints\x18\x01 \x03(\v2 .gibson.daemon.v1.CheckpointInfoR\vcheckpoints\"\xdf\x01\n" +
	"\x0eCheckpointInfo\x12#\n" +
	"\rcheckpoint_id\x18\x01 \x01(\tR\fcheckpointId\x12\x1d\n" +
	"\n" +
	"created_at\x18\x02 \x01(\x03R\tcreatedAt\x12'\n" +
	"\x0fcompleted_nodes\x18\x03 \x01(\x05R\x0ecompletedNodes\x12\x1f\n" +
	"\vtotal_nodes\x18\x04 \x01(\x05R\n" +
	"totalNodes\x12%\n" +
	"\x0efindings_count\x18\x05 \x01(\x05R\rfindingsCount\x12\x18\n" +
	"\aversion\x18\x06 \x01(\x05R\aversion\"f\n" +
	"\x12ExecuteToolRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1d\n" +
	"\n" +
	"input_json\x18\x02 \x01(\tR\tinputJson\x12\x1d\n" +
	"\n" +
	"timeout_ms\x18\x03 \x01(\x03R\ttimeoutMs\"\x87\x01\n" +
	"\x13ExecuteToolResponse\x12\x18\n" +
	"\asuccess\x18\x01 \x01(\bR\asuccess\x12\x1f\n" +
	"\voutput_json\x18\x02 \x01(\tR\n" +
	"outputJson\x12\x14\n" +
	"\x05error\x18\x03 \x01(\tR\x05error\x12\x1f\n" +
	"\vduration_ms\x18\x04 \x01(\x03R\n" +
	"durationMs\"\x1a\n" +
	"\x18GetAvailableToolsRequest\"V\n" +
	"\x19GetAvailableToolsResponse\x129\n" +
	"\x05tools\x18\x01 \x03(\v2#.gibson.daemon.v1.AvailableToolInfoR\x05tools\"\xd0\x02\n" +
	"\x11AvailableToolInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\x12\n" +
	"\x04tags\x18\x04 \x03(\tR\x04tags\x12*\n" +
	"\x11input_schema_json\x18\x05 \x01(\tR\x0finputSchemaJson\x12,\n" +
	"\x12output_schema_json\x18\x06 \x01(\tR\x10outputSchemaJson\x12\x16\n" +
	"\x06status\x18\a \x01(\tR\x06status\x12#\n" +
	"\rerror_message\x18\b \x01(\tR\ferrorMessage\x12@\n" +
	"\ametrics\x18\t \x01(\v2&.gibson.daemon.v1.ToolExecutionMetricsR\ametrics\"\xd1\x01\n" +
	"\x14ToolExecutionMetrics\x12\x1f\n" +
	"\vtotal_calls\x18\x01 \x01(\x03R\n" +
	"totalCalls\x12#\n" +
	"\rsuccess_calls\x18\x02 \x01(\x03R\fsuccessCalls\x12!\n" +
	"\ffailed_calls\x18\x03 \x01(\x03R\vfailedCalls\x12&\n" +
	"\x0favg_duration_ms\x18\x04 \x01(\x03R\ravgDurationMs\x12(\n" +
	"\x10last_executed_at\x18\x05 \x01(\x03R\x0elastExecutedAt2\x9d\x0f\n" +
	"\rDaemonService\x12N\n" +
	"\aConnect\x12 .gibson.daemon.v1.ConnectRequest\x1a!.gibson.daemon.v1.ConnectResponse\x12E\n" +
	"\x04Ping\x12\x1d.gibson.daemon.v1.PingRequest\x1a\x1e.gibson.daemon.v1.PingResponse\x12K\n" +
	"\x06Status\x12\x1f.gibson.daemon.v1.StatusRequest\x1a .gibson.daemon.v1.StatusResponse\x12S\n" +
	"\n" +
	"RunMission\x12#.gibson.daemon.v1.RunMissionRequest\x1a\x1e.gibson.daemon.v1.MissionEvent0\x01\x12Z\n" +
	"\vStopMission\x12$.gibson.daemon.v1.StopMissionRequest\x1a%.gibson.daemon.v1.StopMissionResponse\x12]\n" +
	"\fListMissions\x12%.gibson.daemon.v1.ListMissionsRequest\x1a&.gibson.daemon.v1.ListMissionsResponse\x12W\n" +
	"\n" +
	"ListAgents\x12#.gibson.daemon.v1.ListAgentsRequest\x1a$.gibson.daemon.v1.ListAgentsResponse\x12`\n" +
	"\x0eGetAgentStatus\x12'.gibson.daemon.v1.GetAgentStatusRequest\x1a%.gibson.daemon.v1.AgentStatusResponse\x12T\n" +
	"\tListTools\x12\".gibson.daemon.v1.ListToolsRequest\x1a#.gibson.daemon.v1.ListToolsResponse\x12Z\n" +
	"\vListPlugins\x12$.gibson.daemon.v1.ListPluginsRequest\x1a%.gibson.daemon.v1.ListPluginsResponse\x12Z\n" +
	"\vQueryPlugin\x12$.gibson.daemon.v1.QueryPluginRequest\x1a%.gibson.daemon.v1.QueryPluginResponse\x12P\n" +
	"\tRunAttack\x12\".gibson.daemon.v1.RunAttackRequest\x1a\x1d.gibson.daemon.v1.AttackEvent0\x01\x12J\n" +
	"\tSubscribe\x12\".gibson.daemon.v1.SubscribeRequest\x1a\x17.gibson.daemon.v1.Event0\x01\x12c\n" +
	"\x0eStartComponent\x12'.gibson.daemon.v1.StartComponentRequest\x1a(.gibson.daemon.v1.StartComponentResponse\x12`\n" +
	"\rStopComponent\x12&.gibson.daemon.v1.StopComponentRequest\x1a'.gibson.daemon.v1.StopComponentResponse\x12]\n" +
	"\fPauseMission\x12%.gibson.daemon.v1.PauseMissionRequest\x1a&.gibson.daemon.v1.PauseMissionResponse\x12Y\n" +
	"\rResumeMission\x12&.gibson.daemon.v1.ResumeMissionRequest\x1a\x1e.gibson.daemon.v1.MissionEvent0\x01\x12l\n" +
	"\x11GetMissionHistory\x12*.gibson.daemon.v1.GetMissionHistoryRequest\x1a+.gibson.daemon.v1.GetMissionHistoryResponse\x12x\n" +
	"\x15GetMissionCheckpoints\x12..gibson.daemon.v1.GetMissionCheckpointsRequest\x1a/.gibson.daemon.v1.GetMissionCheckpointsResponse\x12Z\n" +
	"\vExecuteTool\x12$.gibson.daemon.v1.ExecuteToolRequest\x1a%.gibson.daemon.v1.ExecuteToolResponse\x12l\n" +
	"\x11GetAvailableTools\x12*.gibson.daemon.v1.GetAvailableToolsRequest\x1a+.gibson.daemon.v1.GetAvailableToolsResponseB7Z5github.com/zero-day-ai/gibson/internal/daemon/api;apib\x06proto3"

var (
	file_daemon_proto_rawDescOnce sync.Once
	file_daemon_proto_rawDescData []byte
)

func file_daemon_proto_rawDescGZIP() []byte {
	file_daemon_proto_rawDescOnce.Do(func() {
		file_daemon_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_daemon_proto_rawDesc), len(file_daemon_proto_rawDesc)))
	})
	return file_daemon_proto_rawDescData
}

var file_daemon_proto_msgTypes = make([]protoimpl.MessageInfo, 55)
var file_daemon_proto_goTypes = []any{
	(*ConnectRequest)(nil),                // 0: gibson.daemon.v1.ConnectRequest
	(*ConnectResponse)(nil),               // 1: gibson.daemon.v1.ConnectResponse
	(*PingRequest)(nil),                   // 2: gibson.daemon.v1.PingRequest
	(*PingResponse)(nil),                  // 3: gibson.daemon.v1.PingResponse
	(*StatusRequest)(nil),                 // 4: gibson.daemon.v1.StatusRequest
	(*StatusResponse)(nil),                // 5: gibson.daemon.v1.StatusResponse
	(*RunMissionRequest)(nil),             // 6: gibson.daemon.v1.RunMissionRequest
	(*MissionEvent)(nil),                  // 7: gibson.daemon.v1.MissionEvent
	(*StopMissionRequest)(nil),            // 8: gibson.daemon.v1.StopMissionRequest
	(*StopMissionResponse)(nil),           // 9: gibson.daemon.v1.StopMissionResponse
	(*ListMissionsRequest)(nil),           // 10: gibson.daemon.v1.ListMissionsRequest
	(*ListMissionsResponse)(nil),          // 11: gibson.daemon.v1.ListMissionsResponse
	(*MissionInfo)(nil),                   // 12: gibson.daemon.v1.MissionInfo
	(*ListAgentsRequest)(nil),             // 13: gibson.daemon.v1.ListAgentsRequest
	(*ListAgentsResponse)(nil),            // 14: gibson.daemon.v1.ListAgentsResponse
	(*AgentInfo)(nil),                     // 15: gibson.daemon.v1.AgentInfo
	(*GetAgentStatusRequest)(nil),         // 16: gibson.daemon.v1.GetAgentStatusRequest
	(*AgentStatusResponse)(nil),           // 17: gibson.daemon.v1.AgentStatusResponse
	(*ListToolsRequest)(nil),              // 18: gibson.daemon.v1.ListToolsRequest
	(*ListToolsResponse)(nil),             // 19: gibson.daemon.v1.ListToolsResponse
	(*ToolInfo)(nil),                      // 20: gibson.daemon.v1.ToolInfo
	(*ListPluginsRequest)(nil),            // 21: gibson.daemon.v1.ListPluginsRequest
	(*ListPluginsResponse)(nil),           // 22: gibson.daemon.v1.ListPluginsResponse
	(*PluginInfo)(nil),                    // 23: gibson.daemon.v1.PluginInfo
	(*QueryPluginRequest)(nil),            // 24: gibson.daemon.v1.QueryPluginRequest
	(*QueryPluginResponse)(nil),           // 25: gibson.daemon.v1.QueryPluginResponse
	(*RunAttackRequest)(nil),              // 26: gibson.daemon.v1.RunAttackRequest
	(*AttackEvent)(nil),                   // 27: gibson.daemon.v1.AttackEvent
	(*FindingInfo)(nil),                   // 28: gibson.daemon.v1.FindingInfo
	(*SubscribeRequest)(nil),              // 29: gibson.daemon.v1.SubscribeRequest
	(*Event)(nil),                         // 30: gibson.daemon.v1.Event
	(*AgentEvent)(nil),                    // 31: gibson.daemon.v1.AgentEvent
	(*FindingEvent)(nil),                  // 32: gibson.daemon.v1.FindingEvent
	(*StartComponentRequest)(nil),         // 33: gibson.daemon.v1.StartComponentRequest
	(*StartComponentResponse)(nil),        // 34: gibson.daemon.v1.StartComponentResponse
	(*StopComponentRequest)(nil),          // 35: gibson.daemon.v1.StopComponentRequest
	(*StopComponentResponse)(nil),         // 36: gibson.daemon.v1.StopComponentResponse
	(*OperationResult)(nil),               // 37: gibson.daemon.v1.OperationResult
	(*PauseMissionRequest)(nil),           // 38: gibson.daemon.v1.PauseMissionRequest
	(*PauseMissionResponse)(nil),          // 39: gibson.daemon.v1.PauseMissionResponse
	(*ResumeMissionRequest)(nil),          // 40: gibson.daemon.v1.ResumeMissionRequest
	(*GetMissionHistoryRequest)(nil),      // 41: gibson.daemon.v1.GetMissionHistoryRequest
	(*GetMissionHistoryResponse)(nil),     // 42: gibson.daemon.v1.GetMissionHistoryResponse
	(*MissionRun)(nil),                    // 43: gibson.daemon.v1.MissionRun
	(*GetMissionCheckpointsRequest)(nil),  // 44: gibson.daemon.v1.GetMissionCheckpointsRequest
	(*GetMissionCheckpointsResponse)(nil), // 45: gibson.daemon.v1.GetMissionCheckpointsResponse
	(*CheckpointInfo)(nil),                // 46: gibson.daemon.v1.CheckpointInfo
	(*ExecuteToolRequest)(nil),            // 47: gibson.daemon.v1.ExecuteToolRequest
	(*ExecuteToolResponse)(nil),           // 48: gibson.daemon.v1.ExecuteToolResponse
	(*GetAvailableToolsRequest)(nil),      // 49: gibson.daemon.v1.GetAvailableToolsRequest
	(*GetAvailableToolsResponse)(nil),     // 50: gibson.daemon.v1.GetAvailableToolsResponse
	(*AvailableToolInfo)(nil),             // 51: gibson.daemon.v1.AvailableToolInfo
	(*ToolExecutionMetrics)(nil),          // 52: gibson.daemon.v1.ToolExecutionMetrics
	nil,                                   // 53: gibson.daemon.v1.RunMissionRequest.VariablesEntry
	nil,                                   // 54: gibson.daemon.v1.RunAttackRequest.OptionsEntry
}
var file_daemon_proto_depIdxs = []int32{
	53, // 0: gibson.daemon.v1.RunMissionRequest.variables:type_name -> gibson.daemon.v1.RunMissionRequest.VariablesEntry
	37, // 1: gibson.daemon.v1.MissionEvent.result:type_name -> gibson.daemon.v1.OperationResult
	12, // 2: gibson.daemon.v1.ListMissionsResponse.missions:type_name -> gibson.daemon.v1.MissionInfo
	15, // 3: gibson.daemon.v1.ListAgentsResponse.agents:type_name -> gibson.daemon.v1.AgentInfo
	15, // 4: gibson.daemon.v1.AgentStatusResponse.agent:type_name -> gibson.daemon.v1.AgentInfo
	20, // 5: gibson.daemon.v1.ListToolsResponse.tools:type_name -> gibson.daemon.v1.ToolInfo
	23, // 6: gibson.daemon.v1.ListPluginsResponse.plugins:type_name -> gibson.daemon.v1.PluginInfo
	54, // 7: gibson.daemon.v1.RunAttackRequest.options:type_name -> gibson.daemon.v1.RunAttackRequest.OptionsEntry
	28, // 8: gibson.daemon.v1.AttackEvent.finding:type_name -> gibson.daemon.v1.FindingInfo
	37, // 9: gibson.daemon.v1.AttackEvent.result:type_name -> gibson.daemon.v1.OperationResult
	7,  // 10: gibson.daemon.v1.Event.mission_event:type_name -> gibson.daemon.v1.MissionEvent
	27, // 11: gibson.daemon.v1.Event.attack_event:type_name -> gibson.daemon.v1.AttackEvent
	31, // 12: gibson.daemon.v1.Event.agent_event:type_name -> gibson.daemon.v1.AgentEvent
	32, // 13: gibson.daemon.v1.Event.finding_event:type_name -> gibson.daemon.v1.FindingEvent
	28, // 14: gibson.daemon.v1.FindingEvent.finding:type_name -> gibson.daemon.v1.FindingInfo
	43, // 15: gibson.daemon.v1.GetMissionHistoryResponse.runs:type_name -> gibson.daemon.v1.MissionRun
	46, // 16: gibson.daemon.v1.GetMissionCheckpointsResponse.checkpoints:type_name -> gibson.daemon.v1.CheckpointInfo
	51, // 17: gibson.daemon.v1.GetAvailableToolsResponse.tools:type_name -> gibson.daemon.v1.AvailableToolInfo
	52, // 18: gibson.daemon.v1.AvailableToolInfo.metrics:type_name -> gibson.daemon.v1.ToolExecutionMetrics
	0,  // 19: gibson.daemon.v1.DaemonService.Connect:input_type -> gibson.daemon.v1.ConnectRequest
	2,  // 20: gibson.daemon.v1.DaemonService.Ping:input_type -> gibson.daemon.v1.PingRequest
	4,  // 21: gibson.daemon.v1.DaemonService.Status:input_type -> gibson.daemon.v1.StatusRequest
	6,  // 22: gibson.daemon.v1.DaemonService.RunMission:input_type -> gibson.daemon.v1.RunMissionRequest
	8,  // 23: gibson.daemon.v1.DaemonService.StopMission:input_type -> gibson.daemon.v1.StopMissionRequest
	10, // 24: gibson.daemon.v1.DaemonService.ListMissions:input_type -> gibson.daemon.v1.ListMissionsRequest
	13, // 25: gibson.daemon.v1.DaemonService.ListAgents:input_type -> gibson.daemon.v1.ListAgentsRequest
	16, // 26: gibson.daemon.v1.DaemonService.GetAgentStatus:input_type -> gibson.daemon.v1.GetAgentStatusRequest
	18, // 27: gibson.daemon.v1.DaemonService.ListTools:input_type -> gibson.daemon.v1.ListToolsRequest
	21, // 28: gibson.daemon.v1.DaemonService.ListPlugins:input_type -> gibson.daemon.v1.ListPluginsRequest
	24, // 29: gibson.daemon.v1.DaemonService.QueryPlugin:input_type -> gibson.daemon.v1.QueryPluginRequest
	26, // 30: gibson.daemon.v1.DaemonService.RunAttack:input_type -> gibson.daemon.v1.RunAttackRequest
	29, // 31: gibson.daemon.v1.DaemonService.Subscribe:input_type -> gibson.daemon.v1.SubscribeRequest
	33, // 32: gibson.daemon.v1.DaemonService.StartComponent:input_type -> gibson.daemon.v1.StartComponentRequest
	35, // 33: gibson.daemon.v1.DaemonService.StopComponent:input_type -> gibson.daemon.v1.StopComponentRequest
	38, // 34: gibson.daemon.v1.DaemonService.PauseMission:input_type -> gibson.daemon.v1.PauseMissionRequest
	40, // 35: gibson.daemon.v1.DaemonService.ResumeMission:input_type -> gibson.daemon.v1.ResumeMissionRequest
	41, // 36: gibson.daemon.v1.DaemonService.GetMissionHistory:input_type -> gibson.daemon.v1.GetMissionHistoryRequest
	44, // 37: gibson.daemon.v1.DaemonService.GetMissionCheckpoints:input_type -> gibson.daemon.v1.GetMissionCheckpointsRequest
	47, // 38: gibson.daemon.v1.DaemonService.ExecuteTool:input_type -> gibson.daemon.v1.ExecuteToolRequest
	49, // 39: gibson.daemon.v1.DaemonService.GetAvailableTools:input_type -> gibson.daemon.v1.GetAvailableToolsRequest
	1,  // 40: gibson.daemon.v1.DaemonService.Connect:output_type -> gibson.daemon.v1.ConnectResponse
	3,  // 41: gibson.daemon.v1.DaemonService.Ping:output_type -> gibson.daemon.v1.PingResponse
	5,  // 42: gibson.daemon.v1.DaemonService.Status:output_type -> gibson.daemon.v1.StatusResponse
	7,  // 43: gibson.daemon.v1.DaemonService.RunMission:output_type -> gibson.daemon.v1.MissionEvent
	9,  // 44: gibson.daemon.v1.DaemonService.StopMission:output_type -> gibson.daemon.v1.StopMissionResponse
	11, // 45: gibson.daemon.v1.DaemonService.ListMissions:output_type -> gibson.daemon.v1.ListMissionsResponse
	14, // 46: gibson.daemon.v1.DaemonService.ListAgents:output_type -> gibson.daemon.v1.ListAgentsResponse
	17, // 47: gibson.daemon.v1.DaemonService.GetAgentStatus:output_type -> gibson.daemon.v1.AgentStatusResponse
	19, // 48: gibson.daemon.v1.DaemonService.ListTools:output_type -> gibson.daemon.v1.ListToolsResponse
	22, // 49: gibson.daemon.v1.DaemonService.ListPlugins:output_type -> gibson.daemon.v1.ListPluginsResponse
	25, // 50: gibson.daemon.v1.DaemonService.QueryPlugin:output_type -> gibson.daemon.v1.QueryPluginResponse
	27, // 51: gibson.daemon.v1.DaemonService.RunAttack:output_type -> gibson.daemon.v1.AttackEvent
	30, // 52: gibson.daemon.v1.DaemonService.Subscribe:output_type -> gibson.daemon.v1.Event
	34, // 53: gibson.daemon.v1.DaemonService.StartComponent:output_type -> gibson.daemon.v1.StartComponentResponse
	36, // 54: gibson.daemon.v1.DaemonService.StopComponent:output_type -> gibson.daemon.v1.StopComponentResponse
	39, // 55: gibson.daemon.v1.DaemonService.PauseMission:output_type -> gibson.daemon.v1.PauseMissionResponse
	7,  // 56: gibson.daemon.v1.DaemonService.ResumeMission:output_type -> gibson.daemon.v1.MissionEvent
	42, // 57: gibson.daemon.v1.DaemonService.GetMissionHistory:output_type -> gibson.daemon.v1.GetMissionHistoryResponse
	45, // 58: gibson.daemon.v1.DaemonService.GetMissionCheckpoints:output_type -> gibson.daemon.v1.GetMissionCheckpointsResponse
	48, // 59: gibson.daemon.v1.DaemonService.ExecuteTool:output_type -> gibson.daemon.v1.ExecuteToolResponse
	50, // 60: gibson.daemon.v1.DaemonService.GetAvailableTools:output_type -> gibson.daemon.v1.GetAvailableToolsResponse
	40, // [40:61] is the sub-list for method output_type
	19, // [19:40] is the sub-list for method input_type
	19, // [19:19] is the sub-list for extension type_name
	19, // [19:19] is the sub-list for extension extendee
	0,  // [0:19] is the sub-list for field type_name
}

func init() { file_daemon_proto_init() }
func file_daemon_proto_init() {
	if File_daemon_proto != nil {
		return
	}
	file_daemon_proto_msgTypes[30].OneofWrappers = []any{
		(*Event_MissionEvent)(nil),
		(*Event_AttackEvent)(nil),
		(*Event_AgentEvent)(nil),
		(*Event_FindingEvent)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_daemon_proto_rawDesc), len(file_daemon_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   55,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_daemon_proto_goTypes,
		DependencyIndexes: file_daemon_proto_depIdxs,
		MessageInfos:      file_daemon_proto_msgTypes,
	}.Build()
	File_daemon_proto = out.File
	file_daemon_proto_goTypes = nil
	file_daemon_proto_depIdxs = nil
}
