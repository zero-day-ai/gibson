// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v4.25.1
// source: daemon.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DaemonService_Connect_FullMethodName               = "/gibson.daemon.v1.DaemonService/Connect"
	DaemonService_Ping_FullMethodName                  = "/gibson.daemon.v1.DaemonService/Ping"
	DaemonService_Status_FullMethodName                = "/gibson.daemon.v1.DaemonService/Status"
	DaemonService_RunMission_FullMethodName            = "/gibson.daemon.v1.DaemonService/RunMission"
	DaemonService_StopMission_FullMethodName           = "/gibson.daemon.v1.DaemonService/StopMission"
	DaemonService_ListMissions_FullMethodName          = "/gibson.daemon.v1.DaemonService/ListMissions"
	DaemonService_ListAgents_FullMethodName            = "/gibson.daemon.v1.DaemonService/ListAgents"
	DaemonService_GetAgentStatus_FullMethodName        = "/gibson.daemon.v1.DaemonService/GetAgentStatus"
	DaemonService_ListTools_FullMethodName             = "/gibson.daemon.v1.DaemonService/ListTools"
	DaemonService_ListPlugins_FullMethodName           = "/gibson.daemon.v1.DaemonService/ListPlugins"
	DaemonService_QueryPlugin_FullMethodName           = "/gibson.daemon.v1.DaemonService/QueryPlugin"
	DaemonService_RunAttack_FullMethodName             = "/gibson.daemon.v1.DaemonService/RunAttack"
	DaemonService_Subscribe_FullMethodName             = "/gibson.daemon.v1.DaemonService/Subscribe"
	DaemonService_StartComponent_FullMethodName        = "/gibson.daemon.v1.DaemonService/StartComponent"
	DaemonService_StopComponent_FullMethodName         = "/gibson.daemon.v1.DaemonService/StopComponent"
	DaemonService_PauseMission_FullMethodName          = "/gibson.daemon.v1.DaemonService/PauseMission"
	DaemonService_ResumeMission_FullMethodName         = "/gibson.daemon.v1.DaemonService/ResumeMission"
	DaemonService_GetMissionHistory_FullMethodName     = "/gibson.daemon.v1.DaemonService/GetMissionHistory"
	DaemonService_GetMissionCheckpoints_FullMethodName = "/gibson.daemon.v1.DaemonService/GetMissionCheckpoints"
	DaemonService_ExecuteTool_FullMethodName           = "/gibson.daemon.v1.DaemonService/ExecuteTool"
	DaemonService_GetAvailableTools_FullMethodName     = "/gibson.daemon.v1.DaemonService/GetAvailableTools"
)

// DaemonServiceClient is the client API for DaemonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// DaemonService provides the gRPC API for Gibson daemon client communication.
//
// This service exposes all daemon functionality including mission execution,
// agent management, attack operations, and real-time event streaming for the TUI.
type DaemonServiceClient interface {
	// Connect establishes a client connection to the daemon.
	// Returns connection metadata and daemon version info.
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	// Ping checks if the daemon is responsive.
	// Used for health checks and connection validation.
	Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error)
	// Status returns the current daemon status including uptime,
	// service endpoints, and component counts.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// RunMission starts a mission and streams execution events.
	// The stream remains open until the mission completes or is stopped.
	RunMission(ctx context.Context, in *RunMissionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MissionEvent], error)
	// StopMission gracefully stops a running mission.
	StopMission(ctx context.Context, in *StopMissionRequest, opts ...grpc.CallOption) (*StopMissionResponse, error)
	// ListMissions returns all missions (past and active).
	ListMissions(ctx context.Context, in *ListMissionsRequest, opts ...grpc.CallOption) (*ListMissionsResponse, error)
	// ListAgents returns all registered agents from the etcd registry.
	ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error)
	// GetAgentStatus returns the current status of a specific agent.
	GetAgentStatus(ctx context.Context, in *GetAgentStatusRequest, opts ...grpc.CallOption) (*AgentStatusResponse, error)
	// ListTools returns all registered tools from the etcd registry.
	ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error)
	// ListPlugins returns all registered plugins from the etcd registry.
	ListPlugins(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error)
	// QueryPlugin executes a method on a plugin and returns the result.
	// The plugin must be registered in the etcd registry.
	QueryPlugin(ctx context.Context, in *QueryPluginRequest, opts ...grpc.CallOption) (*QueryPluginResponse, error)
	// RunAttack executes an attack and streams progress events.
	// The stream remains open until the attack completes or is stopped.
	RunAttack(ctx context.Context, in *RunAttackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttackEvent], error)
	// Subscribe establishes an event stream for TUI real-time updates.
	// Streams mission events, agent events, finding events, etc.
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error)
	// StartComponent starts a component (agent, tool, or plugin) by kind and name.
	// The component must be installed in the local database.
	StartComponent(ctx context.Context, in *StartComponentRequest, opts ...grpc.CallOption) (*StartComponentResponse, error)
	// StopComponent stops a running component (agent, tool, or plugin) by kind and name.
	// If force is true, sends SIGKILL immediately instead of graceful SIGTERM.
	StopComponent(ctx context.Context, in *StopComponentRequest, opts ...grpc.CallOption) (*StopComponentResponse, error)
	// PauseMission pauses a running mission at the next clean checkpoint boundary.
	// If force is true, pauses immediately without waiting for a clean boundary.
	PauseMission(ctx context.Context, in *PauseMissionRequest, opts ...grpc.CallOption) (*PauseMissionResponse, error)
	// ResumeMission resumes a paused mission from its last checkpoint.
	// Returns a stream of mission events as execution continues.
	ResumeMission(ctx context.Context, in *ResumeMissionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MissionEvent], error)
	// GetMissionHistory returns all runs for a mission name, showing the
	// complete history of mission executions with the same workflow name.
	GetMissionHistory(ctx context.Context, in *GetMissionHistoryRequest, opts ...grpc.CallOption) (*GetMissionHistoryResponse, error)
	// GetMissionCheckpoints returns all checkpoints for a specific mission,
	// providing visibility into saved execution states for resume capability.
	GetMissionCheckpoints(ctx context.Context, in *GetMissionCheckpointsRequest, opts ...grpc.CallOption) (*GetMissionCheckpointsResponse, error)
	// ExecuteTool executes a tool via the Tool Executor Service.
	// Routes tool execution through the centralized tool executor which handles
	// schema validation, timeout management, and execution tracking.
	ExecuteTool(ctx context.Context, in *ExecuteToolRequest, opts ...grpc.CallOption) (*ExecuteToolResponse, error)
	// GetAvailableTools returns all available tools from the Tool Executor Service.
	// Provides detailed information about each tool including schemas, capabilities,
	// and execution metrics.
	GetAvailableTools(ctx context.Context, in *GetAvailableToolsRequest, opts ...grpc.CallOption) (*GetAvailableToolsResponse, error)
}

type daemonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonServiceClient(cc grpc.ClientConnInterface) DaemonServiceClient {
	return &daemonServiceClient{cc}
}

func (c *daemonServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, DaemonService_Connect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) Ping(ctx context.Context, in *PingRequest, opts ...grpc.CallOption) (*PingResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PingResponse)
	err := c.cc.Invoke(ctx, DaemonService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, DaemonService_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) RunMission(ctx context.Context, in *RunMissionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MissionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DaemonService_ServiceDesc.Streams[0], DaemonService_RunMission_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunMissionRequest, MissionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_RunMissionClient = grpc.ServerStreamingClient[MissionEvent]

func (c *daemonServiceClient) StopMission(ctx context.Context, in *StopMissionRequest, opts ...grpc.CallOption) (*StopMissionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopMissionResponse)
	err := c.cc.Invoke(ctx, DaemonService_StopMission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) ListMissions(ctx context.Context, in *ListMissionsRequest, opts ...grpc.CallOption) (*ListMissionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListMissionsResponse)
	err := c.cc.Invoke(ctx, DaemonService_ListMissions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) ListAgents(ctx context.Context, in *ListAgentsRequest, opts ...grpc.CallOption) (*ListAgentsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAgentsResponse)
	err := c.cc.Invoke(ctx, DaemonService_ListAgents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) GetAgentStatus(ctx context.Context, in *GetAgentStatusRequest, opts ...grpc.CallOption) (*AgentStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AgentStatusResponse)
	err := c.cc.Invoke(ctx, DaemonService_GetAgentStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) ListTools(ctx context.Context, in *ListToolsRequest, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListToolsResponse)
	err := c.cc.Invoke(ctx, DaemonService_ListTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) ListPlugins(ctx context.Context, in *ListPluginsRequest, opts ...grpc.CallOption) (*ListPluginsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPluginsResponse)
	err := c.cc.Invoke(ctx, DaemonService_ListPlugins_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) QueryPlugin(ctx context.Context, in *QueryPluginRequest, opts ...grpc.CallOption) (*QueryPluginResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(QueryPluginResponse)
	err := c.cc.Invoke(ctx, DaemonService_QueryPlugin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) RunAttack(ctx context.Context, in *RunAttackRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[AttackEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DaemonService_ServiceDesc.Streams[1], DaemonService_RunAttack_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RunAttackRequest, AttackEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_RunAttackClient = grpc.ServerStreamingClient[AttackEvent]

func (c *daemonServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Event], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DaemonService_ServiceDesc.Streams[2], DaemonService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, Event]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_SubscribeClient = grpc.ServerStreamingClient[Event]

func (c *daemonServiceClient) StartComponent(ctx context.Context, in *StartComponentRequest, opts ...grpc.CallOption) (*StartComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartComponentResponse)
	err := c.cc.Invoke(ctx, DaemonService_StartComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) StopComponent(ctx context.Context, in *StopComponentRequest, opts ...grpc.CallOption) (*StopComponentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopComponentResponse)
	err := c.cc.Invoke(ctx, DaemonService_StopComponent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) PauseMission(ctx context.Context, in *PauseMissionRequest, opts ...grpc.CallOption) (*PauseMissionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PauseMissionResponse)
	err := c.cc.Invoke(ctx, DaemonService_PauseMission_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) ResumeMission(ctx context.Context, in *ResumeMissionRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[MissionEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DaemonService_ServiceDesc.Streams[3], DaemonService_ResumeMission_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ResumeMissionRequest, MissionEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_ResumeMissionClient = grpc.ServerStreamingClient[MissionEvent]

func (c *daemonServiceClient) GetMissionHistory(ctx context.Context, in *GetMissionHistoryRequest, opts ...grpc.CallOption) (*GetMissionHistoryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMissionHistoryResponse)
	err := c.cc.Invoke(ctx, DaemonService_GetMissionHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) GetMissionCheckpoints(ctx context.Context, in *GetMissionCheckpointsRequest, opts ...grpc.CallOption) (*GetMissionCheckpointsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMissionCheckpointsResponse)
	err := c.cc.Invoke(ctx, DaemonService_GetMissionCheckpoints_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) ExecuteTool(ctx context.Context, in *ExecuteToolRequest, opts ...grpc.CallOption) (*ExecuteToolResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteToolResponse)
	err := c.cc.Invoke(ctx, DaemonService_ExecuteTool_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) GetAvailableTools(ctx context.Context, in *GetAvailableToolsRequest, opts ...grpc.CallOption) (*GetAvailableToolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAvailableToolsResponse)
	err := c.cc.Invoke(ctx, DaemonService_GetAvailableTools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DaemonServiceServer is the server API for DaemonService service.
// All implementations must embed UnimplementedDaemonServiceServer
// for forward compatibility.
//
// DaemonService provides the gRPC API for Gibson daemon client communication.
//
// This service exposes all daemon functionality including mission execution,
// agent management, attack operations, and real-time event streaming for the TUI.
type DaemonServiceServer interface {
	// Connect establishes a client connection to the daemon.
	// Returns connection metadata and daemon version info.
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	// Ping checks if the daemon is responsive.
	// Used for health checks and connection validation.
	Ping(context.Context, *PingRequest) (*PingResponse, error)
	// Status returns the current daemon status including uptime,
	// service endpoints, and component counts.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	// RunMission starts a mission and streams execution events.
	// The stream remains open until the mission completes or is stopped.
	RunMission(*RunMissionRequest, grpc.ServerStreamingServer[MissionEvent]) error
	// StopMission gracefully stops a running mission.
	StopMission(context.Context, *StopMissionRequest) (*StopMissionResponse, error)
	// ListMissions returns all missions (past and active).
	ListMissions(context.Context, *ListMissionsRequest) (*ListMissionsResponse, error)
	// ListAgents returns all registered agents from the etcd registry.
	ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error)
	// GetAgentStatus returns the current status of a specific agent.
	GetAgentStatus(context.Context, *GetAgentStatusRequest) (*AgentStatusResponse, error)
	// ListTools returns all registered tools from the etcd registry.
	ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error)
	// ListPlugins returns all registered plugins from the etcd registry.
	ListPlugins(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error)
	// QueryPlugin executes a method on a plugin and returns the result.
	// The plugin must be registered in the etcd registry.
	QueryPlugin(context.Context, *QueryPluginRequest) (*QueryPluginResponse, error)
	// RunAttack executes an attack and streams progress events.
	// The stream remains open until the attack completes or is stopped.
	RunAttack(*RunAttackRequest, grpc.ServerStreamingServer[AttackEvent]) error
	// Subscribe establishes an event stream for TUI real-time updates.
	// Streams mission events, agent events, finding events, etc.
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[Event]) error
	// StartComponent starts a component (agent, tool, or plugin) by kind and name.
	// The component must be installed in the local database.
	StartComponent(context.Context, *StartComponentRequest) (*StartComponentResponse, error)
	// StopComponent stops a running component (agent, tool, or plugin) by kind and name.
	// If force is true, sends SIGKILL immediately instead of graceful SIGTERM.
	StopComponent(context.Context, *StopComponentRequest) (*StopComponentResponse, error)
	// PauseMission pauses a running mission at the next clean checkpoint boundary.
	// If force is true, pauses immediately without waiting for a clean boundary.
	PauseMission(context.Context, *PauseMissionRequest) (*PauseMissionResponse, error)
	// ResumeMission resumes a paused mission from its last checkpoint.
	// Returns a stream of mission events as execution continues.
	ResumeMission(*ResumeMissionRequest, grpc.ServerStreamingServer[MissionEvent]) error
	// GetMissionHistory returns all runs for a mission name, showing the
	// complete history of mission executions with the same workflow name.
	GetMissionHistory(context.Context, *GetMissionHistoryRequest) (*GetMissionHistoryResponse, error)
	// GetMissionCheckpoints returns all checkpoints for a specific mission,
	// providing visibility into saved execution states for resume capability.
	GetMissionCheckpoints(context.Context, *GetMissionCheckpointsRequest) (*GetMissionCheckpointsResponse, error)
	// ExecuteTool executes a tool via the Tool Executor Service.
	// Routes tool execution through the centralized tool executor which handles
	// schema validation, timeout management, and execution tracking.
	ExecuteTool(context.Context, *ExecuteToolRequest) (*ExecuteToolResponse, error)
	// GetAvailableTools returns all available tools from the Tool Executor Service.
	// Provides detailed information about each tool including schemas, capabilities,
	// and execution metrics.
	GetAvailableTools(context.Context, *GetAvailableToolsRequest) (*GetAvailableToolsResponse, error)
	mustEmbedUnimplementedDaemonServiceServer()
}

// UnimplementedDaemonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDaemonServiceServer struct{}

func (UnimplementedDaemonServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedDaemonServiceServer) Ping(context.Context, *PingRequest) (*PingResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedDaemonServiceServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedDaemonServiceServer) RunMission(*RunMissionRequest, grpc.ServerStreamingServer[MissionEvent]) error {
	return status.Error(codes.Unimplemented, "method RunMission not implemented")
}
func (UnimplementedDaemonServiceServer) StopMission(context.Context, *StopMissionRequest) (*StopMissionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopMission not implemented")
}
func (UnimplementedDaemonServiceServer) ListMissions(context.Context, *ListMissionsRequest) (*ListMissionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListMissions not implemented")
}
func (UnimplementedDaemonServiceServer) ListAgents(context.Context, *ListAgentsRequest) (*ListAgentsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListAgents not implemented")
}
func (UnimplementedDaemonServiceServer) GetAgentStatus(context.Context, *GetAgentStatusRequest) (*AgentStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAgentStatus not implemented")
}
func (UnimplementedDaemonServiceServer) ListTools(context.Context, *ListToolsRequest) (*ListToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTools not implemented")
}
func (UnimplementedDaemonServiceServer) ListPlugins(context.Context, *ListPluginsRequest) (*ListPluginsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListPlugins not implemented")
}
func (UnimplementedDaemonServiceServer) QueryPlugin(context.Context, *QueryPluginRequest) (*QueryPluginResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method QueryPlugin not implemented")
}
func (UnimplementedDaemonServiceServer) RunAttack(*RunAttackRequest, grpc.ServerStreamingServer[AttackEvent]) error {
	return status.Error(codes.Unimplemented, "method RunAttack not implemented")
}
func (UnimplementedDaemonServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[Event]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedDaemonServiceServer) StartComponent(context.Context, *StartComponentRequest) (*StartComponentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartComponent not implemented")
}
func (UnimplementedDaemonServiceServer) StopComponent(context.Context, *StopComponentRequest) (*StopComponentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopComponent not implemented")
}
func (UnimplementedDaemonServiceServer) PauseMission(context.Context, *PauseMissionRequest) (*PauseMissionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method PauseMission not implemented")
}
func (UnimplementedDaemonServiceServer) ResumeMission(*ResumeMissionRequest, grpc.ServerStreamingServer[MissionEvent]) error {
	return status.Error(codes.Unimplemented, "method ResumeMission not implemented")
}
func (UnimplementedDaemonServiceServer) GetMissionHistory(context.Context, *GetMissionHistoryRequest) (*GetMissionHistoryResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMissionHistory not implemented")
}
func (UnimplementedDaemonServiceServer) GetMissionCheckpoints(context.Context, *GetMissionCheckpointsRequest) (*GetMissionCheckpointsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMissionCheckpoints not implemented")
}
func (UnimplementedDaemonServiceServer) ExecuteTool(context.Context, *ExecuteToolRequest) (*ExecuteToolResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ExecuteTool not implemented")
}
func (UnimplementedDaemonServiceServer) GetAvailableTools(context.Context, *GetAvailableToolsRequest) (*GetAvailableToolsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetAvailableTools not implemented")
}
func (UnimplementedDaemonServiceServer) mustEmbedUnimplementedDaemonServiceServer() {}
func (UnimplementedDaemonServiceServer) testEmbeddedByValue()                       {}

// UnsafeDaemonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonServiceServer will
// result in compilation errors.
type UnsafeDaemonServiceServer interface {
	mustEmbedUnimplementedDaemonServiceServer()
}

func RegisterDaemonServiceServer(s grpc.ServiceRegistrar, srv DaemonServiceServer) {
	// If the following call panics, it indicates UnimplementedDaemonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DaemonService_ServiceDesc, srv)
}

func _DaemonService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).Ping(ctx, req.(*PingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_RunMission_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunMissionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServiceServer).RunMission(m, &grpc.GenericServerStream[RunMissionRequest, MissionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_RunMissionServer = grpc.ServerStreamingServer[MissionEvent]

func _DaemonService_StopMission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopMissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).StopMission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_StopMission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).StopMission(ctx, req.(*StopMissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_ListMissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMissionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).ListMissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_ListMissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).ListMissions(ctx, req.(*ListMissionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_ListAgents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).ListAgents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_ListAgents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).ListAgents(ctx, req.(*ListAgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_GetAgentStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAgentStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).GetAgentStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_GetAgentStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).GetAgentStatus(ctx, req.(*GetAgentStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_ListTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).ListTools(ctx, req.(*ListToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_ListPlugins_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPluginsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).ListPlugins(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_ListPlugins_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).ListPlugins(ctx, req.(*ListPluginsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_QueryPlugin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPluginRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).QueryPlugin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_QueryPlugin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).QueryPlugin(ctx, req.(*QueryPluginRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_RunAttack_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunAttackRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServiceServer).RunAttack(m, &grpc.GenericServerStream[RunAttackRequest, AttackEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_RunAttackServer = grpc.ServerStreamingServer[AttackEvent]

func _DaemonService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, Event]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_SubscribeServer = grpc.ServerStreamingServer[Event]

func _DaemonService_StartComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).StartComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_StartComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).StartComponent(ctx, req.(*StartComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_StopComponent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopComponentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).StopComponent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_StopComponent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).StopComponent(ctx, req.(*StopComponentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_PauseMission_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PauseMissionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).PauseMission(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_PauseMission_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).PauseMission(ctx, req.(*PauseMissionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_ResumeMission_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ResumeMissionRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServiceServer).ResumeMission(m, &grpc.GenericServerStream[ResumeMissionRequest, MissionEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_ResumeMissionServer = grpc.ServerStreamingServer[MissionEvent]

func _DaemonService_GetMissionHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMissionHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).GetMissionHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_GetMissionHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).GetMissionHistory(ctx, req.(*GetMissionHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_GetMissionCheckpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMissionCheckpointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).GetMissionCheckpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_GetMissionCheckpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).GetMissionCheckpoints(ctx, req.(*GetMissionCheckpointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_ExecuteTool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteToolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).ExecuteTool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_ExecuteTool_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).ExecuteTool(ctx, req.(*ExecuteToolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_GetAvailableTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableToolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).GetAvailableTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_GetAvailableTools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).GetAvailableTools(ctx, req.(*GetAvailableToolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DaemonService_ServiceDesc is the grpc.ServiceDesc for DaemonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DaemonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "gibson.daemon.v1.DaemonService",
	HandlerType: (*DaemonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _DaemonService_Connect_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _DaemonService_Ping_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _DaemonService_Status_Handler,
		},
		{
			MethodName: "StopMission",
			Handler:    _DaemonService_StopMission_Handler,
		},
		{
			MethodName: "ListMissions",
			Handler:    _DaemonService_ListMissions_Handler,
		},
		{
			MethodName: "ListAgents",
			Handler:    _DaemonService_ListAgents_Handler,
		},
		{
			MethodName: "GetAgentStatus",
			Handler:    _DaemonService_GetAgentStatus_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _DaemonService_ListTools_Handler,
		},
		{
			MethodName: "ListPlugins",
			Handler:    _DaemonService_ListPlugins_Handler,
		},
		{
			MethodName: "QueryPlugin",
			Handler:    _DaemonService_QueryPlugin_Handler,
		},
		{
			MethodName: "StartComponent",
			Handler:    _DaemonService_StartComponent_Handler,
		},
		{
			MethodName: "StopComponent",
			Handler:    _DaemonService_StopComponent_Handler,
		},
		{
			MethodName: "PauseMission",
			Handler:    _DaemonService_PauseMission_Handler,
		},
		{
			MethodName: "GetMissionHistory",
			Handler:    _DaemonService_GetMissionHistory_Handler,
		},
		{
			MethodName: "GetMissionCheckpoints",
			Handler:    _DaemonService_GetMissionCheckpoints_Handler,
		},
		{
			MethodName: "ExecuteTool",
			Handler:    _DaemonService_ExecuteTool_Handler,
		},
		{
			MethodName: "GetAvailableTools",
			Handler:    _DaemonService_GetAvailableTools_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RunMission",
			Handler:       _DaemonService_RunMission_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunAttack",
			Handler:       _DaemonService_RunAttack_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _DaemonService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ResumeMission",
			Handler:       _DaemonService_ResumeMission_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon.proto",
}
