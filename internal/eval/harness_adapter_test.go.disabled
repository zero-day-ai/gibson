package eval

import (
	"context"
	"errors"
	"log/slog"
	"testing"
	"time"

	gibsonAgent "github.com/zero-day-ai/gibson/internal/agent"
	gibsonHarness "github.com/zero-day-ai/gibson/internal/harness"
	gibsonLLM "github.com/zero-day-ai/gibson/internal/llm"
	"github.com/zero-day-ai/sdk/agent"
	"github.com/zero-day-ai/sdk/graphrag"
	"github.com/zero-day-ai/sdk/llm"
	"github.com/zero-day-ai/sdk/types"
	"go.opentelemetry.io/otel/trace"
	"go.opentelemetry.io/otel/trace/noop"
)

// mockGibsonHarness is a mock implementation of Gibson's AgentHarness for testing.
type mockGibsonHarness struct {
	// LLM operations
	completeFunc          func(ctx context.Context, slot string, messages []gibsonLLM.Message, opts ...gibsonHarness.CompletionOption) (*gibsonLLM.CompletionResponse, error)
	completeWithToolsFunc func(ctx context.Context, slot string, messages []gibsonLLM.Message, tools []gibsonLLM.ToolDef, opts ...gibsonHarness.CompletionOption) (*gibsonLLM.CompletionResponse, error)
	streamFunc            func(ctx context.Context, slot string, messages []gibsonLLM.Message, opts ...gibsonHarness.CompletionOption) (<-chan gibsonLLM.StreamChunk, error)

	// Tool operations
	callToolFunc func(ctx context.Context, name string, input map[string]any) (map[string]any, error)
	listToolsFunc func() []gibsonHarness.ToolDescriptor

	// Plugin operations
	queryPluginFunc func(ctx context.Context, name string, method string, params map[string]any) (any, error)
	listPluginsFunc func() []gibsonHarness.PluginDescriptor

	// Agent operations
	delegateToAgentFunc func(ctx context.Context, name string, task gibsonAgent.Task) (gibsonAgent.Result, error)
	listAgentsFunc      func() []gibsonHarness.AgentDescriptor

	// Finding operations
	submitFindingFunc func(ctx context.Context, finding gibsonAgent.Finding) error
	getFindingsFunc   func(ctx context.Context, filter gibsonHarness.FindingFilter) ([]gibsonAgent.Finding, error)

	// Memory operations
	memoryFunc func() gibsonHarness.MemoryStore

	// Context operations
	missionFunc func() gibsonHarness.MissionContext
	targetFunc  func() gibsonHarness.TargetInfo

	// Observability
	tracerFunc     func() trace.Tracer
	loggerFunc     func() *slog.Logger
	tokenUsageFunc func() *gibsonLLM.TokenTracker

	// GraphRAG operations
	queryGraphRAGFunc          func(ctx context.Context, query graphrag.Query) ([]graphrag.Result, error)
	findSimilarAttacksFunc     func(ctx context.Context, content string, topK int) ([]graphrag.AttackPattern, error)
	findSimilarFindingsFunc    func(ctx context.Context, findingID string, topK int) ([]graphrag.FindingNode, error)
	getAttackChainsFunc        func(ctx context.Context, techniqueID string, maxDepth int) ([]graphrag.AttackChain, error)
	getRelatedFindingsFunc     func(ctx context.Context, findingID string) ([]graphrag.FindingNode, error)
	storeGraphNodeFunc         func(ctx context.Context, node graphrag.GraphNode) (string, error)
	createGraphRelationshipFunc func(ctx context.Context, rel graphrag.Relationship) error
	storeGraphBatchFunc        func(ctx context.Context, batch graphrag.Batch) ([]string, error)
	traverseGraphFunc          func(ctx context.Context, startNodeID string, opts graphrag.TraversalOptions) ([]graphrag.TraversalResult, error)
	graphRAGHealthFunc         func(ctx context.Context) types.HealthStatus
}

func (m *mockGibsonHarness) Complete(ctx context.Context, slot string, messages []gibsonLLM.Message, opts ...gibsonHarness.CompletionOption) (*gibsonLLM.CompletionResponse, error) {
	if m.completeFunc != nil {
		return m.completeFunc(ctx, slot, messages, opts...)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) CompleteWithTools(ctx context.Context, slot string, messages []gibsonLLM.Message, tools []gibsonLLM.ToolDef, opts ...gibsonHarness.CompletionOption) (*gibsonLLM.CompletionResponse, error) {
	if m.completeWithToolsFunc != nil {
		return m.completeWithToolsFunc(ctx, slot, messages, tools, opts...)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) Stream(ctx context.Context, slot string, messages []gibsonLLM.Message, opts ...gibsonHarness.CompletionOption) (<-chan gibsonLLM.StreamChunk, error) {
	if m.streamFunc != nil {
		return m.streamFunc(ctx, slot, messages, opts...)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) CallTool(ctx context.Context, name string, input map[string]any) (map[string]any, error) {
	if m.callToolFunc != nil {
		return m.callToolFunc(ctx, name, input)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) ListTools() []gibsonHarness.ToolDescriptor {
	if m.listToolsFunc != nil {
		return m.listToolsFunc()
	}
	return nil
}

func (m *mockGibsonHarness) QueryPlugin(ctx context.Context, name string, method string, params map[string]any) (any, error) {
	if m.queryPluginFunc != nil {
		return m.queryPluginFunc(ctx, name, method, params)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) ListPlugins() []gibsonHarness.PluginDescriptor {
	if m.listPluginsFunc != nil {
		return m.listPluginsFunc()
	}
	return nil
}

func (m *mockGibsonHarness) DelegateToAgent(ctx context.Context, name string, task gibsonAgent.Task) (gibsonAgent.Result, error) {
	if m.delegateToAgentFunc != nil {
		return m.delegateToAgentFunc(ctx, name, task)
	}
	return gibsonAgent.Result{}, errors.New("not implemented")
}

func (m *mockGibsonHarness) ListAgents() []gibsonHarness.AgentDescriptor {
	if m.listAgentsFunc != nil {
		return m.listAgentsFunc()
	}
	return nil
}

func (m *mockGibsonHarness) SubmitFinding(ctx context.Context, finding gibsonAgent.Finding) error {
	if m.submitFindingFunc != nil {
		return m.submitFindingFunc(ctx, finding)
	}
	return errors.New("not implemented")
}

func (m *mockGibsonHarness) GetFindings(ctx context.Context, filter gibsonHarness.FindingFilter) ([]gibsonAgent.Finding, error) {
	if m.getFindingsFunc != nil {
		return m.getFindingsFunc(ctx, filter)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) Memory() gibsonHarness.MemoryStore {
	if m.memoryFunc != nil {
		return m.memoryFunc()
	}
	return nil
}

func (m *mockGibsonHarness) Mission() gibsonHarness.MissionContext {
	if m.missionFunc != nil {
		return m.missionFunc()
	}
	return gibsonHarness.MissionContext{}
}

func (m *mockGibsonHarness) Target() gibsonHarness.TargetInfo {
	if m.targetFunc != nil {
		return m.targetFunc()
	}
	return gibsonHarness.TargetInfo{}
}

func (m *mockGibsonHarness) Tracer() trace.Tracer {
	if m.tracerFunc != nil {
		return m.tracerFunc()
	}
	return noop.NewTracerProvider().Tracer("mock")
}

func (m *mockGibsonHarness) Logger() *slog.Logger {
	if m.loggerFunc != nil {
		return m.loggerFunc()
	}
	return slog.Default()
}

func (m *mockGibsonHarness) TokenUsage() *gibsonLLM.TokenTracker {
	if m.tokenUsageFunc != nil {
		return m.tokenUsageFunc()
	}
	return nil
}

func (m *mockGibsonHarness) QueryGraphRAG(ctx context.Context, query graphrag.Query) ([]graphrag.Result, error) {
	if m.queryGraphRAGFunc != nil {
		return m.queryGraphRAGFunc(ctx, query)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) FindSimilarAttacks(ctx context.Context, content string, topK int) ([]graphrag.AttackPattern, error) {
	if m.findSimilarAttacksFunc != nil {
		return m.findSimilarAttacksFunc(ctx, content, topK)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) FindSimilarFindings(ctx context.Context, findingID string, topK int) ([]graphrag.FindingNode, error) {
	if m.findSimilarFindingsFunc != nil {
		return m.findSimilarFindingsFunc(ctx, findingID, topK)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) GetAttackChains(ctx context.Context, techniqueID string, maxDepth int) ([]graphrag.AttackChain, error) {
	if m.getAttackChainsFunc != nil {
		return m.getAttackChainsFunc(ctx, techniqueID, maxDepth)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) GetRelatedFindings(ctx context.Context, findingID string) ([]graphrag.FindingNode, error) {
	if m.getRelatedFindingsFunc != nil {
		return m.getRelatedFindingsFunc(ctx, findingID)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) StoreGraphNode(ctx context.Context, node graphrag.GraphNode) (string, error) {
	if m.storeGraphNodeFunc != nil {
		return m.storeGraphNodeFunc(ctx, node)
	}
	return "", errors.New("not implemented")
}

func (m *mockGibsonHarness) CreateGraphRelationship(ctx context.Context, rel graphrag.Relationship) error {
	if m.createGraphRelationshipFunc != nil {
		return m.createGraphRelationshipFunc(ctx, rel)
	}
	return errors.New("not implemented")
}

func (m *mockGibsonHarness) StoreGraphBatch(ctx context.Context, batch graphrag.Batch) ([]string, error) {
	if m.storeGraphBatchFunc != nil {
		return m.storeGraphBatchFunc(ctx, batch)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) TraverseGraph(ctx context.Context, startNodeID string, opts graphrag.TraversalOptions) ([]graphrag.TraversalResult, error) {
	if m.traverseGraphFunc != nil {
		return m.traverseGraphFunc(ctx, startNodeID, opts)
	}
	return nil, errors.New("not implemented")
}

func (m *mockGibsonHarness) GraphRAGHealth(ctx context.Context) types.HealthStatus {
	if m.graphRAGHealthFunc != nil {
		return m.graphRAGHealthFunc(ctx)
	}
	return types.HealthStatus{}
}

// Placeholder methods for interface compliance - not used in these tests
func (m *mockGibsonHarness) PlanContext() *gibsonHarness.PlanningContext { return nil }
func (m *mockGibsonHarness) GetStepBudget() int                          { return 0 }
func (m *mockGibsonHarness) SignalReplanRecommended(ctx context.Context, reason string) error {
	return nil
}
func (m *mockGibsonHarness) ReportStepHints(ctx context.Context, hints *gibsonHarness.StepHints) error {
	return nil
}
func (m *mockGibsonHarness) Metrics() gibsonHarness.MetricsRecorder { return nil }

// mockMemoryStore implements gibsonHarness.MemoryStore for testing.
type mockMemoryStore struct {
	data map[string]any
}

func newMockMemoryStore() *mockMemoryStore {
	return &mockMemoryStore{
		data: make(map[string]any),
	}
}

func (m *mockMemoryStore) Get(ctx context.Context, key string) (any, error) {
	val, ok := m.data[key]
	if !ok {
		return nil, errors.New("key not found")
	}
	return val, nil
}

func (m *mockMemoryStore) Set(ctx context.Context, key string, value any) error {
	m.data[key] = value
	return nil
}

func (m *mockMemoryStore) Delete(ctx context.Context, key string) error {
	delete(m.data, key)
	return nil
}

func (m *mockMemoryStore) List(ctx context.Context, prefix string) ([]string, error) {
	var keys []string
	for k := range m.data {
		if len(prefix) == 0 || k[:len(prefix)] == prefix {
			keys = append(keys, k)
		}
	}
	return keys, nil
}

// TestGibsonHarnessAdapter_Complete tests LLM completion delegation.
func TestGibsonHarnessAdapter_Complete(t *testing.T) {
	ctx := context.Background()

	mock := &mockGibsonHarness{
		completeFunc: func(ctx context.Context, slot string, messages []gibsonLLM.Message, opts ...gibsonHarness.CompletionOption) (*gibsonLLM.CompletionResponse, error) {
			if slot != "primary" {
				t.Errorf("expected slot 'primary', got %s", slot)
			}
			if len(messages) != 1 {
				t.Errorf("expected 1 message, got %d", len(messages))
			}
			return &gibsonLLM.CompletionResponse{
				Message: gibsonLLM.Message{
					Role:    "assistant",
					Content: "Hello!",
				},
				FinishReason: "stop",
				Usage: gibsonLLM.TokenUsage{
					PromptTokens:     10,
					CompletionTokens: 5,
					TotalTokens:      15,
				},
			}, nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	messages := []llm.Message{
		{Role: "user", Content: "Hi"},
	}

	resp, err := adapter.Complete(ctx, "primary", messages)
	if err != nil {
		t.Fatalf("Complete failed: %v", err)
	}

	if resp.Message.Content != "Hello!" {
		t.Errorf("expected content 'Hello!', got %s", resp.Message.Content)
	}
	if resp.Usage.TotalTokens != 15 {
		t.Errorf("expected 15 total tokens, got %d", resp.Usage.TotalTokens)
	}
}

// TestGibsonHarnessAdapter_CompleteWithTools tests tool-calling completion.
func TestGibsonHarnessAdapter_CompleteWithTools(t *testing.T) {
	ctx := context.Background()

	mock := &mockGibsonHarness{
		completeWithToolsFunc: func(ctx context.Context, slot string, messages []gibsonLLM.Message, tools []gibsonLLM.ToolDef, opts ...gibsonHarness.CompletionOption) (*gibsonLLM.CompletionResponse, error) {
			if len(tools) != 1 {
				t.Errorf("expected 1 tool, got %d", len(tools))
			}
			return &gibsonLLM.CompletionResponse{
				Message: gibsonLLM.Message{
					Role: "assistant",
					ToolCalls: []gibsonLLM.ToolCall{
						{
							ID:   "call_1",
							Type: "function",
							Function: gibsonLLM.FunctionCall{
								Name:      "get_weather",
								Arguments: `{"location":"NYC"}`,
							},
						},
					},
				},
				FinishReason: "tool_calls",
			}, nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	messages := []llm.Message{
		{Role: "user", Content: "What's the weather?"},
	}
	tools := []llm.ToolDef{
		{
			Type: "function",
			Function: llm.FunctionDef{
				Name:        "get_weather",
				Description: "Get weather",
			},
		},
	}

	resp, err := adapter.CompleteWithTools(ctx, "primary", messages, tools)
	if err != nil {
		t.Fatalf("CompleteWithTools failed: %v", err)
	}

	if len(resp.Message.ToolCalls) != 1 {
		t.Fatalf("expected 1 tool call, got %d", len(resp.Message.ToolCalls))
	}
	if resp.Message.ToolCalls[0].Function.Name != "get_weather" {
		t.Errorf("expected tool 'get_weather', got %s", resp.Message.ToolCalls[0].Function.Name)
	}
}

// TestGibsonHarnessAdapter_Stream tests streaming completion.
func TestGibsonHarnessAdapter_Stream(t *testing.T) {
	ctx := context.Background()

	mock := &mockGibsonHarness{
		streamFunc: func(ctx context.Context, slot string, messages []gibsonLLM.Message, opts ...gibsonHarness.CompletionOption) (<-chan gibsonLLM.StreamChunk, error) {
			ch := make(chan gibsonLLM.StreamChunk, 2)
			go func() {
				defer close(ch)
				ch <- gibsonLLM.StreamChunk{
					Delta: gibsonLLM.Message{Content: "Hello"},
				}
				ch <- gibsonLLM.StreamChunk{
					Delta:        gibsonLLM.Message{Content: " world"},
					FinishReason: "stop",
				}
			}()
			return ch, nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	messages := []llm.Message{
		{Role: "user", Content: "Hi"},
	}

	ch, err := adapter.Stream(ctx, "primary", messages)
	if err != nil {
		t.Fatalf("Stream failed: %v", err)
	}

	var content string
	for chunk := range ch {
		content += chunk.Delta.Content
	}

	if content != "Hello world" {
		t.Errorf("expected 'Hello world', got %s", content)
	}
}

// TestGibsonHarnessAdapter_CallTool tests tool execution delegation.
func TestGibsonHarnessAdapter_CallTool(t *testing.T) {
	ctx := context.Background()

	mock := &mockGibsonHarness{
		callToolFunc: func(ctx context.Context, name string, input map[string]any) (map[string]any, error) {
			if name != "test_tool" {
				t.Errorf("expected tool 'test_tool', got %s", name)
			}
			return map[string]any{"result": "success"}, nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	result, err := adapter.CallTool(ctx, "test_tool", map[string]any{"param": "value"})
	if err != nil {
		t.Fatalf("CallTool failed: %v", err)
	}

	if result["result"] != "success" {
		t.Errorf("expected result 'success', got %v", result["result"])
	}
}

// TestGibsonHarnessAdapter_Memory tests memory store delegation.
func TestGibsonHarnessAdapter_Memory(t *testing.T) {
	ctx := context.Background()

	mockMem := newMockMemoryStore()
	mock := &mockGibsonHarness{
		memoryFunc: func() gibsonHarness.MemoryStore {
			return mockMem
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)
	mem := adapter.Memory()

	// Test Set
	err := mem.Set(ctx, "test_key", "test_value")
	if err != nil {
		t.Fatalf("Set failed: %v", err)
	}

	// Test Get
	val, err := mem.Get(ctx, "test_key")
	if err != nil {
		t.Fatalf("Get failed: %v", err)
	}
	if val != "test_value" {
		t.Errorf("expected 'test_value', got %v", val)
	}

	// Test List
	keys, err := mem.List(ctx, "test")
	if err != nil {
		t.Fatalf("List failed: %v", err)
	}
	if len(keys) != 1 {
		t.Errorf("expected 1 key, got %d", len(keys))
	}

	// Test Delete
	err = mem.Delete(ctx, "test_key")
	if err != nil {
		t.Fatalf("Delete failed: %v", err)
	}

	_, err = mem.Get(ctx, "test_key")
	if err == nil {
		t.Error("expected error for deleted key")
	}
}

// TestGibsonHarnessAdapter_ContextAccess tests mission and target context.
func TestGibsonHarnessAdapter_ContextAccess(t *testing.T) {
	mock := &mockGibsonHarness{
		missionFunc: func() gibsonHarness.MissionContext {
			return gibsonHarness.MissionContext{
				ID:          "mission-123",
				Name:        "Test Mission",
				Description: "A test mission",
				Phase:       "reconnaissance",
				StartTime:   time.Now(),
			}
		},
		targetFunc: func() gibsonHarness.TargetInfo {
			return gibsonHarness.TargetInfo{
				URL:         "https://example.com",
				Type:        "web",
				Description: "Test target",
			}
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	mission := adapter.Mission()
	if mission.ID != "mission-123" {
		t.Errorf("expected mission ID 'mission-123', got %s", mission.ID)
	}
	if mission.Name != "Test Mission" {
		t.Errorf("expected mission name 'Test Mission', got %s", mission.Name)
	}

	target := adapter.Target()
	if target.URL != "https://example.com" {
		t.Errorf("expected URL 'https://example.com', got %s", target.URL)
	}
}

// TestGibsonHarnessAdapter_Observability tests tracer and logger delegation.
func TestGibsonHarnessAdapter_Observability(t *testing.T) {
	testLogger := slog.Default()
	testTracer := noop.NewTracerProvider().Tracer("test")

	mock := &mockGibsonHarness{
		loggerFunc: func() *slog.Logger {
			return testLogger
		},
		tracerFunc: func() trace.Tracer {
			return testTracer
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	logger := adapter.Logger()
	if logger != testLogger {
		t.Error("expected same logger instance")
	}

	tracer := adapter.Tracer()
	if tracer != testTracer {
		t.Error("expected same tracer instance")
	}
}

// TestGibsonHarnessAdapter_DelegateToAgent tests agent delegation.
func TestGibsonHarnessAdapter_DelegateToAgent(t *testing.T) {
	ctx := context.Background()

	mock := &mockGibsonHarness{
		delegateToAgentFunc: func(ctx context.Context, name string, task gibsonAgent.Task) (gibsonAgent.Result, error) {
			if name != "sub_agent" {
				t.Errorf("expected agent 'sub_agent', got %s", name)
			}
			return gibsonAgent.Result{
				Success: true,
				Output:  map[string]any{"status": "complete"},
			}, nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	task := agent.Task{
		ID:          "task-1",
		Name:        "test_task",
		Description: "Test task",
		Input:       map[string]any{"param": "value"},
	}

	result, err := adapter.DelegateToAgent(ctx, "sub_agent", task)
	if err != nil {
		t.Fatalf("DelegateToAgent failed: %v", err)
	}

	if !result.Success {
		t.Error("expected success=true")
	}
}

// TestGibsonHarnessAdapter_GraphRAG tests GraphRAG operations delegation.
func TestGibsonHarnessAdapter_GraphRAG(t *testing.T) {
	ctx := context.Background()

	mock := &mockGibsonHarness{
		queryGraphRAGFunc: func(ctx context.Context, query graphrag.Query) ([]graphrag.Result, error) {
			return []graphrag.Result{
				{NodeID: "node-1", Score: 0.95},
			}, nil
		},
		findSimilarAttacksFunc: func(ctx context.Context, content string, topK int) ([]graphrag.AttackPattern, error) {
			if topK != 5 {
				t.Errorf("expected topK=5, got %d", topK)
			}
			return []graphrag.AttackPattern{
				{TechniqueID: "T1059", Name: "Command Execution"},
			}, nil
		},
		storeGraphNodeFunc: func(ctx context.Context, node graphrag.GraphNode) (string, error) {
			return "node-123", nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	// Test QueryGraphRAG
	results, err := adapter.QueryGraphRAG(ctx, graphrag.Query{Text: "test query"})
	if err != nil {
		t.Fatalf("QueryGraphRAG failed: %v", err)
	}
	if len(results) != 1 {
		t.Errorf("expected 1 result, got %d", len(results))
	}

	// Test FindSimilarAttacks
	attacks, err := adapter.FindSimilarAttacks(ctx, "malicious payload", 5)
	if err != nil {
		t.Fatalf("FindSimilarAttacks failed: %v", err)
	}
	if len(attacks) != 1 {
		t.Errorf("expected 1 attack, got %d", len(attacks))
	}

	// Test StoreGraphNode
	nodeID, err := adapter.StoreGraphNode(ctx, graphrag.GraphNode{
		Type: "Finding",
		Properties: map[string]any{
			"title": "Test finding",
		},
	})
	if err != nil {
		t.Fatalf("StoreGraphNode failed: %v", err)
	}
	if nodeID != "node-123" {
		t.Errorf("expected nodeID 'node-123', got %s", nodeID)
	}
}

// TestGibsonHarnessAdapter_Findings tests finding submission and retrieval.
func TestGibsonHarnessAdapter_Findings(t *testing.T) {
	ctx := context.Background()

	var submittedFinding gibsonAgent.Finding

	mock := &mockGibsonHarness{
		submitFindingFunc: func(ctx context.Context, finding gibsonAgent.Finding) error {
			submittedFinding = finding
			return nil
		},
		getFindingsFunc: func(ctx context.Context, filter gibsonHarness.FindingFilter) ([]gibsonAgent.Finding, error) {
			return []gibsonAgent.Finding{
				{
					ID:       "finding-1",
					Severity: "high",
					Category: "injection",
				},
			}, nil
		},
	}

	adapter := NewGibsonHarnessAdapter(mock)

	// Test SubmitFinding
	finding := &findingAdapter{
		inner: gibsonAgent.Finding{
			ID:       "test-finding",
			Severity: "critical",
			Category: "xss",
		},
	}
	err := adapter.SubmitFinding(ctx, finding)
	if err != nil {
		t.Fatalf("SubmitFinding failed: %v", err)
	}
	if submittedFinding.ID != "test-finding" {
		t.Errorf("expected submitted finding ID 'test-finding', got %s", submittedFinding.ID)
	}

	// Test GetFindings
	findings, err := adapter.GetFindings(ctx, agent.FindingFilter{
		MinSeverity: "high",
	})
	if err != nil {
		t.Fatalf("GetFindings failed: %v", err)
	}
	if len(findings) != 1 {
		t.Errorf("expected 1 finding, got %d", len(findings))
	}
	if findings[0].Severity() != "high" {
		t.Errorf("expected severity 'high', got %s", findings[0].Severity())
	}
}
