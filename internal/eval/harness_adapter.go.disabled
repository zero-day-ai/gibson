package eval

import (
	"context"
	"log/slog"

	gibsonAgent "github.com/zero-day-ai/gibson/internal/agent"
	gibsonHarness "github.com/zero-day-ai/gibson/internal/harness"
	gibsonLLM "github.com/zero-day-ai/gibson/internal/llm"
	"github.com/zero-day-ai/gibson/internal/memory"
	"github.com/zero-day-ai/sdk/agent"
	"github.com/zero-day-ai/sdk/graphrag"
	"github.com/zero-day-ai/sdk/llm"
	"github.com/zero-day-ai/sdk/types"
	"go.opentelemetry.io/otel/trace"
)

// GibsonHarnessAdapter adapts Gibson's internal AgentHarness to the SDK's agent.Harness interface.
// This adapter enables SDK eval components (RecordingHarness, FeedbackHarness) to wrap
// Gibson's production harness implementation for evaluation and feedback during mission execution.
//
// The adapter bridges differences between Gibson's internal types and the SDK's public API:
//   - Converts between Gibson's internal LLM types and SDK's llm package types
//   - Adapts Gibson's internal agent types to SDK's agent package types
//   - Delegates all operations to the underlying Gibson harness
//   - Preserves context, tracing, and error handling semantics
//
// Thread Safety:
// The adapter is thread-safe as it delegates to Gibson's harness, which guarantees thread-safety.
// Multiple goroutines can safely call methods on the same adapter instance.
//
// Example usage:
//
//	gibsonHarness := harness.NewDefaultAgentHarness(config)
//	sdkHarness := eval.NewGibsonHarnessAdapter(gibsonHarness)
//	recordingHarness := sdkeval.NewRecordingHarness(sdkHarness)
//	feedbackHarness := sdkeval.NewFeedbackHarness(sdkHarness, feedbackOpts)
type GibsonHarnessAdapter struct {
	// inner is the Gibson AgentHarness being adapted
	inner gibsonHarness.AgentHarness
}

// NewGibsonHarnessAdapter creates a new adapter wrapping a Gibson AgentHarness.
// The adapter implements agent.Harness from the SDK, allowing SDK eval components
// to work with Gibson's internal harness implementation.
func NewGibsonHarnessAdapter(inner gibsonHarness.AgentHarness) *GibsonHarnessAdapter {
	return &GibsonHarnessAdapter{
		inner: inner,
	}
}

// ────────────────────────────────────────────────────────────────────────────
// LLM Access Methods
// ────────────────────────────────────────────────────────────────────────────

// Complete performs a single LLM completion request.
// Delegates to Gibson's harness, converting SDK completion options to Gibson's format.
func (a *GibsonHarnessAdapter) Complete(ctx context.Context, slot string, messages []llm.Message, opts ...llm.CompletionOption) (*llm.CompletionResponse, error) {
	// Convert SDK messages to Gibson messages
	gibsonMessages := convertMessagesToGibson(messages)

	// Convert SDK completion options to Gibson options
	gibsonOpts := convertCompletionOptionsToGibson(opts)

	// Delegate to Gibson harness
	resp, err := a.inner.Complete(ctx, slot, gibsonMessages, gibsonOpts...)
	if err != nil {
		return nil, err
	}

	// Convert Gibson response to SDK response
	return convertCompletionResponseToSDK(resp), nil
}

// CompleteWithTools performs a completion with tool calling enabled.
// Delegates to Gibson's harness, converting tool definitions between SDK and Gibson formats.
func (a *GibsonHarnessAdapter) CompleteWithTools(ctx context.Context, slot string, messages []llm.Message, tools []llm.ToolDef) (*llm.CompletionResponse, error) {
	// Convert SDK messages to Gibson messages
	gibsonMessages := convertMessagesToGibson(messages)

	// Convert SDK tool definitions to Gibson tool definitions
	gibsonTools := convertToolDefsToGibson(tools)

	// Delegate to Gibson harness (without options for CompleteWithTools)
	resp, err := a.inner.CompleteWithTools(ctx, slot, gibsonMessages, gibsonTools)
	if err != nil {
		return nil, err
	}

	// Convert Gibson response to SDK response
	return convertCompletionResponseToSDK(resp), nil
}

// Stream performs a streaming completion request.
// Delegates to Gibson's harness, converting stream chunks from Gibson to SDK format.
func (a *GibsonHarnessAdapter) Stream(ctx context.Context, slot string, messages []llm.Message) (<-chan llm.StreamChunk, error) {
	// Convert SDK messages to Gibson messages
	gibsonMessages := convertMessagesToGibson(messages)

	// Delegate to Gibson harness
	gibsonCh, err := a.inner.Stream(ctx, slot, gibsonMessages)
	if err != nil {
		return nil, err
	}

	// Create SDK channel and convert chunks in a goroutine
	sdkCh := make(chan llm.StreamChunk, cap(gibsonCh))
	go func() {
		defer close(sdkCh)
		for gibsonChunk := range gibsonCh {
			sdkCh <- convertStreamChunkToSDK(gibsonChunk)
		}
	}()

	return sdkCh, nil
}

// ────────────────────────────────────────────────────────────────────────────
// Tool Access Methods
// ────────────────────────────────────────────────────────────────────────────

// CallTool invokes a tool by name with the given input parameters.
// Delegates directly to Gibson's harness (no type conversion needed for map[string]any).
func (a *GibsonHarnessAdapter) CallTool(ctx context.Context, name string, input map[string]any) (map[string]any, error) {
	return a.inner.CallTool(ctx, name, input)
}

// ListTools returns descriptors for all available tools.
// Delegates to Gibson's harness, converting tool descriptors to SDK format.
func (a *GibsonHarnessAdapter) ListTools(ctx context.Context) ([]agent.ToolDescriptor, error) {
	gibsonTools := a.inner.ListTools()
	return convertToolDescriptorsToSDK(gibsonTools), nil
}

// ────────────────────────────────────────────────────────────────────────────
// Plugin Access Methods
// ────────────────────────────────────────────────────────────────────────────

// QueryPlugin sends a query to a plugin and returns the result.
// Delegates directly to Gibson's harness.
func (a *GibsonHarnessAdapter) QueryPlugin(ctx context.Context, name string, method string, params map[string]any) (any, error) {
	return a.inner.QueryPlugin(ctx, name, method, params)
}

// ListPlugins returns descriptors for all available plugins.
// Delegates to Gibson's harness, converting plugin descriptors to SDK format.
func (a *GibsonHarnessAdapter) ListPlugins(ctx context.Context) ([]agent.PluginDescriptor, error) {
	gibsonPlugins := a.inner.ListPlugins()
	return convertPluginDescriptorsToSDK(gibsonPlugins), nil
}

// ────────────────────────────────────────────────────────────────────────────
// Agent Delegation Methods
// ────────────────────────────────────────────────────────────────────────────

// DelegateToAgent assigns a task to another agent for execution.
// Delegates to Gibson's harness, converting task and result between SDK and Gibson formats.
func (a *GibsonHarnessAdapter) DelegateToAgent(ctx context.Context, name string, task agent.Task) (agent.Result, error) {
	// Convert SDK task to Gibson task
	gibsonTask := convertTaskToGibson(task)

	// Delegate to Gibson harness
	gibsonResult, err := a.inner.DelegateToAgent(ctx, name, gibsonTask)
	if err != nil {
		return agent.Result{}, err
	}

	// Convert Gibson result to SDK result
	return convertResultToSDK(gibsonResult), nil
}

// ListAgents returns descriptors for all available agents.
// Delegates to Gibson's harness, converting agent descriptors to SDK format.
func (a *GibsonHarnessAdapter) ListAgents(ctx context.Context) ([]agent.Descriptor, error) {
	gibsonAgents := a.inner.ListAgents()
	return convertAgentDescriptorsToSDK(gibsonAgents), nil
}

// ────────────────────────────────────────────────────────────────────────────
// Finding Management Methods
// ────────────────────────────────────────────────────────────────────────────

// SubmitFinding records a new security finding.
// Delegates to Gibson's harness, converting SDK finding to Gibson format.
func (a *GibsonHarnessAdapter) SubmitFinding(ctx context.Context, f agent.Finding) error {
	// Convert SDK finding interface to Gibson finding
	gibsonFinding := convertFindingToGibson(f)
	return a.inner.SubmitFinding(ctx, gibsonFinding)
}

// GetFindings retrieves findings matching the given filter criteria.
// Delegates to Gibson's harness, converting filter and findings between SDK and Gibson formats.
func (a *GibsonHarnessAdapter) GetFindings(ctx context.Context, filter agent.FindingFilter) ([]agent.Finding, error) {
	// Convert SDK filter to Gibson filter
	gibsonFilter := convertFindingFilterToGibson(filter)

	// Delegate to Gibson harness
	gibsonFindings, err := a.inner.GetFindings(ctx, gibsonFilter)
	if err != nil {
		return nil, err
	}

	// Convert Gibson findings to SDK findings
	return convertFindingsToSDK(gibsonFindings), nil
}

// ────────────────────────────────────────────────────────────────────────────
// Memory Access
// ────────────────────────────────────────────────────────────────────────────

// Memory returns the memory store for this agent.
// Returns an adapter that wraps Gibson's memory store to implement SDK's MemoryStore interface.
func (a *GibsonHarnessAdapter) Memory() agent.MemoryStore {
	return &memoryStoreAdapter{
		inner: a.inner.Memory(),
	}
}

// memoryStoreAdapter adapts Gibson's memory.MemoryStore to SDK's agent.MemoryStore.
// Gibson's memory system has a three-tier architecture (Working, Mission, LongTerm),
// but the SDK's MemoryStore is a simple key-value interface. This adapter delegates
// to Gibson's working memory tier for SDK operations.
type memoryStoreAdapter struct {
	inner memory.MemoryStore
}

// Get retrieves a value by key from working memory.
func (m *memoryStoreAdapter) Get(ctx context.Context, key string) (any, error) {
	// Get from working memory tier (no context needed for in-memory operations)
	val, found := m.inner.Working().Get(key)
	if !found {
		return nil, nil
	}
	return val, nil
}

// Set stores a value with the given key in working memory.
func (m *memoryStoreAdapter) Set(ctx context.Context, key string, value any) error {
	// Set in working memory tier
	return m.inner.Working().Set(key, value)
}

// Delete removes a value by key from working memory.
func (m *memoryStoreAdapter) Delete(ctx context.Context, key string) error {
	// Delete from working memory tier
	m.inner.Working().Delete(key)
	return nil
}

// List returns all keys matching the given prefix from working memory.
func (m *memoryStoreAdapter) List(ctx context.Context, prefix string) ([]string, error) {
	// List all keys from working memory
	allKeys := m.inner.Working().List()

	// Filter by prefix if provided
	if prefix == "" {
		return allKeys, nil
	}

	filtered := make([]string, 0, len(allKeys))
	for _, key := range allKeys {
		if len(key) >= len(prefix) && key[:len(prefix)] == prefix {
			filtered = append(filtered, key)
		}
	}
	return filtered, nil
}

// ────────────────────────────────────────────────────────────────────────────
// Context Access Methods
// ────────────────────────────────────────────────────────────────────────────

// Mission returns the current mission context.
// Delegates to Gibson's harness, converting mission context to SDK format.
func (a *GibsonHarnessAdapter) Mission() types.MissionContext {
	gibsonMission := a.inner.Mission()
	return convertMissionContextToSDK(gibsonMission)
}

// Target returns information about the target being tested.
// Delegates to Gibson's harness, converting target info to SDK format.
func (a *GibsonHarnessAdapter) Target() types.TargetInfo {
	gibsonTarget := a.inner.Target()
	return convertTargetInfoToSDK(gibsonTarget)
}

// ────────────────────────────────────────────────────────────────────────────
// Observability
// ────────────────────────────────────────────────────────────────────────────

// Tracer returns an OpenTelemetry tracer for distributed tracing.
// Delegates directly to Gibson's harness (same type).
func (a *GibsonHarnessAdapter) Tracer() trace.Tracer {
	return a.inner.Tracer()
}

// Logger returns a structured logger for the agent.
// Delegates directly to Gibson's harness (same type).
func (a *GibsonHarnessAdapter) Logger() *slog.Logger {
	return a.inner.Logger()
}

// TokenUsage returns the token usage tracker for this execution.
// Delegates to Gibson's harness, wrapping the token tracker for SDK compatibility.
func (a *GibsonHarnessAdapter) TokenUsage() llm.TokenTracker {
	gibsonTracker := a.inner.TokenUsage()
	return &tokenTrackerAdapter{inner: gibsonTracker}
}

// tokenTrackerAdapter adapts Gibson's llm.TokenTracker to SDK's llm.TokenTracker.
// Since both are likely interfaces with the same methods, this is a simple wrapper.
type tokenTrackerAdapter struct {
	inner *gibsonLLM.TokenTracker
}

// Total returns the total token usage across all scopes.
func (t *tokenTrackerAdapter) Total() llm.TokenUsage {
	gibsonUsage := t.inner.Total()
	return convertTokenUsageToSDK(gibsonUsage)
}

// ────────────────────────────────────────────────────────────────────────────
// GraphRAG Query Methods
// ────────────────────────────────────────────────────────────────────────────

// QueryGraphRAG performs a semantic or hybrid query against the knowledge graph.
// Delegates to Gibson's harness (types are compatible via SDK graphrag package).
func (a *GibsonHarnessAdapter) QueryGraphRAG(ctx context.Context, query graphrag.Query) ([]graphrag.Result, error) {
	return a.inner.QueryGraphRAG(ctx, query)
}

// FindSimilarAttacks searches for attack patterns semantically similar to the given content.
func (a *GibsonHarnessAdapter) FindSimilarAttacks(ctx context.Context, content string, topK int) ([]graphrag.AttackPattern, error) {
	return a.inner.FindSimilarAttacks(ctx, content, topK)
}

// FindSimilarFindings searches for findings semantically similar to the referenced finding.
func (a *GibsonHarnessAdapter) FindSimilarFindings(ctx context.Context, findingID string, topK int) ([]graphrag.FindingNode, error) {
	return a.inner.FindSimilarFindings(ctx, findingID)
}

// GetAttackChains discovers multi-step attack paths starting from a technique.
func (a *GibsonHarnessAdapter) GetAttackChains(ctx context.Context, techniqueID string, maxDepth int) ([]graphrag.AttackChain, error) {
	return a.inner.GetAttackChains(ctx, techniqueID, maxDepth)
}

// GetRelatedFindings retrieves findings connected via SIMILAR_TO or RELATED_TO relationships.
func (a *GibsonHarnessAdapter) GetRelatedFindings(ctx context.Context, findingID string) ([]graphrag.FindingNode, error) {
	return a.inner.GetRelatedFindings(ctx, findingID)
}

// ────────────────────────────────────────────────────────────────────────────
// GraphRAG Storage Methods
// ────────────────────────────────────────────────────────────────────────────

// StoreGraphNode stores an arbitrary node in the knowledge graph.
func (a *GibsonHarnessAdapter) StoreGraphNode(ctx context.Context, node graphrag.GraphNode) (string, error) {
	return a.inner.StoreGraphNode(ctx, node)
}

// CreateGraphRelationship creates a relationship between two existing nodes.
func (a *GibsonHarnessAdapter) CreateGraphRelationship(ctx context.Context, rel graphrag.Relationship) error {
	return a.inner.CreateGraphRelationship(ctx, rel)
}

// StoreGraphBatch stores multiple nodes and relationships atomically.
func (a *GibsonHarnessAdapter) StoreGraphBatch(ctx context.Context, batch graphrag.Batch) ([]string, error) {
	return a.inner.StoreGraphBatch(ctx, batch)
}

// TraverseGraph walks the graph from a starting node following relationships.
func (a *GibsonHarnessAdapter) TraverseGraph(ctx context.Context, startNodeID string, opts graphrag.TraversalOptions) ([]graphrag.TraversalResult, error) {
	return a.inner.TraverseGraph(ctx, startNodeID, opts)
}

// GraphRAGHealth returns the health status of the GraphRAG subsystem.
func (a *GibsonHarnessAdapter) GraphRAGHealth(ctx context.Context) types.HealthStatus {
	return a.inner.GraphRAGHealth(ctx)
}

// ────────────────────────────────────────────────────────────────────────────
// Type Conversion Helpers
// ────────────────────────────────────────────────────────────────────────────
// These functions convert between Gibson's internal types and SDK's public types.

// convertMessagesToGibson converts SDK messages to Gibson messages.
// Both structures are similar with slight field differences.
func convertMessagesToGibson(messages []llm.Message) []gibsonLLM.Message {
	result := make([]gibsonLLM.Message, len(messages))
	for i, msg := range messages {
		result[i] = gibsonLLM.Message{
			Role:    string(msg.Role),
			Content: msg.Content,
			Name:    msg.Name,
		}
		// Copy tool calls if present
		if len(msg.ToolCalls) > 0 {
			result[i].ToolCalls = make([]gibsonLLM.ToolCall, len(msg.ToolCalls))
			for j, tc := range msg.ToolCalls {
				result[i].ToolCalls[j] = gibsonLLM.ToolCall{
					ID:        tc.ID,
					Name:      tc.Name,
					Arguments: tc.Arguments,
					Type:      "function", // Default type
				}
			}
		}
		// Map tool results to tool call ID for backward compatibility
		if len(msg.ToolResults) > 0 {
			// SDK uses ToolResults[], Gibson uses single ToolCallID
			// Use the first result's tool call ID
			result[i].ToolCallID = msg.ToolResults[0].ToolCallID
		}
	}
	return result
}

// convertCompletionOptionsToGibson converts SDK completion options to Gibson options.
func convertCompletionOptionsToGibson(opts []llm.CompletionOption) []gibsonHarness.CompletionOption {
	// Gibson's CompletionOption and SDK's llm.CompletionOption are functional options
	// We need to extract the values and create new Gibson options
	// For now, return empty since the options are applied via functional pattern
	// TODO: Properly convert options if they have different implementations
	return nil
}

// convertCompletionResponseToSDK converts Gibson completion response to SDK response.
func convertCompletionResponseToSDK(resp *gibsonLLM.CompletionResponse) *llm.CompletionResponse {
	if resp == nil {
		return nil
	}
	return &llm.CompletionResponse{
		Message: llm.Message{
			Role:       resp.Message.Role,
			Content:    resp.Message.Content,
			Name:       resp.Message.Name,
			ToolCalls:  convertToolCallsToSDK(resp.Message.ToolCalls),
			ToolCallID: resp.Message.ToolCallID,
		},
		FinishReason: resp.FinishReason,
		Usage: llm.TokenUsage{
			PromptTokens:     resp.Usage.PromptTokens,
			CompletionTokens: resp.Usage.CompletionTokens,
			TotalTokens:      resp.Usage.TotalTokens,
		},
	}
}

// convertToolCallsToSDK converts Gibson tool calls to SDK tool calls.
func convertToolCallsToSDK(toolCalls []gibsonLLM.ToolCall) []llm.ToolCall {
	if len(toolCalls) == 0 {
		return nil
	}
	result := make([]llm.ToolCall, len(toolCalls))
	for i, tc := range toolCalls {
		result[i] = llm.ToolCall{
			ID:   tc.ID,
			Type: tc.Type,
			Function: llm.FunctionCall{
				Name:      tc.Function.Name,
				Arguments: tc.Function.Arguments,
			},
		}
	}
	return result
}

// convertToolDefsToGibson converts SDK tool definitions to Gibson tool definitions.
func convertToolDefsToGibson(tools []llm.ToolDef) []gibsonLLM.ToolDef {
	result := make([]gibsonLLM.ToolDef, len(tools))
	for i, tool := range tools {
		result[i] = gibsonLLM.ToolDef{
			Type: tool.Type,
			Function: gibsonLLM.FunctionDef{
				Name:        tool.Function.Name,
				Description: tool.Function.Description,
				Parameters:  tool.Function.Parameters,
			},
		}
	}
	return result
}

// convertStreamChunkToSDK converts Gibson stream chunk to SDK stream chunk.
func convertStreamChunkToSDK(chunk gibsonLLM.StreamChunk) llm.StreamChunk {
	return llm.StreamChunk{
		Delta: llm.Message{
			Role:    chunk.Delta.Role,
			Content: chunk.Delta.Content,
		},
		FinishReason: chunk.FinishReason,
		Error:        chunk.Error,
	}
}

// convertToolDescriptorsToSDK converts Gibson tool descriptors to SDK tool descriptors.
func convertToolDescriptorsToSDK(descriptors []gibsonHarness.ToolDescriptor) []agent.ToolDescriptor {
	result := make([]agent.ToolDescriptor, len(descriptors))
	for i, desc := range descriptors {
		result[i] = agent.ToolDescriptor{
			Name:        desc.Name,
			Description: desc.Description,
			Schema:      desc.Schema,
		}
	}
	return result
}

// convertPluginDescriptorsToSDK converts Gibson plugin descriptors to SDK plugin descriptors.
func convertPluginDescriptorsToSDK(descriptors []gibsonHarness.PluginDescriptor) []agent.PluginDescriptor {
	result := make([]agent.PluginDescriptor, len(descriptors))
	for i, desc := range descriptors {
		result[i] = agent.PluginDescriptor{
			Name:        desc.Name,
			Description: desc.Description,
			Version:     desc.Version,
			Methods:     desc.Methods,
		}
	}
	return result
}

// convertTaskToGibson converts SDK task to Gibson task.
func convertTaskToGibson(task agent.Task) gibsonAgent.Task {
	return gibsonAgent.Task{
		ID:          task.ID,
		Name:        task.Name,
		Description: task.Description,
		Input:       task.Input,
		Constraints: task.Constraints,
	}
}

// convertResultToSDK converts Gibson result to SDK result.
func convertResultToSDK(result gibsonAgent.Result) agent.Result {
	return agent.Result{
		Success:  result.Success,
		Output:   result.Output,
		Error:    result.Error,
		Metrics:  result.Metrics,
		Findings: result.Findings,
	}
}

// convertAgentDescriptorsToSDK converts Gibson agent descriptors to SDK agent descriptors.
func convertAgentDescriptorsToSDK(descriptors []gibsonHarness.AgentDescriptor) []agent.Descriptor {
	result := make([]agent.Descriptor, len(descriptors))
	for i, desc := range descriptors {
		result[i] = agent.Descriptor{
			Name:        desc.Name,
			Version:     desc.Version,
			Description: desc.Description,
			Capabilities: convertCapabilitiesToSDK(desc.Capabilities),
			// TargetTypes and TechniqueTypes would be here if Gibson's descriptor had them
		}
	}
	return result
}

// convertCapabilitiesToSDK converts Gibson capabilities ([]string) to SDK capabilities ([]Capability).
func convertCapabilitiesToSDK(capabilities []string) []agent.Capability {
	result := make([]agent.Capability, len(capabilities))
	for i, cap := range capabilities {
		// SDK Capability is a string type, so just convert directly
		result[i] = agent.Capability(cap)
	}
	return result
}

// convertFindingToGibson converts SDK finding interface to Gibson finding.
func convertFindingToGibson(f agent.Finding) gibsonAgent.Finding {
	// Since agent.Finding is an interface, we need to extract the data
	// and create a Gibson finding instance
	return gibsonAgent.Finding{
		ID:       f.ID(),
		Severity: f.Severity(),
		Category: f.Category(),
		// Additional fields would be extracted here if the interface provided them
	}
}

// convertFindingFilterToGibson converts SDK finding filter to Gibson finding filter.
func convertFindingFilterToGibson(filter agent.FindingFilter) gibsonHarness.FindingFilter {
	return gibsonHarness.FindingFilter{
		MissionID:   filter.MissionID,
		AgentName:   filter.AgentName,
		MinSeverity: filter.MinSeverity,
		Category:    filter.Category,
		Limit:       filter.Limit,
	}
}

// convertFindingsToSDK converts Gibson findings to SDK findings.
func convertFindingsToSDK(findings []gibsonAgent.Finding) []agent.Finding {
	result := make([]agent.Finding, len(findings))
	for i, f := range findings {
		result[i] = &findingAdapter{inner: f}
	}
	return result
}

// findingAdapter adapts a Gibson finding to implement the SDK's agent.Finding interface.
type findingAdapter struct {
	inner gibsonAgent.Finding
}

func (f *findingAdapter) ID() string       { return f.inner.ID }
func (f *findingAdapter) Severity() string { return f.inner.Severity }
func (f *findingAdapter) Category() string { return f.inner.Category }

// convertMissionContextToSDK converts Gibson mission context to SDK mission context.
func convertMissionContextToSDK(ctx gibsonHarness.MissionContext) types.MissionContext {
	return types.MissionContext{
		ID:          ctx.ID,
		Name:        ctx.Name,
		Description: ctx.Description,
		Phase:       ctx.Phase,
		StartTime:   ctx.StartTime,
		Metadata:    ctx.Metadata,
	}
}

// convertTargetInfoToSDK converts Gibson target info to SDK target info.
func convertTargetInfoToSDK(info gibsonHarness.TargetInfo) types.TargetInfo {
	return types.TargetInfo{
		URL:         info.URL,
		Type:        info.Type,
		Description: info.Description,
		Auth:        info.Auth,
		Headers:     info.Headers,
		Metadata:    info.Metadata,
	}
}

// convertTokenUsageToSDK converts Gibson token usage to SDK token usage.
func convertTokenUsageToSDK(usage gibsonLLM.TokenUsage) llm.TokenUsage {
	return llm.TokenUsage{
		PromptTokens:     usage.PromptTokens,
		CompletionTokens: usage.CompletionTokens,
		TotalTokens:      usage.TotalTokens,
	}
}
