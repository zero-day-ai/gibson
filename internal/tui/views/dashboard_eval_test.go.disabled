package views

import (
	"context"
	"testing"
	"time"

	"github.com/zero-day-ai/gibson/internal/eval"
	"github.com/zero-day-ai/gibson/internal/tui/components"
	"github.com/zero-day-ai/gibson/internal/types"
	sdkeval "github.com/zero-day-ai/sdk/eval"
)

// TestDashboardEvalIntegration tests the integration of the eval panel with the dashboard.
func TestDashboardEvalIntegration(t *testing.T) {
	ctx := context.Background()

	// Create dashboard view
	dashboard := NewDashboardView(ctx, nil, nil, nil, nil)

	// Initially eval should be disabled
	if dashboard.evalEnabled {
		t.Error("Dashboard should start with eval disabled")
	}

	if dashboard.evalPanel == nil {
		t.Fatal("Eval panel should be initialized")
	}

	if dashboard.evalPanel.IsVisible() {
		t.Error("Eval panel should not be visible initially")
	}

	// Enable eval
	dashboard.EnableEval(true)

	if !dashboard.evalEnabled {
		t.Error("EnableEval(true) should enable eval")
	}

	if !dashboard.evalPanel.IsVisible() {
		t.Error("Eval panel should be visible when eval is enabled")
	}

	// Test eval summary message handling
	summary := &eval.EvalSummary{
		MissionID:    types.NewID(),
		OverallScore: 0.85,
		ScorerScores: map[string]float64{
			"tool_correctness":       0.9,
			"trajectory_efficiency": 0.8,
		},
		TotalSteps:    10,
		TotalAlerts:   2,
		WarningCount:  1,
		CriticalCount: 1,
		Duration:      5 * time.Minute,
		TokensUsed:    1500,
	}

	msg := components.EvalSummaryMsg{Summary: summary}
	_, _ = dashboard.Update(msg)

	// Test alert message handling
	alert := sdkeval.Alert{
		Level:     sdkeval.AlertWarning,
		Scorer:    "tool_correctness",
		Score:     0.6,
		Threshold: 0.7,
		Message:   "Tool usage below threshold",
		Action:    sdkeval.ActionAdjust,
	}

	alertMsg := components.EvalAlertMsg{Alert: alert}
	_, _ = dashboard.Update(alertMsg)

	// Disable eval
	dashboard.EnableEval(false)

	if dashboard.evalEnabled {
		t.Error("EnableEval(false) should disable eval")
	}

	if dashboard.evalPanel.IsVisible() {
		t.Error("Eval panel should not be visible when eval is disabled")
	}
}

// TestDashboardViewWithEval tests that the View() method works with eval enabled.
func TestDashboardViewWithEval(t *testing.T) {
	ctx := context.Background()
	dashboard := NewDashboardView(ctx, nil, nil, nil, nil)

	// Set reasonable dimensions
	dashboard.SetSize(120, 40)

	// Test view without eval
	view1 := dashboard.View()
	if view1 == "" {
		t.Error("View should not be empty")
	}

	// Enable eval and test view
	dashboard.EnableEval(true)
	view2 := dashboard.View()
	if view2 == "" {
		t.Error("View should not be empty with eval enabled")
	}

	// Views should be different (eval layout vs standard layout)
	// This is a basic check - in a more sophisticated test we'd verify the layout structure
	if len(view2) == 0 {
		t.Error("View with eval should have content")
	}
}

// TestDashboardPanelSizing tests that panel sizes are correctly calculated.
func TestDashboardPanelSizing(t *testing.T) {
	ctx := context.Background()
	dashboard := NewDashboardView(ctx, nil, nil, nil, nil)

	// Set test dimensions
	testWidth := 120
	testHeight := 40
	dashboard.SetSize(testWidth, testHeight)

	// Without eval: 2x2 grid, each panel is 1/2 width and 1/2 height
	if dashboard.evalEnabled {
		t.Error("Eval should start disabled")
	}

	// Enable eval
	dashboard.EnableEval(true)

	// With eval: left 2x2 grid is 2/3 width, eval panel is 1/3 width
	// This is verified by the updatePanelSizes logic
	// We can't directly check panel sizes without exposing them, but we can verify no panic
	dashboard.updatePanelSizes()
}
