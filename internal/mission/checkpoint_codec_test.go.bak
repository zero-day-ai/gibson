package mission

import (
	"encoding/json"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/zero-day-ai/gibson/internal/types"
)

func TestSerializeWorkflowState(t *testing.T) {
	// Create test state map (as used by checkpoint_codec.go)
	stateMap := map[string]any{
		"workflow_id": types.NewID().String(),
		"status":      "running",
		"node_states": map[string]map[string]any{
			"node1": {
				"status": "completed",
			},
			"node2": {
				"status": "pending",
			},
		},
		"started_at": time.Now().Format(time.RFC3339),
	}

	// Serialize
	data, err := SerializeWorkflowState(stateMap)
	require.NoError(t, err)
	assert.NotEmpty(t, data)

	// Verify it's valid JSON
	var decoded map[string]any
	err = json.Unmarshal(data, &decoded)
	require.NoError(t, err)
	assert.Contains(t, decoded, "version")
	assert.Contains(t, decoded, "data")
}

func TestSerializeDeserializeWorkflowState_RoundTrip(t *testing.T) {
	// Create complex state map with nested structures
	workflowID := types.NewID()
	stateMap := map[string]any{
		"workflow_id": workflowID.String(),
		"status":      "running",
		"started_at":  time.Now().Format(time.RFC3339),
		"execution_order": []string{"node1", "node2", "node3"},
		"node_states": map[string]any{
			"node1": map[string]any{
				"status":       "completed",
				"retry_count":  0,
				"started_at":   time.Now().Add(-1 * time.Minute).Format(time.RFC3339),
				"completed_at": time.Now().Add(-30 * time.Second).Format(time.RFC3339),
			},
			"node2": map[string]any{
				"status":      "running",
				"retry_count": 0,
				"started_at":  time.Now().Add(-20 * time.Second).Format(time.RFC3339),
			},
			"node3": map[string]any{
				"status":      "pending",
				"retry_count": 0,
			},
		},
	}

	// Serialize
	data, err := SerializeWorkflowState(stateMap)
	require.NoError(t, err)

	// Deserialize
	restored, err := DeserializeWorkflowState(data)
	require.NoError(t, err)
	require.NotNil(t, restored)

	// Verify workflow ID
	assert.Equal(t, workflowID.String(), restored["workflow_id"])

	// Verify status
	assert.Equal(t, "running", restored["status"])

	// Verify node states exist
	nodeStates, ok := restored["node_states"].(map[string]any)
	require.True(t, ok)
	assert.Len(t, nodeStates, 3)

	// Verify specific node data
	node1, ok := nodeStates["node1"].(map[string]any)
	require.True(t, ok)
	assert.Equal(t, "completed", node1["status"])

	node2, ok := nodeStates["node2"].(map[string]any)
	require.True(t, ok)
	assert.Equal(t, "running", node2["status"])

	node3, ok := nodeStates["node3"].(map[string]any)
	require.True(t, ok)
	assert.Equal(t, "pending", node3["status"])

	// Verify execution order
	execOrder, ok := restored["execution_order"].([]any)
	require.True(t, ok)
	assert.Len(t, execOrder, 3)
}

func TestDeserializeWorkflowState_InvalidJSON(t *testing.T) {
	// Test with invalid JSON
	_, err := DeserializeWorkflowState([]byte("invalid json"))
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "deserialize workflow state")
}

func TestDeserializeWorkflowState_EmptyData(t *testing.T) {
	// Test with empty data
	_, err := DeserializeWorkflowState([]byte{})
	assert.Error(t, err)
}

func TestDeserializeWorkflowState_MissingVersion(t *testing.T) {
	// Create a serialized state without version field
	data := []byte(`{
		"workflow_id": "test-id",
		"status": "running",
		"node_states": {},
		"results": {}
	}`)

	// Should still deserialize (version defaults to 1)
	state, err := DeserializeWorkflowState(data)
	require.NoError(t, err)
	assert.NotNil(t, state)
}

func TestComputeChecksum(t *testing.T) {
	data := []byte("test data for checksum")

	// Compute checksum
	checksum := ComputeChecksum(data)
	assert.NotEmpty(t, checksum)
	assert.Len(t, checksum, 64) // SHA256 produces 64 hex characters

	// Same data should produce same checksum
	checksum2 := ComputeChecksum(data)
	assert.Equal(t, checksum, checksum2)

	// Different data should produce different checksum
	checksum3 := ComputeChecksum([]byte("different data"))
	assert.NotEqual(t, checksum, checksum3)
}

func TestComputeChecksum_Consistency(t *testing.T) {
	// Create test state map
	stateMap := map[string]any{
		"workflow_id": types.NewID().String(),
		"status":      "running",
		"node_states": map[string]any{
			"node1": map[string]any{
				"status":       "completed",
				"retry_count":  0,
				"completed_at": "2024-01-01T00:00:00Z",
			},
		},
		"started_at": "2024-01-01T00:00:00Z",
	}

	// Serialize and compute checksum multiple times
	data1, err := SerializeWorkflowState(stateMap)
	require.NoError(t, err)
	checksum1 := ComputeChecksum(data1)

	data2, err := SerializeWorkflowState(stateMap)
	require.NoError(t, err)
	checksum2 := ComputeChecksum(data2)

	// Checksums should be identical for same state
	assert.Equal(t, checksum1, checksum2)
}

func TestValidateChecksum_ValidChecksum(t *testing.T) {
	data := []byte("test data for validation")
	checksum := ComputeChecksum(data)

	// Valid checksum should pass
	err := ValidateChecksum(data, checksum)
	assert.NoError(t, err)
}

func TestValidateChecksum_InvalidChecksum(t *testing.T) {
	data := []byte("test data for validation")

	// Compute correct checksum
	correctChecksum := ComputeChecksum(data)

	// Modify data slightly
	corruptedData := []byte("test data for validatioN") // Changed last character

	// Validation should fail
	err := ValidateChecksum(corruptedData, correctChecksum)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "checksum mismatch")
}

func TestValidateChecksum_CorruptedChecksum(t *testing.T) {
	data := []byte("test data for validation")

	// Use a fake checksum
	fakeChecksum := "0000000000000000000000000000000000000000000000000000000000000000"

	// Validation should fail
	err := ValidateChecksum(data, fakeChecksum)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "checksum mismatch")
}

func TestValidateChecksum_EmptyChecksum(t *testing.T) {
	data := []byte("test data")

	// Empty checksum should fail
	err := ValidateChecksum(data, "")
	assert.Error(t, err)
}

func TestValidateChecksum_DetectsBitFlip(t *testing.T) {
	// Original data
	data := []byte("This is important checkpoint data that must not be corrupted")
	checksum := ComputeChecksum(data)

	// Verify original is valid
	err := ValidateChecksum(data, checksum)
	require.NoError(t, err)

	// Simulate a single bit flip (change one byte)
	corruptedData := make([]byte, len(data))
	copy(corruptedData, data)
	corruptedData[len(corruptedData)/2] ^= 0x01 // Flip lowest bit

	// Validation should detect corruption
	err = ValidateChecksum(corruptedData, checksum)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "checksum mismatch")
}

func TestSerializeWorkflowState_PreservesOrder(t *testing.T) {
	// Create state map with multiple nodes
	stateMap := map[string]any{
		"workflow_id": types.NewID().String(),
		"status":      "pending",
		"node_states": map[string]any{
			"node1": map[string]any{"status": "pending"},
			"node2": map[string]any{"status": "pending"},
			"node3": map[string]any{"status": "pending"},
		},
		"started_at": "2024-01-01T00:00:00Z",
	}

	// Serialize multiple times and verify checksums match
	checksums := make([]string, 5)
	for i := 0; i < 5; i++ {
		data, err := SerializeWorkflowState(stateMap)
		require.NoError(t, err)
		checksums[i] = ComputeChecksum(data)
	}

	// All checksums should be identical
	for i := 1; i < len(checksums); i++ {
		assert.Equal(t, checksums[0], checksums[i],
			"Checksum %d differs from checksum 0 - serialization order is not consistent", i)
	}
}

func TestDeserializeWorkflowState_HandlesNilFields(t *testing.T) {
	// Create minimal valid JSON with nil fields wrapped in envelope
	data := []byte(`{
		"version": 1,
		"data": {
			"workflow_id": "test-id",
			"status": "pending",
			"node_states": {},
			"execution_order": null,
			"started_at": "2024-01-01T00:00:00Z",
			"completed_at": null
		}
	}`)

	state, err := DeserializeWorkflowState(data)
	require.NoError(t, err)
	assert.NotNil(t, state)
	assert.Contains(t, state, "workflow_id")
	assert.Contains(t, state, "status")
	assert.Contains(t, state, "node_states")
}

func TestSerializeWorkflowState_WithComplexStructures(t *testing.T) {
	// Create state with complex nested structures
	stateMap := map[string]any{
		"workflow_id": types.NewID().String(),
		"status":      "running",
		"node_states": map[string]any{
			"node1": map[string]any{
				"status":      "completed",
				"retry_count": 0,
				"retry_params": map[string]any{
					"max_retries": 3,
					"backoff":     "exponential",
				},
			},
		},
		"execution_order": []string{"node1", "node2", "node3"},
		"started_at":      time.Now().Format(time.RFC3339),
	}

	// Serialize and deserialize
	data, err := SerializeWorkflowState(stateMap)
	require.NoError(t, err)

	restored, err := DeserializeWorkflowState(data)
	require.NoError(t, err)

	// Verify complex structures are preserved
	nodeStates, ok := restored["node_states"].(map[string]any)
	require.True(t, ok)

	node1, ok := nodeStates["node1"].(map[string]any)
	require.True(t, ok)

	retryParams, ok := node1["retry_params"].(map[string]any)
	require.True(t, ok)
	assert.Equal(t, float64(3), retryParams["max_retries"]) // JSON numbers are float64
	assert.Equal(t, "exponential", retryParams["backoff"])

	// Verify execution order
	execOrder, ok := restored["execution_order"].([]any)
	require.True(t, ok)
	assert.Len(t, execOrder, 3)
}
