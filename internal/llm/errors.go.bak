package llm

import (
	"errors"
	"fmt"
	"strings"
)

// ErrorType represents the type of error
type ErrorType string

const (
	ErrorTypeAuth          ErrorType = "authentication"
	ErrorTypeRateLimit     ErrorType = "rate_limit"
	ErrorTypeInvalidInput  ErrorType = "invalid_input"
	ErrorTypeProviderError ErrorType = "provider_error"
	ErrorTypeNetwork       ErrorType = "network"
	ErrorTypeTimeout       ErrorType = "timeout"
	ErrorTypeUnknown       ErrorType = "unknown"
)

// GibsonError represents a standardized error from the LLM subsystem
type GibsonError struct {
	Type       ErrorType
	Message    string
	Provider   string
	StatusCode int
	Err        error
}

// Error implements the error interface
func (e *GibsonError) Error() string {
	if e.Provider != "" {
		return fmt.Sprintf("[%s] %s: %s", e.Provider, e.Type, e.Message)
	}
	return fmt.Sprintf("%s: %s", e.Type, e.Message)
}

// Unwrap implements the error unwrapping interface
func (e *GibsonError) Unwrap() error {
	return e.Err
}

// IsAuthError checks if an error is an authentication error
func IsAuthError(err error) bool {
	var gibsonErr *GibsonError
	if errors.As(err, &gibsonErr) {
		return gibsonErr.Type == ErrorTypeAuth
	}
	return false
}

// IsRateLimitError checks if an error is a rate limit error
func IsRateLimitError(err error) bool {
	var gibsonErr *GibsonError
	if errors.As(err, &gibsonErr) {
		return gibsonErr.Type == ErrorTypeRateLimit
	}
	return false
}

// IsTimeoutError checks if an error is a timeout error
func IsTimeoutError(err error) bool {
	var gibsonErr *GibsonError
	if errors.As(err, &gibsonErr) {
		return gibsonErr.Type == ErrorTypeTimeout
	}
	return false
}

// NewAuthError creates a new authentication error
func NewAuthError(provider string, err error) *GibsonError {
	return &GibsonError{
		Type:     ErrorTypeAuth,
		Message:  "authentication failed",
		Provider: provider,
		Err:      err,
	}
}

// NewRateLimitError creates a new rate limit error
func NewRateLimitError(provider string, err error) *GibsonError {
	return &GibsonError{
		Type:     ErrorTypeRateLimit,
		Message:  "rate limit exceeded",
		Provider: provider,
		Err:      err,
	}
}

// NewInvalidInputError creates a new invalid input error
func NewInvalidInputError(provider string, message string) *GibsonError {
	return &GibsonError{
		Type:     ErrorTypeInvalidInput,
		Message:  message,
		Provider: provider,
	}
}

// NewProviderError creates a new provider error
func NewProviderError(provider string, err error) *GibsonError {
	return &GibsonError{
		Type:     ErrorTypeProviderError,
		Message:  fmt.Sprintf("provider error: %v", err),
		Provider: provider,
		Err:      err,
	}
}

// NewNetworkError creates a new network error
func NewNetworkError(provider string, err error) *GibsonError {
	return &GibsonError{
		Type:     ErrorTypeNetwork,
		Message:  "network error",
		Provider: provider,
		Err:      err,
	}
}

// NewTimeoutError creates a new timeout error
func NewTimeoutError(provider string, err error) *GibsonError {
	return &GibsonError{
		Type:     ErrorTypeTimeout,
		Message:  "request timeout",
		Provider: provider,
		Err:      err,
	}
}

// TranslateError translates a generic error into a GibsonError
func TranslateError(provider string, err error) error {
	if err == nil {
		return nil
	}

	var gibsonErr *GibsonError
	if errors.As(err, &gibsonErr) {
		return err
	}

	errStr := strings.ToLower(err.Error())

	if containsAny(errStr, []string{"authentication", "unauthorized", "invalid api key", "api key"}) {
		return NewAuthError(provider, err)
	}

	if containsAny(errStr, []string{"rate limit", "too many requests", "quota exceeded"}) {
		return NewRateLimitError(provider, err)
	}

	if containsAny(errStr, []string{"timeout", "deadline exceeded", "context deadline"}) {
		return NewTimeoutError(provider, err)
	}

	if containsAny(errStr, []string{"connection", "network", "dial", "unreachable"}) {
		return NewNetworkError(provider, err)
	}

	return NewProviderError(provider, err)
}

// containsAny checks if a string contains any of the provided substrings
func containsAny(s string, substrs []string) bool {
	for _, substr := range substrs {
		if strings.Contains(s, substr) {
			return true
		}
	}
	return false
}
